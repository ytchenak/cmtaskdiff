Execute (c:\utils\ccm_task_diff.pl:250): EXECUTE_CMD: ccm task -show synopsis 43731
Execute (c:\utils\ccm_task_diff.pl:250): OUTPUT_BEGIN
Task 43731: 640.4: bsm: forecast: diag: print bim data  w/o name

OUTPUT_END
Execute (c:\utils\ccm_task_diff.pl:247): EXECUTE_CMD: ccm task 43731 -show objs -u
Execute (c:\utils\ccm_task_diff.pl:247): OUTPUT_BEGIN
BimService.cpp#12.1.1:cpp:2 integrate yakovt                
BimServiceInfo.cpp#2.1.1:cpp:2 integrate yakovt             
BimServiceInfo.h#2.1.1:INC:2 integrate yakovt               
DefJobRepository.cpp#5.1.1:cpp:1 integrate yakovt           
SimGraphI.cpp#81.1.3.1.3:cpp:4 integrate yakovt             
SimGraphI_AddToSim.cpp#3.1.1.1.1.1.1:cpp:1 integrate yakovt 

OUTPUT_END
Execute (c:\utils\ccm_task_diff.pl:145): EXECUTE_CMD: ccm history BimService.cpp#12.1.1:cpp:2
Execute (c:\utils\ccm_task_diff.pl:145): OUTPUT_BEGIN
Object:  BimService.cpp#1 (cpp:2)
Owner:   yturgman
State:   sqa
Created: Sun Apr 15 22:20:46 2007
Task:    28409
Comment:
changed to sqa state by mntinteg
Predecessors:
Successors:
	BimService.cpp#2:cpp:2
*****************************************************************************
Object:  BimService.cpp#2 (cpp:2)
Owner:   yturgman
State:   sqa
Created: Sun May 20 17:23:33 2007
Task:    28799
Comment:
changed to sqa state by mntinteg
Predecessors:
	BimService.cpp#1:cpp:2
Successors:
	BimService.cpp#3:cpp:2
*****************************************************************************
Object:  BimService.cpp#3 (cpp:2)
Owner:   yakovt
State:   sqa
Created: Thu Jun 21 16:01:55 2007
Task:    29110
Comment:
changed to sqa state by mntinteg
Predecessors:
	BimService.cpp#2:cpp:2
Successors:
	BimService.cpp#4:cpp:2
*****************************************************************************
Object:  BimService.cpp#4 (cpp:2)
Owner:   yturgman
State:   sqa
Created: Tue Jul 10 13:06:51 2007
Task:    29288
Comment:
changed to sqa state by mntinteg
Predecessors:
	BimService.cpp#3:cpp:2
Successors:
	BimService.cpp#5:cpp:2
*****************************************************************************
Object:  BimService.cpp#5 (cpp:2)
Owner:   yturgman
State:   sqa
Created: Thu Jul 12 14:31:18 2007
Task:    29315
Comment:
by tadmon
Predecessors:
	BimService.cpp#4:cpp:2
Successors:
	BimService.cpp#6:cpp:2
*****************************************************************************
Object:  BimService.cpp#6 (cpp:2)
Owner:   yakovt
State:   sqa
Created: Wed Jul 25 10:50:47 2007
Task:    29458
Comment:
by tadmon
Predecessors:
	BimService.cpp#5:cpp:2
Successors:
	BimService.cpp#7:cpp:2
*****************************************************************************
Object:  BimService.cpp#7 (cpp:2)
Owner:   tadmon
State:   sqa
Created: Wed Aug 15 13:17:51 2007
Task:    29568
Comment:
by tadmon
Predecessors:
	BimService.cpp#6:cpp:2
Successors:
	BimService.cpp#7.1.1:cpp:2
*****************************************************************************
Object:  BimService.cpp#7.1.1 (cpp:2)
Owner:   tadmon
State:   sqa
Created: Sun Sep 02 18:44:24 2007
Task:    29905
Comment:
by tadmon
Predecessors:
	BimService.cpp#7:cpp:2
Successors:
	BimService.cpp#7.1.2:cpp:2
*****************************************************************************
Object:  BimService.cpp#7.1.2 (cpp:2)
Owner:   yakovt
State:   sqa
Created: Tue Sep 11 18:04:31 2007
Task:    30062
Comment:
by tadmon
Predecessors:
	BimService.cpp#7.1.1:cpp:2
Successors:
	BimService.cpp#7.1.3:cpp:2
*****************************************************************************
Object:  BimService.cpp#7.1.3 (cpp:2)
Owner:   eyals
State:   sqa
Created: Tue Sep 18 18:14:15 2007
Task:    30117
Comment:
by tadmon
Predecessors:
	BimService.cpp#7.1.2:cpp:2
Successors:
	BimService.cpp#8:cpp:2
*****************************************************************************
Object:  BimService.cpp#8 (cpp:2)
Owner:   yakovt
State:   sqa
Created: Thu Jan 17 11:36:48 2008
Task:    32097
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	BimService.cpp#7.1.3:cpp:2
Successors:
	BimService.cpp#9:cpp:2
*****************************************************************************
Object:  BimService.cpp#9 (cpp:2)
Owner:   yakovt
State:   released
Created: Tue Apr 29 17:37:51 2008
Task:    34148
Comment:
changed to sqa state by GAP automatic approval

Predecessors:
	BimService.cpp#8:cpp:2
Successors:
	BimService.cpp#10:cpp:2
	BimService.cpp#9.1.1:cpp:2
*****************************************************************************
Object:  BimService.cpp#10 (cpp:2)
Owner:   yakovt
State:   sqa
Created: Thu Jul 31 18:43:22 2008
Task:    35469
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	BimService.cpp#9:cpp:2
Successors:
	BimService.cpp#11:cpp:2
*****************************************************************************
Object:  BimService.cpp#9.1.1 (cpp:2)
Owner:   yturgman
State:   sqa
Created: Mon Aug 11 20:56:10 2008
Task:    33515
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	BimService.cpp#9:cpp:2
Successors:
	BimService.cpp#11:cpp:2
*****************************************************************************
Object:  BimService.cpp#11 (cpp:2)
Owner:   yakovt
State:   sqa
Created: Sun Sep 14 17:08:57 2008
Task:    35469
Comment:
Merged 'BimService.cpp#10' with 'BimService.cpp#9.1.1'.
changed to sqa state by GAP automatic approval
Predecessors:
	BimService.cpp#10:cpp:2
	BimService.cpp#9.1.1:cpp:2
Successors:
	BimService.cpp#12:cpp:2
*****************************************************************************
Object:  BimService.cpp#12 (cpp:2)
Owner:   tadmon
State:   released
Created: Thu Nov 13 11:18:40 2008
Task:    36564
Comment:
changed to sqa state by GAP automatic approval

Predecessors:
	BimService.cpp#11:cpp:2
Successors:
	BimService.cpp#13:cpp:2
	BimService.cpp#12.1.1:cpp:2
*****************************************************************************
Object:  BimService.cpp#13 (cpp:2)
Owner:   evgenir
State:   sqa
Created: Wed Jul 29 12:14:14 2009
Task:    40584
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	BimService.cpp#12:cpp:2
Successors:
	BimService.cpp#14:cpp:2
	BimService.cpp#13.1.1:cpp:2
*****************************************************************************
Object:  BimService.cpp#14 (cpp:2)
Owner:   tadmon
State:   working
Created: Sun Nov 15 16:24:12 2009
Task:    42666
Comment:

Predecessors:
	BimService.cpp#13:cpp:2
Successors:
*****************************************************************************
Object:  BimService.cpp#12.1.1 (cpp:2)
Owner:   yakovt
State:   integrate
Created: Mon Dec 14 13:26:45 2009
Task:    43731
Comment:
<void>
Predecessors:
	BimService.cpp#12:cpp:2
Successors:
	BimService.cpp#13.1.1:cpp:2
*****************************************************************************
Object:  BimService.cpp#13.1.1 (cpp:2)
Owner:   yakovt
State:   integrate
Created: Wed Dec 23 18:54:45 2009
Task:    43956
Comment:

Predecessors:
	BimService.cpp#13:cpp:2
	BimService.cpp#12.1.1:cpp:2
Successors:
*****************************************************************************

OUTPUT_END
Execute (c:\utils\ccm_task_diff.pl:157): EXECUTE_CMD: ccm finduse BimService.cpp#13.1.1:cpp:2
Execute (c:\utils\ccm_task_diff.pl:157): OUTPUT_BEGIN
BimService.cpp#13.1.1 integrate yakovt cpp ECSNT 2 43956
	ECSNT\ForecastService\BimService.cpp#13.1.1@ECSNT#700yakovt-win:project:4
	ECSNT\ForecastService\BimService.cpp#13.1.1@ECSNT#700_hani_win:project:4
	ECSNT\ForecastService\BimService.cpp#13.1.1@ECSNT#bldrem_EM700_U_CI:project:4
	ECSNT\ForecastService\BimService.cpp#13.1.1@ECSNT#bldrem_EM700_W_CI:project:4
	ECSNT\ForecastService\BimService.cpp#13.1.1@ECSNT#galia700windows2:project:4

OUTPUT_END
Execute (c:\utils\ccm_task_diff.pl:174): EXECUTE_CMD: ccm cat BimService.cpp#12.1.1:cpp:2
Execute (c:\utils\ccm_task_diff.pl:174): OUTPUT_BEGIN
/**********************************************************************
*                 Copyright BMC Software Inc., 
*     as an unpublished licensed work. All rights reserved.
*     -----------------------------------------------------
*
*	C++ Source   : BimService.cpp
*	Instance     : 1
*	Created by   : yakovt
*	Date created : Sun Dec 10 12:58:29 2006
*	Description  : 
*
**********************************************************************/
#ifndef lint /* Automatically created, Please don't modify */
static const char _BimService_cpp_cpp[] = "@(#) %name: BimService.cpp %, %cvtype: cpp %, %date_modified: %, %derived_by: yakovt %, %version: 12.1.1 %, %instance: 2 %, %compiled: "__DATE__", "__TIME__" %, %file_path: "__FILE__ " %(#)@";
#endif

#include "stdafx.h"

#include <libfcengine/BimSimulJobI.h>
#include <ForecastCommon/FcException.h>
#include <ForecastService/BimService.h>
#include <em_foundations/EmHelper.h>
#include <ForecastCommon/FcException.h>
#include <libfcengine/SchedGroupI.h>
#include <libfcengine/ConditionI.h>

#include "Common/TimeConstants.h"
DIAG_REGISTER_MODULE;


namespace	Forecast {
namespace	Service {


//////////////////////////////////////////////////////////////////////////
//
//BimService::BimService()
//: m_JobOrderId(0)
//, m_IsSigned(false)
//{
//}

BimService::BimService(const SimulJobI* pBimSimulJob):
							m_OrderId(pBimSimulJob->GetOrderID()),
                            m_DataCenterName(pBimSimulJob->GetDataCenter()->GetDataCenterName())
{
}

BimService::BimService(const std::string& DcName,int oid):m_DataCenterName(DcName),m_OrderId(oid)
{
}


//////////////////////////////////////////////////////////////////////////
// data definition
const std::string& BimService::GetServiceName() const{ 
	return m_ServiceInfo.GetVar("SERVICE_NAME"); 
}

const std::string& BimService::GetPriority() const{ 
	return m_ServiceInfo.GetVar("SERVICE_PRIORITY"); 
}


//////////////////////////////////////////////////////////////////////////
// set service definition from BIM definition form (auto-edit variable)
//
void BimService::SetFromDBJob( const bsm::DefJob& dbjob)
{
	DBG_FNC_ENTER("BimService::SetFromDBJob");

	m_ServiceInfo.SetFromDBJob(dbjob);



	EM_ASSERT ( m_ServiceInfo.HasVars(), "service w/o vars, job_name=" + em::tos(dbjob.GetName()) + ", table_id=" + em::tos(dbjob.Base().f_DBF_DEF_JOB_TABLE_ID) );
	
	//bypass for case when service definition has no service priority. it seems like BIM form bug. currently set to 3 (default)
	if( m_ServiceInfo.HasVars() && !m_ServiceInfo.HasVar("SERVICE_PRIORITY") ) 
	{
		DIAG_PDEF(DIAG_W, "service " << GetServiceName() <<", job name " << dbjob.GetName() <<  " has no priority");

		m_ServiceInfo.SetVar("SERVICE_PRIORITY", "3");
	}

}


//////////////////////////////////////////////////////////////////////////
// get the service due time in minutes
//
// input can be one from:
// +HH:MM
// HH:MM
// HH:MM,DD
//
// return: parsed due time
// 
TimeValue BimService::ParseDueTime(const std::string& due_time_string, TimeValue OrderTime,
								   TimeValue NewDayTimeTz,int NewDay)
{
	DBG_FNC_ENTER("BimService::ParseDueTime");

	if (due_time_string.empty()) 
	{
		DIAG_PDEF(DIAG_E, "oid " << this->GetJobOrderId() << " Due time is missing for the service" );
		return TimeValue::NO_TIME;
	}

	const bool relative_to_odate = (due_time_string[0] == '+');
	size_t start_pos = 0;
	if (relative_to_odate == true)
	{
		++start_pos;
	}

	// parse hour and min from time
	int hour = ACE_OS::atoi(due_time_string.c_str() + start_pos);
	size_t pos = due_time_string.find(':', start_pos);
	if (pos == std::string::npos)
		return TimeValue::NO_TIME;
	int minutes = ACE_OS::atoi(due_time_string.c_str() + pos + 1);
	int days = 0;

	TimeValue DueTime;

	if (relative_to_odate == true)
	{
		// +HH:MM case
		// time + order time = relative time
		DueTime=OrderTime;
		DueTime+=(hour * SIMUL_MINS *SIMUL_SECS_MULTIPLIER) + minutes*SIMUL_SECS_MULTIPLIER;
		return DueTime;
	}

	DueTime=NewDayTimeTz;
	// HH:MM,DD case
	size_t date_pos = due_time_string.find_first_of(",", pos);
	if(date_pos != std::string::npos)
	{
		days = ACE_OS::atoi(due_time_string.c_str() + date_pos + 1);
	}

	int time_only = (hour * SIMUL_MINS * SIMUL_SECS_MULTIPLIER) + minutes*SIMUL_SECS_MULTIPLIER;
	if (time_only <= NewDay)
	{
		time_only += (SIMUL_RESOLUTION ); // add 24 hours
	}
	time_only-=NewDay;
	DueTime += time_only + (days * SIMUL_RESOLUTION);

	return DueTime;
}


//////////////////////////////////////////////////////////////////////////
// GenBimStatusData
//////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////
// generate sequence of BIM jobs using bim method (bim indicators)
//
void BimService::GenBimJobs(
	const SimulJobI* serviceJob,
	SimulJobISeqConst& bimJobs
	)
{
	DBG_FNC_ENTER("BimService::GenBimJobs");

	const BimSimulJobI* bim_service_job = dynamic_cast<const BimSimulJobI*>(serviceJob);

	for( AutoIter<const SimulJobI> it = bim_service_job->GetBimJobsIter(); it.HasMore(); ++it )
	{
		const SimulJobI* job = (*it);
		bimJobs.push_back(job);
	}

}



//////////////////////////////////////////////////////////////////////////
// Critical jobs
//////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////
// return all critical jobs for the service-job. 
//
void BimService::GenBimCritJobs(
								SimulJobI* serviceJob,
								SimulJobISeqConst& bimJobs,
								TimeValue::T min_gap
								) 
{
	DBG_FNC_ENTER("BimService::GenBimCritJobs");
	DIAG_PDEF(DIAG_I, "serviceJob: " << serviceJob->GetJobName() << " min_gap: " << min_gap);

	BimSimulJobI* bim_job = dynamic_cast<BimSimulJobI*>(serviceJob);
	bim_job->UpdateServiceCriticalJobs(bimJobs, min_gap);
}


//////////////////////////////////////////////////////////////////////////
// set the BimStatusData
//
void BimService::Calculate(const SimulJobI& serviceJob)
{
	DBG_FNC_ENTER("BimService::Calculate");

	m_StatusData.Clear(); //clear all status data (can be re-simulation)

	// locate bim service in simulation engine
	//SimulJobI* serviceJob = simulator->GetJobByOid(this->GetJobOrderId());
	//if (serviceJob == NULL)
	//	throw Common::FcException("oid " + em::tos(this->GetJobOrderId()) + " job not found in simulation");

	m_IsSigned = serviceJob.GetSigned();

	int newDayTime = serviceJob.GetDataCenter()->GetNewDayInSecFromMidnight();

	// OrderTime
	m_StatusData.m_OrderTime = serviceJob.GetOrderObjTime();

	// DueTime
	const std::string& strDueTime = m_ServiceInfo.GetVar("DUE_TIME");
	m_StatusData.m_DueTime = ParseDueTime(strDueTime, m_StatusData.m_OrderTime,
		                                  serviceJob.GetJobNewDayTime(),newDayTime);
	EM_ASSERT(m_StatusData.m_DueTime.IsTimeOK(),"oid " + em::tos(this->GetJobOrderId()) + " fail to parse due time: "+strDueTime);

	// EstimateEndTime (it is start of the service job)
	unsigned int nExecTimes = serviceJob.GetNumberOfExecTime();
	if (nExecTimes >  0)
		m_StatusData.m_EstimateEndTime = serviceJob.GetStartedTimeIx(nExecTimes - 1);

	// CtmName
	m_StatusData.m_CtmName = serviceJob.GetDataCenter()->GetDataCenterName();

	//NumberOfAllJobs;
	//NumberOfCompletedJobs;
	//NumberOfJobsWithoutStatistic;

	const BimSimulJobI& BimJob=dynamic_cast<const BimSimulJobI&>(serviceJob);
	m_StatusData.m_NumberOfAllJobs = BimJob.GetNumberOfJobs();//bimJobs.size();
	m_StatusData.m_NumberOfCompletedJobs = 0;
	m_StatusData.m_NumberOfJobsWithoutStatistic = 0;

	AutoIter<const SimulJobI> BimJobsIter=BimJob.GetBimJobsIter();
	while(*BimJobsIter!=NULL)
	{
		const SimulJobI* job = (*BimJobsIter);
		unsigned int nExecTimes = job->GetNumberOfExecTime();
		if( nExecTimes  > 0 && job->GetEndedTimeIx(nExecTimes-1).IsTimeOK())
			++m_StatusData.m_NumberOfCompletedJobs;

		if( job->IsThereNoStatistic() )
			++m_StatusData.m_NumberOfJobsWithoutStatistic;
		++BimJobsIter;
	}

	// status
	m_StatusData.m_Status = CalculateBimServiceStatus(newDayTime);

}

//////////////////////////////////////////////////////////////////////////
// calculate and return the bim service status
//
BimServiceStatus BimService::CalculateBimServiceStatus(TimeValue DcNewDayTimeTz)
{
	DBG_FNC_ENTER("BimService::CalculateBimServiceStatus");

	BimServiceStatus status;

	TimeValue dueTime = GetDueTime();
	TimeValue estimateEndTime = GetEstimateEndTime();


	DIAG_PDEF(DIAG_I, " oid " << this->GetJobOrderId()
		<< " dueTime: " << dueTime.ToString() 
		<< " estimateEndTime: " << estimateEndTime.ToString()
		<< " newDayTime: " << DcNewDayTimeTz.ToString()
		);

	if(0); //cases:

	// case: service finished before due time
	else if( estimateEndTime.IsTimeOK() && estimateEndTime <= dueTime )
	{
		if( this->HasJobs() ) //running service has some dependence jobs (not only service job itself)
		status |= BimServiceStatus::en_ServiceCompleted;
		else
			status |= BimServiceStatus::en_ServiceHasNoJobs;
	}

	// case: service is finished after due time
	else if( estimateEndTime.IsTimeOK() && estimateEndTime > dueTime )
	{
		status |= BimServiceStatus::en_ServiceDelay; //it is completed late but we want see it as 'late'
	}

	// case: service did not  finish during simulation time-frame and its due-time is into this frame
	else if( estimateEndTime.IsGreEqNoTime() && dueTime <= (DcNewDayTimeTz+SIMUL_RESOLUTION) )
	{
		status |= BimServiceStatus::en_ServiceDelay;
	}

	// case: service did not  finish during simulation time-frame and its due-time is out from this frame
	else if( estimateEndTime.IsGreEqNoTime() && dueTime > (DcNewDayTimeTz+SIMUL_RESOLUTION) )
	{
		if( this->HasJobs() ) //running service has some dependence jobs (not only service job itself)
			status |= BimServiceStatus::en_ServiceRunning;
		else
			status |= BimServiceStatus::en_ServiceHasNoJobs;
	}
	else
		throw Common::FcException("logical: non-handled service condition",-1, __FILE__,__LINE__);

	return status;
}

//////////////////////////////////////////////////////////////////////////
// Get jobs that influence progress percentage relative to total job number
//
float BimService::GetJobsProgressPercentage() const
{
	if (m_StatusData.m_NumberOfAllJobs == 0)
		return 0;

	float percentage = (float)m_StatusData.m_NumberOfCompletedJobs / (float)m_StatusData.m_NumberOfAllJobs * 100;

	return percentage;
}

//////////////////////////////////////////////////////////////////////////
//
bool BimService::HasJobs() const
{
	//number of service job includes the service itself. 
	// so when number of job is 1 it mean there are no jobs for this service
	return m_StatusData.m_NumberOfAllJobs > 1; 
}

}}	// Forecast::Service




OUTPUT_END
Execute (c:\utils\ccm_task_diff.pl:128): EXECUTE_CMD: ccm diff -vc  BimService.cpp#12.1.1:cpp:2
Execute (c:\utils\ccm_task_diff.pl:128): OUTPUT_BEGIN
Attribute name            BimService.cpp#12          BimService.cpp#12.1.1     
------------------------- -------------------------- --------------------------
create_time               Thu Nov 13 11:18:40 2008   Mon Dec 14 13:26:45 2009  
modify_time               Thu Mar 05 13:09:25 2009   Wed Dec 23 13:25:02 2009  
owner                     tadmon                     yakovt                    
release                   6.4.0.02                   6.4.0.04                  
status                    released                   integrate                 
version                   12                         12.1.1                    
comment                   changed to sqa state by... <doesn't exist>           
source_create_time        Thu Nov 13 11:18:41 2008   Mon Dec 14 13:26:46 2009  
source_modify_time        Thu Nov 13 11:23:28 2008   Thu Dec 17 18:01:58 2009  

===============================================================================
Associated tasks differs:

BimService.cpp#12
36564: Forecast adjustments

BimService.cpp#12.1.1
43731: 640.4: bsm: forecast: diag: print bim data  w/o name

===============================================================================
Text attribute 'source' differs:

14c14
< static const char _BimService_cpp_cpp[] = "@(#) %name: BimService.cpp %, %cvtype: cpp %, %date_modified: %, %derived_by: tadmon %, %version: 12 %, %instance: 2 %, %compiled: "__DATE__", "__TIME__" %, %file_path: "__FILE__ " %(#)@";
---
> static const char _BimService_cpp_cpp[] = "@(#) %name: BimService.cpp %, %cvtype: cpp %, %date_modified: %, %derived_by: yakovt %, %version: 12.1.1 %, %instance: 2 %, %compiled: "__DATE__", "__TIME__" %, %file_path: "__FILE__ " %(#)@";
73a74,77
> 
> 
> 	EM_ASSERT ( m_ServiceInfo.HasVars(), "service w/o vars, job_name=" + em::tos(dbjob.GetName()) + ", table_id=" + em::tos(dbjob.Base().f_DBF_DEF_JOB_TABLE_ID) );
> 	
75c79
< 	if( !m_ServiceInfo.HasVar("SERVICE_PRIORITY") ) 
---
> 	if( m_ServiceInfo.HasVars() && !m_ServiceInfo.HasVar("SERVICE_PRIORITY") ) 
77c81
< 		DIAG_PDEF(DIAG_W, "service " << GetServiceName() << " has no priority");
---
> 		DIAG_PDEF(DIAG_W, "service " << GetServiceName() <<", job name " << dbjob.GetName() <<  " has no priority");

===============================================================================
Text attribute 'status_log' differs:

1,4c1,2
< Thu Nov 13 11:18:41 2008: Status set to 'working' by tadmon in role developer
< Sun Nov 16 09:14:47 2008: Status set to 'integrate' by tadmon in role developer
< Mon Nov 17 09:49:22 2008: Status set to 'sqa' by bldrem in role build_mgr
< Thu Mar  5 13:09:25 2009: Status set to 'released' by ccm_root in role ccm_admin
---
> Mon Dec 14 13:26:46 2009: Status set to 'working' by yakovt in role developer
> Wed Dec 23 13:25:02 2009: Status set to 'integrate' by yakovt in role developer


OUTPUT_END
Execute (c:\utils\ccm_task_diff.pl:174): EXECUTE_CMD: ccm cat BimService.cpp#12:cpp:2
Execute (c:\utils\ccm_task_diff.pl:174): OUTPUT_BEGIN
/**********************************************************************
*                 Copyright BMC Software Inc., 
*     as an unpublished licensed work. All rights reserved.
*     -----------------------------------------------------
*
*	C++ Source   : BimService.cpp
*	Instance     : 1
*	Created by   : yakovt
*	Date created : Sun Dec 10 12:58:29 2006
*	Description  : 
*
**********************************************************************/
#ifndef lint /* Automatically created, Please don't modify */
static const char _BimService_cpp_cpp[] = "@(#) %name: BimService.cpp %, %cvtype: cpp %, %date_modified: %, %derived_by: tadmon %, %version: 12 %, %instance: 2 %, %compiled: "__DATE__", "__TIME__" %, %file_path: "__FILE__ " %(#)@";
#endif

#include "stdafx.h"

#include <libfcengine/BimSimulJobI.h>
#include <ForecastCommon/FcException.h>
#include <ForecastService/BimService.h>
#include <em_foundations/EmHelper.h>
#include <ForecastCommon/FcException.h>
#include <libfcengine/SchedGroupI.h>
#include <libfcengine/ConditionI.h>

#include "Common/TimeConstants.h"
DIAG_REGISTER_MODULE;


namespace	Forecast {
namespace	Service {


//////////////////////////////////////////////////////////////////////////
//
//BimService::BimService()
//: m_JobOrderId(0)
//, m_IsSigned(false)
//{
//}

BimService::BimService(const SimulJobI* pBimSimulJob):
							m_OrderId(pBimSimulJob->GetOrderID()),
                            m_DataCenterName(pBimSimulJob->GetDataCenter()->GetDataCenterName())
{
}

BimService::BimService(const std::string& DcName,int oid):m_DataCenterName(DcName),m_OrderId(oid)
{
}


//////////////////////////////////////////////////////////////////////////
// data definition
const std::string& BimService::GetServiceName() const{ 
	return m_ServiceInfo.GetVar("SERVICE_NAME"); 
}

const std::string& BimService::GetPriority() const{ 
	return m_ServiceInfo.GetVar("SERVICE_PRIORITY"); 
}


//////////////////////////////////////////////////////////////////////////
// set service definition from BIM definition form (auto-edit variable)
//
void BimService::SetFromDBJob( const bsm::DefJob& dbjob)
{
	DBG_FNC_ENTER("BimService::SetFromDBJob");

	m_ServiceInfo.SetFromDBJob(dbjob);

	//bypass for case when service definition has no service priority. it seems like BIM form bug. currently set to 3 (default)
	if( !m_ServiceInfo.HasVar("SERVICE_PRIORITY") ) 
	{
		DIAG_PDEF(DIAG_W, "service " << GetServiceName() << " has no priority");

		m_ServiceInfo.SetVar("SERVICE_PRIORITY", "3");
	}

}


//////////////////////////////////////////////////////////////////////////
// get the service due time in minutes
//
// input can be one from:
// +HH:MM
// HH:MM
// HH:MM,DD
//
// return: parsed due time
// 
TimeValue BimService::ParseDueTime(const std::string& due_time_string, TimeValue OrderTime,
								   TimeValue NewDayTimeTz,int NewDay)
{
	DBG_FNC_ENTER("BimService::ParseDueTime");

	if (due_time_string.empty()) 
	{
		DIAG_PDEF(DIAG_E, "oid " << this->GetJobOrderId() << " Due time is missing for the service" );
		return TimeValue::NO_TIME;
	}

	const bool relative_to_odate = (due_time_string[0] == '+');
	size_t start_pos = 0;
	if (relative_to_odate == true)
	{
		++start_pos;
	}

	// parse hour and min from time
	int hour = ACE_OS::atoi(due_time_string.c_str() + start_pos);
	size_t pos = due_time_string.find(':', start_pos);
	if (pos == std::string::npos)
		return TimeValue::NO_TIME;
	int minutes = ACE_OS::atoi(due_time_string.c_str() + pos + 1);
	int days = 0;

	TimeValue DueTime;

	if (relative_to_odate == true)
	{
		// +HH:MM case
		// time + order time = relative time
		DueTime=OrderTime;
		DueTime+=(hour * SIMUL_MINS *SIMUL_SECS_MULTIPLIER) + minutes*SIMUL_SECS_MULTIPLIER;
		return DueTime;
	}

	DueTime=NewDayTimeTz;
	// HH:MM,DD case
	size_t date_pos = due_time_string.find_first_of(",", pos);
	if(date_pos != std::string::npos)
	{
		days = ACE_OS::atoi(due_time_string.c_str() + date_pos + 1);
	}

	int time_only = (hour * SIMUL_MINS * SIMUL_SECS_MULTIPLIER) + minutes*SIMUL_SECS_MULTIPLIER;
	if (time_only <= NewDay)
	{
		time_only += (SIMUL_RESOLUTION ); // add 24 hours
	}
	time_only-=NewDay;
	DueTime += time_only + (days * SIMUL_RESOLUTION);

	return DueTime;
}


//////////////////////////////////////////////////////////////////////////
// GenBimStatusData
//////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////
// generate sequence of BIM jobs using bim method (bim indicators)
//
void BimService::GenBimJobs(
	const SimulJobI* serviceJob,
	SimulJobISeqConst& bimJobs
	)
{
	DBG_FNC_ENTER("BimService::GenBimJobs");

	const BimSimulJobI* bim_service_job = dynamic_cast<const BimSimulJobI*>(serviceJob);

	for( AutoIter<const SimulJobI> it = bim_service_job->GetBimJobsIter(); it.HasMore(); ++it )
	{
		const SimulJobI* job = (*it);
		bimJobs.push_back(job);
	}

}



//////////////////////////////////////////////////////////////////////////
// Critical jobs
//////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////
// return all critical jobs for the service-job. 
//
void BimService::GenBimCritJobs(
								SimulJobI* serviceJob,
								SimulJobISeqConst& bimJobs,
								TimeValue::T min_gap
								) 
{
	DBG_FNC_ENTER("BimService::GenBimCritJobs");
	DIAG_PDEF(DIAG_I, "serviceJob: " << serviceJob->GetJobName() << " min_gap: " << min_gap);

	BimSimulJobI* bim_job = dynamic_cast<BimSimulJobI*>(serviceJob);
	bim_job->UpdateServiceCriticalJobs(bimJobs, min_gap);
}


//////////////////////////////////////////////////////////////////////////
// set the BimStatusData
//
void BimService::Calculate(const SimulJobI& serviceJob)
{
	DBG_FNC_ENTER("BimService::Calculate");

	m_StatusData.Clear(); //clear all status data (can be re-simulation)

	// locate bim service in simulation engine
	//SimulJobI* serviceJob = simulator->GetJobByOid(this->GetJobOrderId());
	//if (serviceJob == NULL)
	//	throw Common::FcException("oid " + em::tos(this->GetJobOrderId()) + " job not found in simulation");

	m_IsSigned = serviceJob.GetSigned();

	int newDayTime = serviceJob.GetDataCenter()->GetNewDayInSecFromMidnight();

	// OrderTime
	m_StatusData.m_OrderTime = serviceJob.GetOrderObjTime();

	// DueTime
	const std::string& strDueTime = m_ServiceInfo.GetVar("DUE_TIME");
	m_StatusData.m_DueTime = ParseDueTime(strDueTime, m_StatusData.m_OrderTime,
		                                  serviceJob.GetJobNewDayTime(),newDayTime);
	EM_ASSERT(m_StatusData.m_DueTime.IsTimeOK(),"oid " + em::tos(this->GetJobOrderId()) + " fail to parse due time: "+strDueTime);

	// EstimateEndTime (it is start of the service job)
	unsigned int nExecTimes = serviceJob.GetNumberOfExecTime();
	if (nExecTimes >  0)
		m_StatusData.m_EstimateEndTime = serviceJob.GetStartedTimeIx(nExecTimes - 1);

	// CtmName
	m_StatusData.m_CtmName = serviceJob.GetDataCenter()->GetDataCenterName();

	//NumberOfAllJobs;
	//NumberOfCompletedJobs;
	//NumberOfJobsWithoutStatistic;

	const BimSimulJobI& BimJob=dynamic_cast<const BimSimulJobI&>(serviceJob);
	m_StatusData.m_NumberOfAllJobs = BimJob.GetNumberOfJobs();//bimJobs.size();
	m_StatusData.m_NumberOfCompletedJobs = 0;
	m_StatusData.m_NumberOfJobsWithoutStatistic = 0;

	AutoIter<const SimulJobI> BimJobsIter=BimJob.GetBimJobsIter();
	while(*BimJobsIter!=NULL)
	{
		const SimulJobI* job = (*BimJobsIter);
		unsigned int nExecTimes = job->GetNumberOfExecTime();
		if( nExecTimes  > 0 && job->GetEndedTimeIx(nExecTimes-1).IsTimeOK())
			++m_StatusData.m_NumberOfCompletedJobs;

		if( job->IsThereNoStatistic() )
			++m_StatusData.m_NumberOfJobsWithoutStatistic;
		++BimJobsIter;
	}

	// status
	m_StatusData.m_Status = CalculateBimServiceStatus(newDayTime);

}

//////////////////////////////////////////////////////////////////////////
// calculate and return the bim service status
//
BimServiceStatus BimService::CalculateBimServiceStatus(TimeValue DcNewDayTimeTz)
{
	DBG_FNC_ENTER("BimService::CalculateBimServiceStatus");

	BimServiceStatus status;

	TimeValue dueTime = GetDueTime();
	TimeValue estimateEndTime = GetEstimateEndTime();


	DIAG_PDEF(DIAG_I, " oid " << this->GetJobOrderId()
		<< " dueTime: " << dueTime.ToString() 
		<< " estimateEndTime: " << estimateEndTime.ToString()
		<< " newDayTime: " << DcNewDayTimeTz.ToString()
		);

	if(0); //cases:

	// case: service finished before due time
	else if( estimateEndTime.IsTimeOK() && estimateEndTime <= dueTime )
	{
		if( this->HasJobs() ) //running service has some dependence jobs (not only service job itself)
		status |= BimServiceStatus::en_ServiceCompleted;
		else
			status |= BimServiceStatus::en_ServiceHasNoJobs;
	}

	// case: service is finished after due time
	else if( estimateEndTime.IsTimeOK() && estimateEndTime > dueTime )
	{
		status |= BimServiceStatus::en_ServiceDelay; //it is completed late but we want see it as 'late'
	}

	// case: service did not  finish during simulation time-frame and its due-time is into this frame
	else if( estimateEndTime.IsGreEqNoTime() && dueTime <= (DcNewDayTimeTz+SIMUL_RESOLUTION) )
	{
		status |= BimServiceStatus::en_ServiceDelay;
	}

	// case: service did not  finish during simulation time-frame and its due-time is out from this frame
	else if( estimateEndTime.IsGreEqNoTime() && dueTime > (DcNewDayTimeTz+SIMUL_RESOLUTION) )
	{
		if( this->HasJobs() ) //running service has some dependence jobs (not only service job itself)
			status |= BimServiceStatus::en_ServiceRunning;
		else
			status |= BimServiceStatus::en_ServiceHasNoJobs;
	}
	else
		throw Common::FcException("logical: non-handled service condition",-1, __FILE__,__LINE__);

	return status;
}

//////////////////////////////////////////////////////////////////////////
// Get jobs that influence progress percentage relative to total job number
//
float BimService::GetJobsProgressPercentage() const
{
	if (m_StatusData.m_NumberOfAllJobs == 0)
		return 0;

	float percentage = (float)m_StatusData.m_NumberOfCompletedJobs / (float)m_StatusData.m_NumberOfAllJobs * 100;

	return percentage;
}

//////////////////////////////////////////////////////////////////////////
//
bool BimService::HasJobs() const
{
	//number of service job includes the service itself. 
	// so when number of job is 1 it mean there are no jobs for this service
	return m_StatusData.m_NumberOfAllJobs > 1; 
}

}}	// Forecast::Service




OUTPUT_END
Execute (c:\utils\ccm_task_diff.pl:228): diff -u C:/Tasks/43731/old/BimService.cpp C:/Tasks/43731/new/BimService.cpp
Execute (c:\utils\ccm_task_diff.pl:228): OUTPUT_BEGIN
--- C:/Tasks/43731/old/BimService.cpp	Thu Dec 24 11:29:06 2009
+++ C:/Tasks/43731/new/BimService.cpp	Thu Dec 24 11:29:05 2009
@@ -11,7 +11,7 @@
 *
 **********************************************************************/
 #ifndef lint /* Automatically created, Please don't modify */
-static const char _BimService_cpp_cpp[] = "@(#) %name: BimService.cpp %, %cvtype: cpp %, %date_modified: %, %derived_by: tadmon %, %version: 12 %, %instance: 2 %, %compiled: "__DATE__", "__TIME__" %, %file_path: "__FILE__ " %(#)@";
+static const char _BimService_cpp_cpp[] = "@(#) %name: BimService.cpp %, %cvtype: cpp %, %date_modified: %, %derived_by: yakovt %, %version: 12.1.1 %, %instance: 2 %, %compiled: "__DATE__", "__TIME__" %, %file_path: "__FILE__ " %(#)@";
 #endif
 
 #include "stdafx.h"
@@ -71,10 +71,14 @@
 
 	m_ServiceInfo.SetFromDBJob(dbjob);
 
+
+
+	EM_ASSERT ( m_ServiceInfo.HasVars(), "service w/o vars, job_name=" + em::tos(dbjob.GetName()) + ", table_id=" + em::tos(dbjob.Base().f_DBF_DEF_JOB_TABLE_ID) );
+	
 	//bypass for case when service definition has no service priority. it seems like BIM form bug. currently set to 3 (default)
-	if( !m_ServiceInfo.HasVar("SERVICE_PRIORITY") ) 
+	if( m_ServiceInfo.HasVars() && !m_ServiceInfo.HasVar("SERVICE_PRIORITY") ) 
 	{
-		DIAG_PDEF(DIAG_W, "service " << GetServiceName() << " has no priority");
+		DIAG_PDEF(DIAG_W, "service " << GetServiceName() <<", job name " << dbjob.GetName() <<  " has no priority");
 
 		m_ServiceInfo.SetVar("SERVICE_PRIORITY", "3");
 	}

OUTPUT_END
Execute (c:\utils\ccm_task_diff.pl:145): EXECUTE_CMD: ccm history BimServiceInfo.cpp#2.1.1:cpp:2
Execute (c:\utils\ccm_task_diff.pl:145): OUTPUT_BEGIN
Object:  BimServiceInfo.cpp#1 (cpp:2)
Owner:   yturgman
State:   released
Created: Sun Apr 15 22:20:55 2007
Task:    28409
Comment:
changed to sqa state by mntinteg

Predecessors:
Successors:
	BimServiceInfo.cpp#2:cpp:2
*****************************************************************************
Object:  BimServiceInfo.cpp#2 (cpp:2)
Owner:   yakovt
State:   released
Created: Thu Jul 31 18:57:07 2008
Task:    35469
Comment:
changed to sqa state by GAP automatic approval

Predecessors:
	BimServiceInfo.cpp#1:cpp:2
Successors:
	BimServiceInfo.cpp#3:cpp:2
	BimServiceInfo.cpp#2.1.1:cpp:2
*****************************************************************************
Object:  BimServiceInfo.cpp#3 (cpp:2)
Owner:   mgendelm
State:   sqa
Created: Wed Mar 25 17:41:46 2009
Task:    38853
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	BimServiceInfo.cpp#2:cpp:2
Successors:
	BimServiceInfo.cpp#4:cpp:2
*****************************************************************************
Object:  BimServiceInfo.cpp#4 (cpp:2)
Owner:   barak
State:   sqa
Created: Sun Jul 12 10:32:37 2009
Task:    40085
Comment:
Version automatically created during work area reconciliation.


changed to sqa state by GAP automatic approval
Predecessors:
	BimServiceInfo.cpp#3:cpp:2
Successors:
	BimServiceInfo.cpp#5:cpp:2
	BimServiceInfo.cpp#4.1.1:cpp:2
*****************************************************************************
Object:  BimServiceInfo.cpp#5 (cpp:2)
Owner:   tadmon
State:   working
Created: Sun Nov 15 16:22:45 2009
Task:    42666
Comment:
<void>
Predecessors:
	BimServiceInfo.cpp#4:cpp:2
Successors:
*****************************************************************************
Object:  BimServiceInfo.cpp#2.1.1 (cpp:2)
Owner:   yakovt
State:   integrate
Created: Mon Dec 14 13:32:21 2009
Task:    43731
Comment:
<void>
Predecessors:
	BimServiceInfo.cpp#2:cpp:2
Successors:
	BimServiceInfo.cpp#4.1.1:cpp:2
*****************************************************************************
Object:  BimServiceInfo.cpp#4.1.1 (cpp:2)
Owner:   yakovt
State:   integrate
Created: Wed Dec 23 16:10:36 2009
Task:    43956
Comment:

Predecessors:
	BimServiceInfo.cpp#4:cpp:2
	BimServiceInfo.cpp#2.1.1:cpp:2
Successors:
*****************************************************************************

OUTPUT_END
Execute (c:\utils\ccm_task_diff.pl:157): EXECUTE_CMD: ccm finduse BimServiceInfo.cpp#4.1.1:cpp:2
Execute (c:\utils\ccm_task_diff.pl:157): OUTPUT_BEGIN
BimServiceInfo.cpp#4.1.1 integrate yakovt cpp ECSNT 2 43956
	ECSNT\ForecastService\BimServiceInfo.cpp#4.1.1@ECSNT#700yakovt-win:project:4
	ECSNT\ForecastService\BimServiceInfo.cpp#4.1.1@ECSNT#700_hani_win:project:4
	ECSNT\ForecastService\BimServiceInfo.cpp#4.1.1@ECSNT#bldrem_EM700_U_CI:project:4
	ECSNT\ForecastService\BimServiceInfo.cpp#4.1.1@ECSNT#bldrem_EM700_W_CI:project:4
	ECSNT\ForecastService\BimServiceInfo.cpp#4.1.1@ECSNT#galia700windows2:project:4

OUTPUT_END
Execute (c:\utils\ccm_task_diff.pl:174): EXECUTE_CMD: ccm cat BimServiceInfo.cpp#2.1.1:cpp:2
Execute (c:\utils\ccm_task_diff.pl:174): OUTPUT_BEGIN
/**********************************************************************
*                 Copyright BMC Software Inc., 
*     as an unpublished licensed work. All rights reserved.
*     -----------------------------------------------------
*
*	C++ Source   : BimServiceInfo.cpp
*	Instance     : 1
*	Created by   : yakovt
*	Date created : Sun Dec 10 14:32:49 2006
*	Description  : 
*
**********************************************************************/
#ifndef lint /* Automatically created, Please don't modify */
static const char _BimServiceInfo_cpp_cpp[] = "@(#) %name: BimServiceInfo.cpp %, %cvtype: cpp %, %date_modified: %, %derived_by: yakovt %, %version: 2.1.1 %, %instance: 2 %, %compiled: "__DATE__", "__TIME__" %, %file_path: "__FILE__ " %(#)@";
#endif

#include "stdafx.h"
DIAG_REGISTER_MODULE;
#include <em_crb_foundations/ECSDBJob.h>
#include <ForecastService/BimServiceInfo.h>
#include <ForecastCommon/FcException.h>


namespace	Forecast {
namespace	Service {

const std::string sEmptyString;


//////////////////////////////////////////////////////////////////////////
//
BimServiceInfo::BimServiceInfo()
{

}


//////////////////////////////////////////////////////////////////////////
//
void BimServiceInfo::SetFromDBJob( const bsm::DefJob& dbjob)
{
	DBG_FNC_ENTER("BimServiceInfo::SetFromDBJob");

	// if job is a bim service add it to the list
	EM_ASSERT(dbjob.Base().f_DBF_DEF_JOB_APPL_TYPE == "BIM", "logical: cannot create BIM service from no-bim job");

	// fill all bim auto-edit variables
	const bsm::V_TABLE_CLASS_SETVAR &jobAttrHldrVec = dbjob.GetRecordsVec_TABLE_CLASS_SETVAR();
	for (bsm::V_TABLE_CLASS_SETVAR::const_iterator it = jobAttrHldrVec.begin()
		; it != jobAttrHldrVec.end()
		; ++it)
	{
		const bsm::R_TABLE_CLASS_SETVAR& jobAttrHldr = *it;
		IOAString n = jobAttrHldr.f_DBF_DEF_SETVAR_NAME.c_str();
		IOAString v = jobAttrHldr.f_DBF_DEF_SETVAR_VALUE.c_str();

		if (n.compare(0, 6, "%%BIM-") == 0)
		{
			std::string name = n.substr(6);
			this->m_Vars[name] = v;
		}
	}
}

//////////////////////////////////////////////////////////////////////////
//
const std::string& BimServiceInfo::GetVar(const std::string& name ) const 
{
	DBG_FNC_ENTER("BimServiceInfo::GetVar");

 	Vars_type::const_iterator i = m_Vars.find(name);
 	if( i != m_Vars.end() )
 		return (*i).second;
 	else
 		return sEmptyString;
}

//////////////////////////////////////////////////////////////////////////
//

bool BimServiceInfo::HasVars() const
{
	return (m_Vars.size() > 0);
}

bool BimServiceInfo::HasVar(const std::string& name ) const 
{
	Vars_type::const_iterator i = m_Vars.find(name);
	return ( i != m_Vars.end() );
}

void BimServiceInfo::SetVar(const std::string& name, const std::string& value )
{
	m_Vars[name] = value;
}


}}	// Forecast::Service


OUTPUT_END
Execute (c:\utils\ccm_task_diff.pl:128): EXECUTE_CMD: ccm diff -vc  BimServiceInfo.cpp#2.1.1:cpp:2
Execute (c:\utils\ccm_task_diff.pl:128): OUTPUT_BEGIN
Attribute name            BimServiceInfo.cpp#2       BimServiceInfo.cpp#2.1.1  
------------------------- -------------------------- --------------------------
create_time               Thu Jul 31 18:57:07 2008   Mon Dec 14 13:32:21 2009  
modify_time               Thu Mar 05 13:09:27 2009   Wed Dec 23 13:25:02 2009  
release                   6.4.0.01                   6.4.0.04                  
status                    released                   integrate                 
version                   2                          2.1.1                     
comment                   changed to sqa state by... <doesn't exist>           
source_create_time        Thu Jul 31 18:57:08 2008   Mon Dec 14 13:32:22 2009  
source_modify_time        Thu Jul 31 19:03:48 2008   Thu Dec 17 18:02:59 2009  

===============================================================================
Associated tasks differs:

BimServiceInfo.cpp#2
35469: 640.1: bsm: Forecast Definition Repository

BimServiceInfo.cpp#2.1.1
43731: 640.4: bsm: forecast: diag: print bim data  w/o name

===============================================================================
Text attribute 'source' differs:

14c14
< static const char _BimServiceInfo_cpp_cpp[] = "@(#) %name: BimServiceInfo.cpp %, %cvtype: cpp %, %date_modified: %, %derived_by: yakovt %, %version: 2 %, %instance: 2 %, %compiled: "__DATE__", "__TIME__" %, %file_path: "__FILE__ " %(#)@";
---
> static const char _BimServiceInfo_cpp_cpp[] = "@(#) %name: BimServiceInfo.cpp %, %cvtype: cpp %, %date_modified: %, %derived_by: yakovt %, %version: 2.1.1 %, %instance: 2 %, %compiled: "__DATE__", "__TIME__" %, %file_path: "__FILE__ " %(#)@";
26a27
> const std::string sEmptyString;
70,74c71,75
< 	Vars_type::const_iterator i = m_Vars.find(name);
< 	if( i != m_Vars.end() )
< 		return (*i).second;
< 	else
< 		throw Common::FcException("cannot found BIM service attribute with name " + name);
---
>  	Vars_type::const_iterator i = m_Vars.find(name);
>  	if( i != m_Vars.end() )
>  		return (*i).second;
>  	else
>  		return sEmptyString;
78a80,85
> 
> bool BimServiceInfo::HasVars() const
> {
> 	return (m_Vars.size() > 0);
> }
> 

===============================================================================
Text attribute 'status_log' differs:

1,4c1,2
< Thu Jul 31 18:57:08 2008: Status set to 'working' by yakovt in role developer
< Tue Sep 16 11:07:40 2008: Status set to 'integrate' by yakovt in role developer
< Mon Sep 22 09:20:23 2008: Status set to 'sqa' by bldrem in role build_mgr
< Thu Mar  5 13:09:27 2009: Status set to 'released' by ccm_root in role ccm_admin
---
> Mon Dec 14 13:32:22 2009: Status set to 'working' by yakovt in role developer
> Wed Dec 23 13:25:02 2009: Status set to 'integrate' by yakovt in role developer


OUTPUT_END
Execute (c:\utils\ccm_task_diff.pl:174): EXECUTE_CMD: ccm cat BimServiceInfo.cpp#2:cpp:2
Execute (c:\utils\ccm_task_diff.pl:174): OUTPUT_BEGIN
/**********************************************************************
*                 Copyright BMC Software Inc., 
*     as an unpublished licensed work. All rights reserved.
*     -----------------------------------------------------
*
*	C++ Source   : BimServiceInfo.cpp
*	Instance     : 1
*	Created by   : yakovt
*	Date created : Sun Dec 10 14:32:49 2006
*	Description  : 
*
**********************************************************************/
#ifndef lint /* Automatically created, Please don't modify */
static const char _BimServiceInfo_cpp_cpp[] = "@(#) %name: BimServiceInfo.cpp %, %cvtype: cpp %, %date_modified: %, %derived_by: yakovt %, %version: 2 %, %instance: 2 %, %compiled: "__DATE__", "__TIME__" %, %file_path: "__FILE__ " %(#)@";
#endif

#include "stdafx.h"
DIAG_REGISTER_MODULE;
#include <em_crb_foundations/ECSDBJob.h>
#include <ForecastService/BimServiceInfo.h>
#include <ForecastCommon/FcException.h>


namespace	Forecast {
namespace	Service {



//////////////////////////////////////////////////////////////////////////
//
BimServiceInfo::BimServiceInfo()
{

}


//////////////////////////////////////////////////////////////////////////
//
void BimServiceInfo::SetFromDBJob( const bsm::DefJob& dbjob)
{
	DBG_FNC_ENTER("BimServiceInfo::SetFromDBJob");

	// if job is a bim service add it to the list
	EM_ASSERT(dbjob.Base().f_DBF_DEF_JOB_APPL_TYPE == "BIM", "logical: cannot create BIM service from no-bim job");

	// fill all bim auto-edit variables
	const bsm::V_TABLE_CLASS_SETVAR &jobAttrHldrVec = dbjob.GetRecordsVec_TABLE_CLASS_SETVAR();
	for (bsm::V_TABLE_CLASS_SETVAR::const_iterator it = jobAttrHldrVec.begin()
		; it != jobAttrHldrVec.end()
		; ++it)
	{
		const bsm::R_TABLE_CLASS_SETVAR& jobAttrHldr = *it;
		IOAString n = jobAttrHldr.f_DBF_DEF_SETVAR_NAME.c_str();
		IOAString v = jobAttrHldr.f_DBF_DEF_SETVAR_VALUE.c_str();

		if (n.compare(0, 6, "%%BIM-") == 0)
		{
			std::string name = n.substr(6);
			this->m_Vars[name] = v;
		}
	}
}

//////////////////////////////////////////////////////////////////////////
//
const std::string& BimServiceInfo::GetVar(const std::string& name ) const 
{
	DBG_FNC_ENTER("BimServiceInfo::GetVar");

	Vars_type::const_iterator i = m_Vars.find(name);
	if( i != m_Vars.end() )
		return (*i).second;
	else
		throw Common::FcException("cannot found BIM service attribute with name " + name);
}

//////////////////////////////////////////////////////////////////////////
//
bool BimServiceInfo::HasVar(const std::string& name ) const 
{
	Vars_type::const_iterator i = m_Vars.find(name);
	return ( i != m_Vars.end() );
}

void BimServiceInfo::SetVar(const std::string& name, const std::string& value )
{
	m_Vars[name] = value;
}


}}	// Forecast::Service


OUTPUT_END
Execute (c:\utils\ccm_task_diff.pl:228): diff -u C:/Tasks/43731/old/BimServiceInfo.cpp C:/Tasks/43731/new/BimServiceInfo.cpp
Execute (c:\utils\ccm_task_diff.pl:228): OUTPUT_BEGIN
--- C:/Tasks/43731/old/BimServiceInfo.cpp	Thu Dec 24 11:29:07 2009
+++ C:/Tasks/43731/new/BimServiceInfo.cpp	Thu Dec 24 11:29:07 2009
@@ -11,7 +11,7 @@
 *
 **********************************************************************/
 #ifndef lint /* Automatically created, Please don't modify */
-static const char _BimServiceInfo_cpp_cpp[] = "@(#) %name: BimServiceInfo.cpp %, %cvtype: cpp %, %date_modified: %, %derived_by: yakovt %, %version: 2 %, %instance: 2 %, %compiled: "__DATE__", "__TIME__" %, %file_path: "__FILE__ " %(#)@";
+static const char _BimServiceInfo_cpp_cpp[] = "@(#) %name: BimServiceInfo.cpp %, %cvtype: cpp %, %date_modified: %, %derived_by: yakovt %, %version: 2.1.1 %, %instance: 2 %, %compiled: "__DATE__", "__TIME__" %, %file_path: "__FILE__ " %(#)@";
 #endif
 
 #include "stdafx.h"
@@ -24,6 +24,7 @@
 namespace	Forecast {
 namespace	Service {
 
+const std::string sEmptyString;
 
 
 //////////////////////////////////////////////////////////////////////////
@@ -67,15 +68,21 @@
 {
 	DBG_FNC_ENTER("BimServiceInfo::GetVar");
 
-	Vars_type::const_iterator i = m_Vars.find(name);
-	if( i != m_Vars.end() )
-		return (*i).second;
-	else
-		throw Common::FcException("cannot found BIM service attribute with name " + name);
+ 	Vars_type::const_iterator i = m_Vars.find(name);
+ 	if( i != m_Vars.end() )
+ 		return (*i).second;
+ 	else
+ 		return sEmptyString;
 }
 
 //////////////////////////////////////////////////////////////////////////
 //
+
+bool BimServiceInfo::HasVars() const
+{
+	return (m_Vars.size() > 0);
+}
+
 bool BimServiceInfo::HasVar(const std::string& name ) const 
 {
 	Vars_type::const_iterator i = m_Vars.find(name);

OUTPUT_END
Execute (c:\utils\ccm_task_diff.pl:145): EXECUTE_CMD: ccm history BimServiceInfo.h#2.1.1:INC:2
Execute (c:\utils\ccm_task_diff.pl:145): OUTPUT_BEGIN
Object:  BimServiceInfo.h#1 (INC:2)
Owner:   yturgman
State:   released
Created: Sun Apr 15 22:20:58 2007
Task:    28409
Comment:
changed to sqa state by mntinteg

Predecessors:
Successors:
	BimServiceInfo.h#2:INC:2
*****************************************************************************
Object:  BimServiceInfo.h#2 (INC:2)
Owner:   yakovt
State:   released
Created: Thu Jul 31 18:44:01 2008
Task:    35469
Comment:
changed to sqa state by GAP automatic approval

Predecessors:
	BimServiceInfo.h#1:INC:2
Successors:
	BimServiceInfo.h#3:INC:2
	BimServiceInfo.h#2.1.1:INC:2
	BimServiceInfo.h#2.2.1:INC:2
*****************************************************************************
Object:  BimServiceInfo.h#3 (INC:2)
Owner:   tadmon
State:   working
Created: Sun Nov 15 16:25:46 2009
Task:    42666
Comment:

Predecessors:
	BimServiceInfo.h#2:INC:2
Successors:
*****************************************************************************
Object:  BimServiceInfo.h#2.1.1 (INC:2)
Owner:   yakovt
State:   integrate
Created: Mon Dec 14 13:41:51 2009
Task:    43731
Comment:
<void>
Predecessors:
	BimServiceInfo.h#2:INC:2
Successors:
	BimServiceInfo.h#2.2.1:INC:2
*****************************************************************************
Object:  BimServiceInfo.h#2.2.1 (INC:2)
Owner:   yakovt
State:   integrate
Created: Wed Dec 23 17:03:29 2009
Task:    43956
Comment:

Predecessors:
	BimServiceInfo.h#2:INC:2
	BimServiceInfo.h#2.1.1:INC:2
Successors:
*****************************************************************************

OUTPUT_END
Execute (c:\utils\ccm_task_diff.pl:157): EXECUTE_CMD: ccm finduse BimServiceInfo.h#2.2.1:INC:2
Execute (c:\utils\ccm_task_diff.pl:157): OUTPUT_BEGIN
BimServiceInfo.h#2.2.1 integrate yakovt INC ECSNT 2 43956
	ECSNT\ForecastService\BimServiceInfo.h#2.2.1@ECSNT#700yakovt-win:project:4
	ECSNT\ForecastService\BimServiceInfo.h#2.2.1@ECSNT#700_hani_win:project:4
	ECSNT\ForecastService\BimServiceInfo.h#2.2.1@ECSNT#bldrem_EM700_U_CI:project:4
	ECSNT\ForecastService\BimServiceInfo.h#2.2.1@ECSNT#bldrem_EM700_W_CI:project:4
	ECSNT\ForecastService\BimServiceInfo.h#2.2.1@ECSNT#galia700windows2:project:4

OUTPUT_END
Execute (c:\utils\ccm_task_diff.pl:174): EXECUTE_CMD: ccm cat BimServiceInfo.h#2.1.1:INC:2
Execute (c:\utils\ccm_task_diff.pl:174): OUTPUT_BEGIN
/**********************************************************************
*                 Copyright BMC Software Inc., 
*     as an unpublished licensed work. All rights reserved.
*     -----------------------------------------------------
*
*	C Include    : BimServiceInfo.h
*	Instance     : 1
*	Created by   : yakovt
*	Date created : Sun Dec 10 14:32:51 2006
*	Description  : static information about service: name, priority, etc
*
**********************************************************************/
#ifndef _BimServiceInfo_h_1_
#define _BimServiceInfo_h_1_

#include <ForecastService/BimServiceStatus.h>
#include <BsmCommon/DefJob.h>


namespace	Forecast {
namespace	Service {

class BimServiceInfo
{
public:
	BimServiceInfo();

	void SetFromDBJob( const bsm::DefJob& dbjob);

	const std::string& GetVar(const std::string& name ) const;
	bool HasVar(const std::string& name ) const;
	bool HasVars() const;
	void SetVar(const std::string& name, const std::string& value );

private:
	typedef std::map< std::string, std::string >	Vars_type;
	Vars_type m_Vars;

};

typedef std::vector< BimServiceInfo >				BimServiceVec;


}}	// Forecast::Service

#endif /* _BimServiceInfo_h_1_ */

OUTPUT_END
Execute (c:\utils\ccm_task_diff.pl:128): EXECUTE_CMD: ccm diff -vc  BimServiceInfo.h#2.1.1:INC:2
Execute (c:\utils\ccm_task_diff.pl:128): OUTPUT_BEGIN
Attribute name            BimServiceInfo.h#2         BimServiceInfo.h#2.1.1    
------------------------- -------------------------- --------------------------
create_time               Thu Jul 31 18:44:01 2008   Mon Dec 14 13:41:51 2009  
modify_time               Thu Mar 05 13:09:28 2009   Wed Dec 23 13:25:03 2009  
release                   6.4.0.01                   6.4.0.04                  
status                    released                   integrate                 
version                   2                          2.1.1                     
comment                   changed to sqa state by... <doesn't exist>           
source_create_time        Thu Jan 04 19:50:00 2007   Thu Jul 31 18:56:52 2008  
source_modify_time        Thu Jul 31 18:56:52 2008   Mon Dec 14 13:41:27 2009  

===============================================================================
Associated tasks differs:

BimServiceInfo.h#2
35469: 640.1: bsm: Forecast Definition Repository

BimServiceInfo.h#2.1.1
43731: 640.4: bsm: forecast: diag: print bim data  w/o name

===============================================================================
Text attribute 'source' differs:

31a32
> 	bool HasVars() const;

===============================================================================
Text attribute 'status_log' differs:

1,4c1,2
< Thu Jul 31 18:44:01 2008: Status set to 'working' by yakovt in role developer
< Tue Sep 16 11:07:40 2008: Status set to 'integrate' by yakovt in role developer
< Mon Sep 22 09:20:24 2008: Status set to 'sqa' by bldrem in role build_mgr
< Thu Mar  5 13:09:28 2009: Status set to 'released' by ccm_root in role ccm_admin
---
> Mon Dec 14 13:41:52 2009: Status set to 'working' by yakovt in role developer
> Wed Dec 23 13:25:03 2009: Status set to 'integrate' by yakovt in role developer


OUTPUT_END
Execute (c:\utils\ccm_task_diff.pl:174): EXECUTE_CMD: ccm cat BimServiceInfo.h#2:INC:2
Execute (c:\utils\ccm_task_diff.pl:174): OUTPUT_BEGIN
/**********************************************************************
*                 Copyright BMC Software Inc., 
*     as an unpublished licensed work. All rights reserved.
*     -----------------------------------------------------
*
*	C Include    : BimServiceInfo.h
*	Instance     : 1
*	Created by   : yakovt
*	Date created : Sun Dec 10 14:32:51 2006
*	Description  : static information about service: name, priority, etc
*
**********************************************************************/
#ifndef _BimServiceInfo_h_1_
#define _BimServiceInfo_h_1_

#include <ForecastService/BimServiceStatus.h>
#include <BsmCommon/DefJob.h>


namespace	Forecast {
namespace	Service {

class BimServiceInfo
{
public:
	BimServiceInfo();

	void SetFromDBJob( const bsm::DefJob& dbjob);

	const std::string& GetVar(const std::string& name ) const;
	bool HasVar(const std::string& name ) const;
	void SetVar(const std::string& name, const std::string& value );

private:
	typedef std::map< std::string, std::string >	Vars_type;
	Vars_type m_Vars;

};

typedef std::vector< BimServiceInfo >				BimServiceVec;


}}	// Forecast::Service

#endif /* _BimServiceInfo_h_1_ */

OUTPUT_END
Execute (c:\utils\ccm_task_diff.pl:228): diff -u C:/Tasks/43731/old/BimServiceInfo.h C:/Tasks/43731/new/BimServiceInfo.h
Execute (c:\utils\ccm_task_diff.pl:228): OUTPUT_BEGIN
--- C:/Tasks/43731/old/BimServiceInfo.h	Thu Dec 24 11:29:08 2009
+++ C:/Tasks/43731/new/BimServiceInfo.h	Thu Dec 24 11:29:08 2009
@@ -29,6 +29,7 @@
 
 	const std::string& GetVar(const std::string& name ) const;
 	bool HasVar(const std::string& name ) const;
+	bool HasVars() const;
 	void SetVar(const std::string& name, const std::string& value );
 
 private:

OUTPUT_END
Execute (c:\utils\ccm_task_diff.pl:145): EXECUTE_CMD: ccm history DefJobRepository.cpp#5.1.1:cpp:1
Execute (c:\utils\ccm_task_diff.pl:145): OUTPUT_BEGIN
Object:  DefJobRepository.cpp#1 (cpp:1)
Owner:   yakovt
State:   sqa
Created: Wed Aug 06 10:07:40 2008
Task:    35469
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
Successors:
	DefJobRepository.cpp#2:cpp:1
*****************************************************************************
Object:  DefJobRepository.cpp#2 (cpp:1)
Owner:   yakovt
State:   sqa
Created: Wed Sep 17 15:36:21 2008
Task:    36016
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	DefJobRepository.cpp#1:cpp:1
Successors:
	DefJobRepository.cpp#3:cpp:1
*****************************************************************************
Object:  DefJobRepository.cpp#3 (cpp:1)
Owner:   yakovt
State:   released
Created: Mon Oct 06 10:23:53 2008
Task:    36206
Comment:
changed to sqa state by GAP automatic approval

Predecessors:
	DefJobRepository.cpp#2:cpp:1
Successors:
	DefJobRepository.cpp#4:cpp:1
*****************************************************************************
Object:  DefJobRepository.cpp#4 (cpp:1)
Owner:   eyals
State:   sqa
Created: Wed May 06 11:17:31 2009
Task:    39309
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	DefJobRepository.cpp#3:cpp:1
Successors:
	DefJobRepository.cpp#5:cpp:1
*****************************************************************************
Object:  DefJobRepository.cpp#5 (cpp:1)
Owner:   yakovt
State:   released
Created: Wed May 06 13:47:53 2009
Task:    39315
Comment:
changed to sqa state by GAP automatic approval

Predecessors:
	DefJobRepository.cpp#4:cpp:1
Successors:
	DefJobRepository.cpp#6:cpp:1
	DefJobRepository.cpp#5.1.1:cpp:1
*****************************************************************************
Object:  DefJobRepository.cpp#6 (cpp:1)
Owner:   yakovt
State:   sqa
Created: Thu Jul 09 17:39:27 2009
Task:    40227
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	DefJobRepository.cpp#5:cpp:1
Successors:
	DefJobRepository.cpp#7:cpp:1
	DefJobRepository.cpp#6.1.1:cpp:1
*****************************************************************************
Object:  DefJobRepository.cpp#7 (cpp:1)
Owner:   tadmon
State:   working
Created: Sun Nov 15 18:01:05 2009
Task:    42666
Comment:

Predecessors:
	DefJobRepository.cpp#6:cpp:1
Successors:
*****************************************************************************
Object:  DefJobRepository.cpp#6.1.1 (cpp:1)
Owner:   yakovt
State:   sqa
Created: Wed Nov 25 17:25:46 2009
Task:    42852
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	DefJobRepository.cpp#6:cpp:1
Successors:
	DefJobRepository.cpp#6.1.2:cpp:1
*****************************************************************************
Object:  DefJobRepository.cpp#6.1.2 (cpp:1)
Owner:   yakovt
State:   sqa
Created: Thu Nov 26 14:54:46 2009
Task:    43064
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	DefJobRepository.cpp#6.1.1:cpp:1
Successors:
	DefJobRepository.cpp#6.1.3:cpp:1
*****************************************************************************
Object:  DefJobRepository.cpp#5.1.1 (cpp:1)
Owner:   yakovt
State:   integrate
Created: Mon Dec 14 13:42:40 2009
Task:    43731
Comment:
<void>
Predecessors:
	DefJobRepository.cpp#5:cpp:1
Successors:
	DefJobRepository.cpp#6.1.3:cpp:1
*****************************************************************************
Object:  DefJobRepository.cpp#6.1.3 (cpp:1)
Owner:   yakovt
State:   integrate
Created: Wed Dec 23 17:07:17 2009
Task:    43956
Comment:

Predecessors:
	DefJobRepository.cpp#6.1.2:cpp:1
	DefJobRepository.cpp#5.1.1:cpp:1
Successors:
*****************************************************************************

OUTPUT_END
Execute (c:\utils\ccm_task_diff.pl:157): EXECUTE_CMD: ccm finduse DefJobRepository.cpp#6.1.3:cpp:1
Execute (c:\utils\ccm_task_diff.pl:157): OUTPUT_BEGIN
DefJobRepository.cpp#6.1.3 integrate yakovt cpp ECSNT 1 43956
	ECSNT\ForecastService\DefJobRepository.cpp#6.1.3@ECSNT#700yakovt-win:project:4
	ECSNT\ForecastService\DefJobRepository.cpp#6.1.3@ECSNT#700_hani_win:project:4
	ECSNT\ForecastService\DefJobRepository.cpp#6.1.3@ECSNT#bldrem_EM700_U_CI:project:4
	ECSNT\ForecastService\DefJobRepository.cpp#6.1.3@ECSNT#bldrem_EM700_W_CI:project:4
	ECSNT\ForecastService\DefJobRepository.cpp#6.1.3@ECSNT#galia700windows2:project:4

OUTPUT_END
Execute (c:\utils\ccm_task_diff.pl:174): EXECUTE_CMD: ccm cat DefJobRepository.cpp#5.1.1:cpp:1
Execute (c:\utils\ccm_task_diff.pl:174): OUTPUT_BEGIN
/**********************************************************************
*                 Copyright BMC Software Inc.,
*     as an unpublished licensed work. All rights reserved.
*     -----------------------------------------------------
*
*	C++ %name:		DefJobRepository.cpp %
*	Instance:		1
*	Description:	
*	%created_by:	yakovt %
*	%date_created:	Mon Dec 14 13:42:40 2009 %
*
**********************************************************************/
#ifndef lint
static const char *_cxxsrc = "@(#) %filespec: DefJobRepository.cpp#5.1.1 %  (%full_filespec: DefJobRepository.cpp#5.1.1:cpp:1 %)";
#endif

#include "stdafx.h"
#include <BsmCommon/DefJob.h>
#include <em_foundations/EmHelper.h>
#include <em_foundations/EmException.h>
#include <ForecastService/DefJobRepository.h>
#include <ForecastDAL/Definition.h>
#include <ForecastDAL/DALMgr.h>
#include <BsmCommon/Values.h>
#include <BsmCommon/Helper.h>
#include <PeriodicStats/PeriodicStatsMgr.h>
#include <BsmCommon/Values.h>

DIAG_REGISTER_MODULE;

namespace Forecast {
namespace Service {

EM_SINGLETON_IMPLEMENTATION(DefJobRepository)
ACE_RW_Thread_Mutex DefJobRepository::m_Lock;

DefJobRepositoryAutoReadLocker::DefJobRepositoryAutoReadLocker()
{
	DefJobRepository::Instance()->m_Lock.acquire_read();
}

DefJobRepositoryAutoReadLocker::~DefJobRepositoryAutoReadLocker()
{
	DefJobRepository::Instance()->m_Lock.release();
}



DefJobRepository::DefJobRepository()
: m_ConfigurationWasSet( false )
, m_ExtMode ( false )
, m_LastError(0)
{
}



//////////////////////////////////////////////////////////////////////////
// set configuration and init the User Daily parser. should be called before first using
//
void DefJobRepository::SetConfiguration(const Forecast::Common::ForecastParameters& params )
{
	ACE_Write_Guard<ACE_RW_Thread_Mutex> guard(m_Lock);

	m_Params = params;

	m_UserDailyParser.SetConfiguration(params); //will init the regular expression in the object

	m_ConfigurationWasSet = true;
}

//////////////////////////////////////////////////////////////////////////
// Update the repository incrementally
//
void DefJobRepository::Update(bool read_all /*= false*/)
{
	DBG_FNC_ENTER("DefJobRepository::Update");
	EM_ASSERT( m_ConfigurationWasSet == true, "configuraiotn should be set before, is SimGraph::SetSimParameters called?" );

	ACE_Write_Guard<ACE_RW_Thread_Mutex> guard(m_Lock);


	if( IsError() && read_all == false )
	{
		DIAG_PDEF( DIAG_I, "Initial reading all jobs definitions becouse previous error: " << m_LastError );
		read_all = true;
	}

	//there is  no error at start
	m_LastError = 0;

	m_DefTableInfosPrev = m_DefTableInfosCurr;
	ReadSchedTables(m_DefTableInfosCurr);
	ReadDataCenters();

	// fill engine with datacenter information
	for (size_t i = 0; i < m_CommDomVec.size();  ++i)
	{
		commDom& c = m_CommDomVec[i];

		// fill missing data in table definition information
		for (size_t j = 0; j < m_DefTableInfosCurr.size(); ++j)
		{
			if (m_DefTableInfosCurr[j].m_DataCenter == c.data_center())
			{
				m_DefTableInfosCurr[j].m_CTMVer = c.control_m_ver();
				m_DefTableInfosCurr[j].m_Platform = c.platform();
			}
		}
	}



	TableIds to_remove; //removed or updated table
	TableIds to_read;   //new or updated table
	FindUpdatedTablesDiff(to_remove, to_read);

	if( read_all == false )
	{
		if( m_DefTableInfosPrev.empty() && !to_read.empty()  )
		{
			DIAG_PDEF( DIAG_I, "Initial reading all jobs definitions" );
			read_all = true;
		}
	}

	if( read_all )
	{
		ClearAllJobs();
		//we can clear here the all shared string because all jobs are used those string were deleted above
		bsm::ValueStringShared::GetValueStringSet().Clear();

		ReadJobsAll();

		DIAG_PDEF( DIAG_I, m_DefTableInfosCurr.size() << " job definition tables were read");

		size_t all_recn = LoadStatistics();

		DIAG_PDEF(DIAG_I, "load " << all_recn << " statistics record from database for all CONTROL-M ");

	}

	else 
	{
		//incremental read

		if( !to_remove.empty() || !to_read.empty() )
		{
			DIAG_PDEF( DIAG_I, "there are some updates in jobs definitions: " 
				<< to_remove.size() << " old tables will be removed, "
				<< to_read.size() << " new/updated tables will be added");

			ClearJobsBySchedTable(to_remove);
			ClearJobsBySchedTable(to_read);
			ReadJobsBySchedTables(to_read);
		}
		else
		{
			DIAG_PDEF( DIAG_I, "there is no updates in jobs definitions" );
		}
	}

	// in case 'read all' the to_read vector have to consist of all tables (it will be used during pares UD)
	if( read_all )
	{
		// fill to_read with all read tables ID. it will be used latter in parse UD
		to_read.clear();
		to_read.reserve(m_DefTableInfosCurr.size());
		for( bsm::DefTableInfos::const_iterator cur_it=m_DefTableInfosCurr.begin(), cur_it_end=m_DefTableInfosCurr.end();
			cur_it != cur_it_end; ++cur_it )
		{
			to_read.push_back( (*cur_it).m_Table_ID );
		}
	}

	if( !to_read.empty() )
	{
		DIAG_PDEF( DIAG_I, "going to parse jobs User daily for " << to_read.size() << " tables" );
		ParseUserDaily(to_read);
	}

	DIAG_PDEF( DIAG_I, "There are " << DefJobRepository::GetDefJobNumber() << " jobs in Repository" );
}


//////////////////////////////////////////////////////////////////////////
//
void DefJobRepository::ReadJobsBySchedTables(const TableIds& table_ids)
{
	DBG_FNC_ENTER("DefJobRepository::ReadJobsBySchedTables");

	// read all table definitions information
	DIAG_PDEF(DIAG_D, "read table definitions information by scheduled tables");

	for( size_t i=0; i<table_ids.size(); ++i )
	{
		TableId table_id = table_ids[i];
		ReadJobsBySchedTable(table_id);
		if( IsError() )
			DIAG_PDEF( DIAG_E, "Error reading sched table from DB" << table_id );
			break; //do not continue in case any error
	}
}

//////////////////////////////////////////////////////////////////////////
//table_id=0, read all!
//
void DefJobRepository::ReadJobsBySchedTable(TableId table_id)
{
	DBG_FNC_ENTER("DefJobRepository::ReadJobsBySchedTable");
	DAL::Definition defDal(DAL::DALMgr::instance());
	RWDBConnection conn = DAL::DALMgr::instance()->GetConnection();

	int rc = 0;
	rc = defDal.ReadJobs_main(table_id, m_MapTID2MapJID2Job, m_ExtMode, &conn);
	if( rc == 0 ){
		rc = defDal.ReadJobs_parts(table_id, m_MapTID2MapJID2Job, &conn);
	}
	else{
		DIAG_PDEF( DIAG_E, "Error reading sched table from DB" << table_id );
	}
	
	m_LastError = rc;
}


//////////////////////////////////////////////////////////////////////////
// the definition tables are sorted by table id (by DB select) 
// all old tables will be removed from repository
// all new table will be read and added into repository
// all updated tables will be removed, read again and added into repository
//
void DefJobRepository::FindUpdatedTablesDiff( TableIds& to_remove, TableIds& to_read ) const
{
	DBG_FNC_ENTER("DefJobRepository::FindUpdatedTablesDiff");

	bsm::DefTableInfos::const_iterator cur_it=m_DefTableInfosCurr.begin(), cur_it_end=m_DefTableInfosCurr.end(); 
	bsm::DefTableInfos::const_iterator prv_it=m_DefTableInfosPrev.begin(), prv_it_end=m_DefTableInfosPrev.end(); 
	while( prv_it != prv_it_end && cur_it != cur_it_end )
	{
		const bsm::DefTableInfo& prv = *prv_it;
		const bsm::DefTableInfo& cur = *cur_it;
		if( cur.m_Table_ID < prv.m_Table_ID )
		{
			//current is not found in previous, it's new table
			to_read.push_back(cur.m_Table_ID); //should be read and added into repository
			++cur_it;
		}
		else if( prv.m_Table_ID < cur.m_Table_ID )
		{
			//previous is not found in current, it's old table
			to_remove.push_back(prv.m_Table_ID); //should be removed from repository
			++prv_it;
		}
		else //it existed table  
		{
			if( prv.m_LastUpdated < cur.m_LastUpdated )
			{
				// the current table is updated, should be re-read( removed and added)
				to_remove.push_back(cur.m_Table_ID); 
				to_read.push_back(cur.m_Table_ID); 
			}
			++cur_it;
			++prv_it;
		}
	}

	// for all rest previous table -- remove
	for( ; prv_it != prv_it_end; ++prv_it )
	{
		const bsm::DefTableInfo& prv = *prv_it;
		to_remove.push_back(prv.m_Table_ID); 
	}

	// for all rest current table -- read
	for( ; cur_it != cur_it_end; ++cur_it )
	{
		const bsm::DefTableInfo& cur = *cur_it;
		to_read.push_back(cur.m_Table_ID); 
	}
}


//////////////////////////////////////////////////////////////////////////
// 
void DefJobRepository::ClearAllJobs()
{
	DBG_FNC_ENTER("DefJobRepository::ClearAllJobs");

	MapTID2MapJID2Job::iterator it= m_MapTID2MapJID2Job.begin(), it_end=m_MapTID2MapJID2Job.end();
	for( ; it != it_end; ++it)
	{
		SeqMapJID2Job& mapJID2Job = (*it).second;
		SeqMapJID2Job::iterator it= mapJID2Job.begin(), it_end=mapJID2Job.end();
		for( ; it != it_end; ++it)
		{
			 bsm::DefJob* defJob = (*it);
			 delete defJob;
		}
	}
	m_MapTID2MapJID2Job.clear();
}

//////////////////////////////////////////////////////////////////////////
//
void DefJobRepository::ClearJobsBySchedTable(const TableIds& table_ids)
{
	for( TableIds::const_iterator it0=table_ids.begin(), it0_end=table_ids.end(); it0!=it0_end; ++it0 )
	{
		const TableId& table_id = *it0;

		{
			MapTID2MapJID2Job::iterator it= m_MapTID2MapJID2Job.find(table_id);
			if( it != m_MapTID2MapJID2Job.end() )
			{
				SeqMapJID2Job& mapJID2Job = (*it).second;
				SeqMapJID2Job::iterator itj= mapJID2Job.begin(), itj_end=mapJID2Job.end();
				for( ; itj != itj_end; ++itj)
				{
					bsm::DefJob* defJob = *itj;
					delete defJob;
				}
				m_MapTID2MapJID2Job.erase(it);
			}
		}
	}
}



//////////////////////////////////////////////////////////////////////////
// read all tables in one select. it's used by initial load
//
void DefJobRepository::ReadJobsAll()
{
	DBG_FNC_ENTER("DefJobRepository::ReadJobsAll");

	// reference the DataAccessLayer and allocate database connection for the next db access
	DAL::Definition defDal(DAL::DALMgr::instance());
	RWDBConnection conn = DAL::DALMgr::instance()->GetConnection();

	int table_id =0;  //no filter by tables

	defDal.ReadJobs_main(table_id, m_MapTID2MapJID2Job, m_ExtMode, &conn);
	defDal.ReadJobs_parts(table_id, m_MapTID2MapJID2Job, &conn);

}



//////////////////////////////////////////////////////////////////////////
//
void DefJobRepository::ReadSchedTables(bsm::DefTableInfos& defTables)
{
	DBG_FNC_ENTER("DefJobRepository::ReadSchedTables");
	defTables.clear();

	// reference the DataAccessLayer and allocate database connection for the next db access
	DAL::Definition defDal(DAL::DALMgr::instance());
	RWDBConnection conn = DAL::DALMgr::instance()->GetConnection();

	// read all table definitions information
	DIAG_PDEF(DIAG_D, "read all table definitions information");

	if (defDal.ReadDefTables(defTables, &conn) != 0)
	{
		throw EmException("cannot read scheduled table list");
	}
	
}

//////////////////////////////////////////////////////////////////////////
//
void DefJobRepository::ReadDataCenters()
{
	DBG_FNC_ENTER("DefJobRepository::ReadDataCenters");
	m_CommDomVec.clear();

	// reference the DataAccessLayer and allocate database connection for the next db access
	DAL::Definition defDal(DAL::DALMgr::instance());
	RWDBConnection conn = DAL::DALMgr::instance()->GetConnection();

	// read all table definitions information
	DIAG_PDEF(DIAG_D, "read datacenter definition information");

	int rc = defDal.ReadDataCenters(m_CommDomVec, &conn);
	if( rc != 0 )
	{
		throw EmException("cannot read Data Centers");
	}
}

//////////////////////////////////////////////////////////////////////////\
// how many are there jobs in the repository?
//
size_t DefJobRepository::GetDefJobNumber() const
{
	DBG_FNC_ENTER("DefJobRepository::GetDefJobNumber");

	size_t size = 0;
	MapTID2MapJID2Job::const_iterator it= m_MapTID2MapJID2Job.begin(), it_end=m_MapTID2MapJID2Job.end();
	for( ; it != it_end; ++it)
	{
		const SeqMapJID2Job& mapJID2Job = (*it).second;
		size += mapJID2Job.size();
	}

	return size;
}

//////////////////////////////////////////////////////////////////////////
// return all jobs belongs to a table id
//
void DefJobRepository::GetDefJobsByTableId( TableId table_id, bsm::DefJobVec& defJobs ) const
{
	DBG_FNC_ENTER("DefJobRepository::GetJobItByTableId");
	MapTID2MapJID2Job::const_iterator it= m_MapTID2MapJID2Job.find(table_id);
	if( it != m_MapTID2MapJID2Job.end() )
	{
		const SeqMapJID2Job& mapJID2Job = (*it).second;
		defJobs.reserve(mapJID2Job.size());
		for( SeqMapJID2Job::const_iterator it=mapJID2Job.begin(), it_end=mapJID2Job.end(); it!=it_end; ++it)
			defJobs.push_back(*it);
	}
}

//////////////////////////////////////////////////////////////////////////
// look for Def Job by table and job id and return pointer on it else return NULL
// 
bsm::DefJob* DefJobRepository::GetDefJobsByTableAndJobId( TableId table_id, TableId job_id ) const
{
	DBG_FNC_ENTER("DefJobRepository::GetJobItByTableId");
	bsm::DefJob* defJob = NULL;
	MapTID2MapJID2Job::const_iterator it= m_MapTID2MapJID2Job.find(table_id);
	if( it != m_MapTID2MapJID2Job.end() )
	{
		const SeqMapJID2Job& mapJID2Job = (*it).second;
		defJob = mapJID2Job.find(job_id); //if not found then NULL will be return
	}

	return defJob;
}



//////////////////////////////////////////////////////////////////////////
// parse all jobs in the table id list for CTMUDLY pattern to find requested user daily table name
//
void DefJobRepository::ParseUserDaily( const TableIds& tableIds )
{
	DBG_FNC_ENTER("DefJobRepository::ParseUserDaily");
	for( TableIds::const_iterator it=tableIds.begin(), it_end=tableIds.end(); it!=it_end; ++it)
	{
		const TableId& table_id = *it;
		bsm::DefJobVec defJobs;
		GetDefJobsByTableId(table_id, defJobs);
		for( bsm::DefJobVec::iterator it=defJobs.begin(), it_end=defJobs.end(); it != it_end; ++it)
		{
			bsm::DefJob* def_job = *it;
			std::string userDaily;
			m_UserDailyParser.Parse(*def_job, userDaily);
			if( !userDaily.empty())
			{
				DIAG_PDEF( DIAG_D, "found a user daily, job name: '" << def_job->GetName() << "'userdaily: '" << userDaily << "'");
				def_job->SetUserDailyNameToOrder(userDaily);
			}
		}
	}

}

const bsm::DefTableInfos& DefJobRepository::GetDefTables() const
{
	return m_DefTableInfosCurr;
}

const DAL::Definition::CommDomVec& DefJobRepository::GetDataCenters() const 
{ 
	return m_CommDomVec; 
}


//////////////////////////////////////////////////////////////////////////
// load statistics definition and values for all DCs
//
size_t DefJobRepository::LoadStatistics()
{
	DBG_FNC_ENTER("DefJobRepository::LoadStatistics");

	bsm::MemoryWatcher memoryWatcher;
	os_stopwatch stopwatch;
	memoryWatcher.Start();
	stopwatch.start();


	RWDBConnection conn = DAL::DALMgr::instance()->GetConnection();
	PeriodicStats::PeriodicStatsMgr* periodicStatsMgr = PeriodicStats::PeriodicStatsMgr::Instance();
	periodicStatsMgr->Clear();
	periodicStatsMgr->LoadDefsFromDB(conn);

	std::vector< std::string > dc_names;

	size_t all_recn = 0;
	for (size_t i = 0; i < m_CommDomVec.size();  ++i)
	{
		commDom& c = m_CommDomVec[i];
		RWCString dc_name = c.data_center().std();
		dc_names.push_back(dc_name.std());
	}
	std::sort(dc_names.begin(), dc_names.end());

	for( size_t i = 0; i < dc_names.size();  ++i )
	{
		const std::string& dc_name = dc_names[i];
		DIAG_PDEF(DIAG_D, "read statistics for " << dc_name);
		TRC res = periodicStatsMgr->LoadStatsFromDB(conn, dc_name);
		if(res != TRC_SUCCESS)
		{
			DIAG_PDEF(DIAG_E, "Failed to load statistics from database for CONTROL-M " << dc_name);
		}

		all_recn += periodicStatsMgr->GetRecordCount(dc_name);
	}

	memoryWatcher.Stop();
	stopwatch.stop();

	DIAG_P(DIAGC_BIM, DIAG_I, "Statistics is read." 
		<< " Records: " << all_recn
		<< " Memory: " << memoryWatcher.GetSize()
		<< " Blocks: " << memoryWatcher.GetCount()
		<< " Time: " << em::tos(stopwatch.lap())
		);

	return all_recn;
}



}} // Forecast::Service

OUTPUT_END
Execute (c:\utils\ccm_task_diff.pl:128): EXECUTE_CMD: ccm diff -vc  DefJobRepository.cpp#5.1.1:cpp:1
Execute (c:\utils\ccm_task_diff.pl:128): OUTPUT_BEGIN
Attribute name            DefJobRepository.cpp#5     DefJobRepository.cpp#5.1.1
------------------------- -------------------------- --------------------------
create_time               Wed May 06 13:47:53 2009   Mon Dec 14 13:42:40 2009  
modify_time               Wed Aug 12 17:57:51 2009   Wed Dec 23 13:25:04 2009  
release                   6.4.0.02                   6.4.0.04                  
status                    released                   integrate                 
version                   5                          5.1.1                     
comment                   changed to sqa state by... <doesn't exist>           
source_create_time        Wed May 06 13:47:53 2009   Mon Dec 14 13:42:41 2009  
source_modify_time        Wed May 06 15:41:07 2009   Mon Dec 14 13:42:39 2009  

===============================================================================
Associated tasks differs:

DefJobRepository.cpp#5
39315: Fix for Task 39309: Fix for Task 39254: Read scheduling group before jobs

DefJobRepository.cpp#5.1.1
43731: 640.4: bsm: forecast: diag: print bim data  w/o name

===============================================================================
Text attribute 'source' differs:

10c10
< *	%date_created:	Wed May 06 13:47:53 2009 %
---
> *	%date_created:	Mon Dec 14 13:42:40 2009 %
14c14
< static const char *_cxxsrc = "@(#) %filespec: DefJobRepository.cpp#5 %  (%full_filespec: DefJobRepository.cpp#5:cpp:1 %)";
---
> static const char *_cxxsrc = "@(#) %filespec: DefJobRepository.cpp#5.1.1 %  (%full_filespec: DefJobRepository.cpp#5.1.1:cpp:1 %)";
199a200
> 			DIAG_PDEF( DIAG_E, "Error reading sched table from DB" << table_id );
208a210
> 	DBG_FNC_ENTER("DefJobRepository::ReadJobsBySchedTable");
214c216
< 	if( rc == 0 )
---
> 	if( rc == 0 ){
215a218,221
> 	}
> 	else{
> 		DIAG_PDEF( DIAG_E, "Error reading sched table from DB" << table_id );
> 	}

===============================================================================
Text attribute 'status_log' differs:

1,4c1,2
< Wed May  6 13:47:53 2009: Status set to 'working' by yakovt in role developer
< Wed May  6 17:51:59 2009: Status set to 'integrate' by yakovt in role developer
< Thu May  7 11:08:59 2009: Status set to 'sqa' by bldrem in role build_mgr
< Wed Aug 12 17:57:51 2009: Status set to 'released' by bldrem in role ccm_admin
---
> Mon Dec 14 13:42:40 2009: Status set to 'working' by yakovt in role developer
> Wed Dec 23 13:25:04 2009: Status set to 'integrate' by yakovt in role developer


OUTPUT_END
Execute (c:\utils\ccm_task_diff.pl:174): EXECUTE_CMD: ccm cat DefJobRepository.cpp#5:cpp:1
Execute (c:\utils\ccm_task_diff.pl:174): OUTPUT_BEGIN
/**********************************************************************
*                 Copyright BMC Software Inc.,
*     as an unpublished licensed work. All rights reserved.
*     -----------------------------------------------------
*
*	C++ %name:		DefJobRepository.cpp %
*	Instance:		1
*	Description:	
*	%created_by:	yakovt %
*	%date_created:	Wed May 06 13:47:53 2009 %
*
**********************************************************************/
#ifndef lint
static const char *_cxxsrc = "@(#) %filespec: DefJobRepository.cpp#5 %  (%full_filespec: DefJobRepository.cpp#5:cpp:1 %)";
#endif

#include "stdafx.h"
#include <BsmCommon/DefJob.h>
#include <em_foundations/EmHelper.h>
#include <em_foundations/EmException.h>
#include <ForecastService/DefJobRepository.h>
#include <ForecastDAL/Definition.h>
#include <ForecastDAL/DALMgr.h>
#include <BsmCommon/Values.h>
#include <BsmCommon/Helper.h>
#include <PeriodicStats/PeriodicStatsMgr.h>
#include <BsmCommon/Values.h>

DIAG_REGISTER_MODULE;

namespace Forecast {
namespace Service {

EM_SINGLETON_IMPLEMENTATION(DefJobRepository)
ACE_RW_Thread_Mutex DefJobRepository::m_Lock;

DefJobRepositoryAutoReadLocker::DefJobRepositoryAutoReadLocker()
{
	DefJobRepository::Instance()->m_Lock.acquire_read();
}

DefJobRepositoryAutoReadLocker::~DefJobRepositoryAutoReadLocker()
{
	DefJobRepository::Instance()->m_Lock.release();
}



DefJobRepository::DefJobRepository()
: m_ConfigurationWasSet( false )
, m_ExtMode ( false )
, m_LastError(0)
{
}



//////////////////////////////////////////////////////////////////////////
// set configuration and init the User Daily parser. should be called before first using
//
void DefJobRepository::SetConfiguration(const Forecast::Common::ForecastParameters& params )
{
	ACE_Write_Guard<ACE_RW_Thread_Mutex> guard(m_Lock);

	m_Params = params;

	m_UserDailyParser.SetConfiguration(params); //will init the regular expression in the object

	m_ConfigurationWasSet = true;
}

//////////////////////////////////////////////////////////////////////////
// Update the repository incrementally
//
void DefJobRepository::Update(bool read_all /*= false*/)
{
	DBG_FNC_ENTER("DefJobRepository::Update");
	EM_ASSERT( m_ConfigurationWasSet == true, "configuraiotn should be set before, is SimGraph::SetSimParameters called?" );

	ACE_Write_Guard<ACE_RW_Thread_Mutex> guard(m_Lock);


	if( IsError() && read_all == false )
	{
		DIAG_PDEF( DIAG_I, "Initial reading all jobs definitions becouse previous error: " << m_LastError );
		read_all = true;
	}

	//there is  no error at start
	m_LastError = 0;

	m_DefTableInfosPrev = m_DefTableInfosCurr;
	ReadSchedTables(m_DefTableInfosCurr);
	ReadDataCenters();

	// fill engine with datacenter information
	for (size_t i = 0; i < m_CommDomVec.size();  ++i)
	{
		commDom& c = m_CommDomVec[i];

		// fill missing data in table definition information
		for (size_t j = 0; j < m_DefTableInfosCurr.size(); ++j)
		{
			if (m_DefTableInfosCurr[j].m_DataCenter == c.data_center())
			{
				m_DefTableInfosCurr[j].m_CTMVer = c.control_m_ver();
				m_DefTableInfosCurr[j].m_Platform = c.platform();
			}
		}
	}



	TableIds to_remove; //removed or updated table
	TableIds to_read;   //new or updated table
	FindUpdatedTablesDiff(to_remove, to_read);

	if( read_all == false )
	{
		if( m_DefTableInfosPrev.empty() && !to_read.empty()  )
		{
			DIAG_PDEF( DIAG_I, "Initial reading all jobs definitions" );
			read_all = true;
		}
	}

	if( read_all )
	{
		ClearAllJobs();
		//we can clear here the all shared string because all jobs are used those string were deleted above
		bsm::ValueStringShared::GetValueStringSet().Clear();

		ReadJobsAll();

		DIAG_PDEF( DIAG_I, m_DefTableInfosCurr.size() << " job definition tables were read");

		size_t all_recn = LoadStatistics();

		DIAG_PDEF(DIAG_I, "load " << all_recn << " statistics record from database for all CONTROL-M ");

	}

	else 
	{
		//incremental read

		if( !to_remove.empty() || !to_read.empty() )
		{
			DIAG_PDEF( DIAG_I, "there are some updates in jobs definitions: " 
				<< to_remove.size() << " old tables will be removed, "
				<< to_read.size() << " new/updated tables will be added");

			ClearJobsBySchedTable(to_remove);
			ClearJobsBySchedTable(to_read);
			ReadJobsBySchedTables(to_read);
		}
		else
		{
			DIAG_PDEF( DIAG_I, "there is no updates in jobs definitions" );
		}
	}

	// in case 'read all' the to_read vector have to consist of all tables (it will be used during pares UD)
	if( read_all )
	{
		// fill to_read with all read tables ID. it will be used latter in parse UD
		to_read.clear();
		to_read.reserve(m_DefTableInfosCurr.size());
		for( bsm::DefTableInfos::const_iterator cur_it=m_DefTableInfosCurr.begin(), cur_it_end=m_DefTableInfosCurr.end();
			cur_it != cur_it_end; ++cur_it )
		{
			to_read.push_back( (*cur_it).m_Table_ID );
		}
	}

	if( !to_read.empty() )
	{
		DIAG_PDEF( DIAG_I, "going to parse jobs User daily for " << to_read.size() << " tables" );
		ParseUserDaily(to_read);
	}

	DIAG_PDEF( DIAG_I, "There are " << DefJobRepository::GetDefJobNumber() << " jobs in Repository" );
}


//////////////////////////////////////////////////////////////////////////
//
void DefJobRepository::ReadJobsBySchedTables(const TableIds& table_ids)
{
	DBG_FNC_ENTER("DefJobRepository::ReadJobsBySchedTables");

	// read all table definitions information
	DIAG_PDEF(DIAG_D, "read table definitions information by scheduled tables");

	for( size_t i=0; i<table_ids.size(); ++i )
	{
		TableId table_id = table_ids[i];
		ReadJobsBySchedTable(table_id);
		if( IsError() )
			break; //do not continue in case any error
	}
}

//////////////////////////////////////////////////////////////////////////
//table_id=0, read all!
//
void DefJobRepository::ReadJobsBySchedTable(TableId table_id)
{
	DAL::Definition defDal(DAL::DALMgr::instance());
	RWDBConnection conn = DAL::DALMgr::instance()->GetConnection();

	int rc = 0;
	rc = defDal.ReadJobs_main(table_id, m_MapTID2MapJID2Job, m_ExtMode, &conn);
	if( rc == 0 )
		rc = defDal.ReadJobs_parts(table_id, m_MapTID2MapJID2Job, &conn);
	
	m_LastError = rc;
}


//////////////////////////////////////////////////////////////////////////
// the definition tables are sorted by table id (by DB select) 
// all old tables will be removed from repository
// all new table will be read and added into repository
// all updated tables will be removed, read again and added into repository
//
void DefJobRepository::FindUpdatedTablesDiff( TableIds& to_remove, TableIds& to_read ) const
{
	DBG_FNC_ENTER("DefJobRepository::FindUpdatedTablesDiff");

	bsm::DefTableInfos::const_iterator cur_it=m_DefTableInfosCurr.begin(), cur_it_end=m_DefTableInfosCurr.end(); 
	bsm::DefTableInfos::const_iterator prv_it=m_DefTableInfosPrev.begin(), prv_it_end=m_DefTableInfosPrev.end(); 
	while( prv_it != prv_it_end && cur_it != cur_it_end )
	{
		const bsm::DefTableInfo& prv = *prv_it;
		const bsm::DefTableInfo& cur = *cur_it;
		if( cur.m_Table_ID < prv.m_Table_ID )
		{
			//current is not found in previous, it's new table
			to_read.push_back(cur.m_Table_ID); //should be read and added into repository
			++cur_it;
		}
		else if( prv.m_Table_ID < cur.m_Table_ID )
		{
			//previous is not found in current, it's old table
			to_remove.push_back(prv.m_Table_ID); //should be removed from repository
			++prv_it;
		}
		else //it existed table  
		{
			if( prv.m_LastUpdated < cur.m_LastUpdated )
			{
				// the current table is updated, should be re-read( removed and added)
				to_remove.push_back(cur.m_Table_ID); 
				to_read.push_back(cur.m_Table_ID); 
			}
			++cur_it;
			++prv_it;
		}
	}

	// for all rest previous table -- remove
	for( ; prv_it != prv_it_end; ++prv_it )
	{
		const bsm::DefTableInfo& prv = *prv_it;
		to_remove.push_back(prv.m_Table_ID); 
	}

	// for all rest current table -- read
	for( ; cur_it != cur_it_end; ++cur_it )
	{
		const bsm::DefTableInfo& cur = *cur_it;
		to_read.push_back(cur.m_Table_ID); 
	}
}


//////////////////////////////////////////////////////////////////////////
// 
void DefJobRepository::ClearAllJobs()
{
	DBG_FNC_ENTER("DefJobRepository::ClearAllJobs");

	MapTID2MapJID2Job::iterator it= m_MapTID2MapJID2Job.begin(), it_end=m_MapTID2MapJID2Job.end();
	for( ; it != it_end; ++it)
	{
		SeqMapJID2Job& mapJID2Job = (*it).second;
		SeqMapJID2Job::iterator it= mapJID2Job.begin(), it_end=mapJID2Job.end();
		for( ; it != it_end; ++it)
		{
			 bsm::DefJob* defJob = (*it);
			 delete defJob;
		}
	}
	m_MapTID2MapJID2Job.clear();
}

//////////////////////////////////////////////////////////////////////////
//
void DefJobRepository::ClearJobsBySchedTable(const TableIds& table_ids)
{
	for( TableIds::const_iterator it0=table_ids.begin(), it0_end=table_ids.end(); it0!=it0_end; ++it0 )
	{
		const TableId& table_id = *it0;

		{
			MapTID2MapJID2Job::iterator it= m_MapTID2MapJID2Job.find(table_id);
			if( it != m_MapTID2MapJID2Job.end() )
			{
				SeqMapJID2Job& mapJID2Job = (*it).second;
				SeqMapJID2Job::iterator itj= mapJID2Job.begin(), itj_end=mapJID2Job.end();
				for( ; itj != itj_end; ++itj)
				{
					bsm::DefJob* defJob = *itj;
					delete defJob;
				}
				m_MapTID2MapJID2Job.erase(it);
			}
		}
	}
}



//////////////////////////////////////////////////////////////////////////
// read all tables in one select. it's used by initial load
//
void DefJobRepository::ReadJobsAll()
{
	DBG_FNC_ENTER("DefJobRepository::ReadJobsAll");

	// reference the DataAccessLayer and allocate database connection for the next db access
	DAL::Definition defDal(DAL::DALMgr::instance());
	RWDBConnection conn = DAL::DALMgr::instance()->GetConnection();

	int table_id =0;  //no filter by tables

	defDal.ReadJobs_main(table_id, m_MapTID2MapJID2Job, m_ExtMode, &conn);
	defDal.ReadJobs_parts(table_id, m_MapTID2MapJID2Job, &conn);

}



//////////////////////////////////////////////////////////////////////////
//
void DefJobRepository::ReadSchedTables(bsm::DefTableInfos& defTables)
{
	DBG_FNC_ENTER("DefJobRepository::ReadSchedTables");
	defTables.clear();

	// reference the DataAccessLayer and allocate database connection for the next db access
	DAL::Definition defDal(DAL::DALMgr::instance());
	RWDBConnection conn = DAL::DALMgr::instance()->GetConnection();

	// read all table definitions information
	DIAG_PDEF(DIAG_D, "read all table definitions information");

	if (defDal.ReadDefTables(defTables, &conn) != 0)
	{
		throw EmException("cannot read scheduled table list");
	}
	
}

//////////////////////////////////////////////////////////////////////////
//
void DefJobRepository::ReadDataCenters()
{
	DBG_FNC_ENTER("DefJobRepository::ReadDataCenters");
	m_CommDomVec.clear();

	// reference the DataAccessLayer and allocate database connection for the next db access
	DAL::Definition defDal(DAL::DALMgr::instance());
	RWDBConnection conn = DAL::DALMgr::instance()->GetConnection();

	// read all table definitions information
	DIAG_PDEF(DIAG_D, "read datacenter definition information");

	int rc = defDal.ReadDataCenters(m_CommDomVec, &conn);
	if( rc != 0 )
	{
		throw EmException("cannot read Data Centers");
	}
}

//////////////////////////////////////////////////////////////////////////\
// how many are there jobs in the repository?
//
size_t DefJobRepository::GetDefJobNumber() const
{
	DBG_FNC_ENTER("DefJobRepository::GetDefJobNumber");

	size_t size = 0;
	MapTID2MapJID2Job::const_iterator it= m_MapTID2MapJID2Job.begin(), it_end=m_MapTID2MapJID2Job.end();
	for( ; it != it_end; ++it)
	{
		const SeqMapJID2Job& mapJID2Job = (*it).second;
		size += mapJID2Job.size();
	}

	return size;
}

//////////////////////////////////////////////////////////////////////////
// return all jobs belongs to a table id
//
void DefJobRepository::GetDefJobsByTableId( TableId table_id, bsm::DefJobVec& defJobs ) const
{
	DBG_FNC_ENTER("DefJobRepository::GetJobItByTableId");
	MapTID2MapJID2Job::const_iterator it= m_MapTID2MapJID2Job.find(table_id);
	if( it != m_MapTID2MapJID2Job.end() )
	{
		const SeqMapJID2Job& mapJID2Job = (*it).second;
		defJobs.reserve(mapJID2Job.size());
		for( SeqMapJID2Job::const_iterator it=mapJID2Job.begin(), it_end=mapJID2Job.end(); it!=it_end; ++it)
			defJobs.push_back(*it);
	}
}

//////////////////////////////////////////////////////////////////////////
// look for Def Job by table and job id and return pointer on it else return NULL
// 
bsm::DefJob* DefJobRepository::GetDefJobsByTableAndJobId( TableId table_id, TableId job_id ) const
{
	DBG_FNC_ENTER("DefJobRepository::GetJobItByTableId");
	bsm::DefJob* defJob = NULL;
	MapTID2MapJID2Job::const_iterator it= m_MapTID2MapJID2Job.find(table_id);
	if( it != m_MapTID2MapJID2Job.end() )
	{
		const SeqMapJID2Job& mapJID2Job = (*it).second;
		defJob = mapJID2Job.find(job_id); //if not found then NULL will be return
	}

	return defJob;
}



//////////////////////////////////////////////////////////////////////////
// parse all jobs in the table id list for CTMUDLY pattern to find requested user daily table name
//
void DefJobRepository::ParseUserDaily( const TableIds& tableIds )
{
	DBG_FNC_ENTER("DefJobRepository::ParseUserDaily");
	for( TableIds::const_iterator it=tableIds.begin(), it_end=tableIds.end(); it!=it_end; ++it)
	{
		const TableId& table_id = *it;
		bsm::DefJobVec defJobs;
		GetDefJobsByTableId(table_id, defJobs);
		for( bsm::DefJobVec::iterator it=defJobs.begin(), it_end=defJobs.end(); it != it_end; ++it)
		{
			bsm::DefJob* def_job = *it;
			std::string userDaily;
			m_UserDailyParser.Parse(*def_job, userDaily);
			if( !userDaily.empty())
			{
				DIAG_PDEF( DIAG_D, "found a user daily, job name: '" << def_job->GetName() << "'userdaily: '" << userDaily << "'");
				def_job->SetUserDailyNameToOrder(userDaily);
			}
		}
	}

}

const bsm::DefTableInfos& DefJobRepository::GetDefTables() const
{
	return m_DefTableInfosCurr;
}

const DAL::Definition::CommDomVec& DefJobRepository::GetDataCenters() const 
{ 
	return m_CommDomVec; 
}


//////////////////////////////////////////////////////////////////////////
// load statistics definition and values for all DCs
//
size_t DefJobRepository::LoadStatistics()
{
	DBG_FNC_ENTER("DefJobRepository::LoadStatistics");

	bsm::MemoryWatcher memoryWatcher;
	os_stopwatch stopwatch;
	memoryWatcher.Start();
	stopwatch.start();


	RWDBConnection conn = DAL::DALMgr::instance()->GetConnection();
	PeriodicStats::PeriodicStatsMgr* periodicStatsMgr = PeriodicStats::PeriodicStatsMgr::Instance();
	periodicStatsMgr->Clear();
	periodicStatsMgr->LoadDefsFromDB(conn);

	std::vector< std::string > dc_names;

	size_t all_recn = 0;
	for (size_t i = 0; i < m_CommDomVec.size();  ++i)
	{
		commDom& c = m_CommDomVec[i];
		RWCString dc_name = c.data_center().std();
		dc_names.push_back(dc_name.std());
	}
	std::sort(dc_names.begin(), dc_names.end());

	for( size_t i = 0; i < dc_names.size();  ++i )
	{
		const std::string& dc_name = dc_names[i];
		DIAG_PDEF(DIAG_D, "read statistics for " << dc_name);
		TRC res = periodicStatsMgr->LoadStatsFromDB(conn, dc_name);
		if(res != TRC_SUCCESS)
		{
			DIAG_PDEF(DIAG_E, "Failed to load statistics from database for CONTROL-M " << dc_name);
		}

		all_recn += periodicStatsMgr->GetRecordCount(dc_name);
	}

	memoryWatcher.Stop();
	stopwatch.stop();

	DIAG_P(DIAGC_BIM, DIAG_I, "Statistics is read." 
		<< " Records: " << all_recn
		<< " Memory: " << memoryWatcher.GetSize()
		<< " Blocks: " << memoryWatcher.GetCount()
		<< " Time: " << em::tos(stopwatch.lap())
		);

	return all_recn;
}



}} // Forecast::Service

OUTPUT_END
Execute (c:\utils\ccm_task_diff.pl:228): diff -u C:/Tasks/43731/old/DefJobRepository.cpp C:/Tasks/43731/new/DefJobRepository.cpp
Execute (c:\utils\ccm_task_diff.pl:228): OUTPUT_BEGIN
--- C:/Tasks/43731/old/DefJobRepository.cpp	Thu Dec 24 11:29:10 2009
+++ C:/Tasks/43731/new/DefJobRepository.cpp	Thu Dec 24 11:29:09 2009
@@ -7,11 +7,11 @@
 *	Instance:		1
 *	Description:	
 *	%created_by:	yakovt %
-*	%date_created:	Wed May 06 13:47:53 2009 %
+*	%date_created:	Mon Dec 14 13:42:40 2009 %
 *
 **********************************************************************/
 #ifndef lint
-static const char *_cxxsrc = "@(#) %filespec: DefJobRepository.cpp#5 %  (%full_filespec: DefJobRepository.cpp#5:cpp:1 %)";
+static const char *_cxxsrc = "@(#) %filespec: DefJobRepository.cpp#5.1.1 %  (%full_filespec: DefJobRepository.cpp#5.1.1:cpp:1 %)";
 #endif
 
 #include "stdafx.h"
@@ -197,6 +197,7 @@
 		TableId table_id = table_ids[i];
 		ReadJobsBySchedTable(table_id);
 		if( IsError() )
+			DIAG_PDEF( DIAG_E, "Error reading sched table from DB" << table_id );
 			break; //do not continue in case any error
 	}
 }
@@ -206,13 +207,18 @@
 //
 void DefJobRepository::ReadJobsBySchedTable(TableId table_id)
 {
+	DBG_FNC_ENTER("DefJobRepository::ReadJobsBySchedTable");
 	DAL::Definition defDal(DAL::DALMgr::instance());
 	RWDBConnection conn = DAL::DALMgr::instance()->GetConnection();
 
 	int rc = 0;
 	rc = defDal.ReadJobs_main(table_id, m_MapTID2MapJID2Job, m_ExtMode, &conn);
-	if( rc == 0 )
+	if( rc == 0 ){
 		rc = defDal.ReadJobs_parts(table_id, m_MapTID2MapJID2Job, &conn);
+	}
+	else{
+		DIAG_PDEF( DIAG_E, "Error reading sched table from DB" << table_id );
+	}
 	
 	m_LastError = rc;
 }

OUTPUT_END
Execute (c:\utils\ccm_task_diff.pl:145): EXECUTE_CMD: ccm history SimGraphI.cpp#81.1.3.1.3:cpp:4
Execute (c:\utils\ccm_task_diff.pl:145): OUTPUT_BEGIN
Object:  SimGraphI.cpp#1 (cpp:4)
Owner:   ccm_root
State:   released
Created: Mon Jun 19 12:51:42 2006
Task:    25145
Comment:

Predecessors:
Successors:
	SimGraphI.cpp#2:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#2 (cpp:4)
Owner:   ariels
State:   sqa
Created: Tue Sep 05 15:58:50 2006
Task:    25965
Comment:
changed to sqa state by mntinteg
Predecessors:
	SimGraphI.cpp#1:cpp:4
Successors:
	SimGraphI.cpp#3:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#3 (cpp:4)
Owner:   mgendelm
State:   sqa
Created: Mon Dec 25 15:30:55 2006
Task:    26843
Comment:
changed to sqa state by mntinteg
Predecessors:
	SimGraphI.cpp#2:cpp:4
Successors:
	SimGraphI.cpp#4:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#4 (cpp:4)
Owner:   mgendelm
State:   sqa
Created: Wed Jan 10 13:54:06 2007
Task:    27081
Comment:
changed to sqa state by mntinteg
Predecessors:
	SimGraphI.cpp#3:cpp:4
Successors:
	SimGraphI.cpp#5:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#5 (cpp:4)
Owner:   mgendelm
State:   sqa
Created: Tue Jan 23 17:42:38 2007
Task:    27324
Comment:
changed to sqa state by mntinteg
Predecessors:
	SimGraphI.cpp#4:cpp:4
Successors:
	SimGraphI.cpp#6:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#6 (cpp:4)
Owner:   mgendelm
State:   sqa
Created: Sun Feb 25 14:52:44 2007
Task:    27323
Comment:
changed to sqa state by mntinteg
Predecessors:
	SimGraphI.cpp#5:cpp:4
Successors:
	SimGraphI.cpp#7:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#7 (cpp:4)
Owner:   yturgman
State:   sqa
Created: Sun Apr 15 22:23:08 2007
Task:    28409
Comment:
changed to sqa state by mntinteg
Predecessors:
	SimGraphI.cpp#6:cpp:4
Successors:
	SimGraphI.cpp#8:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#8 (cpp:4)
Owner:   kduchan
State:   sqa
Created: Thu May 10 11:55:54 2007
Task:    28706
Comment:
changed to sqa state by mntinteg
Predecessors:
	SimGraphI.cpp#7:cpp:4
Successors:
	SimGraphI.cpp#9:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#9 (cpp:4)
Owner:   yturgman
State:   sqa
Created: Sun May 20 17:23:47 2007
Task:    28799
Comment:
changed to sqa state by mntinteg
Predecessors:
	SimGraphI.cpp#8:cpp:4
Successors:
	SimGraphI.cpp#9.1.1:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#9.1.1 (cpp:4)
Owner:   yakovt
State:   sqa
Created: Thu Jun 21 16:02:07 2007
Task:    29110
Comment:
changed to sqa state by mntinteg
Predecessors:
	SimGraphI.cpp#9:cpp:4
Successors:
	SimGraphI.cpp#10:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#10 (cpp:4)
Owner:   kduchan
State:   sqa
Created: Sun Jun 24 10:38:09 2007
Task:    28995
Comment:
changed to sqa state by mntinteg
Predecessors:
	SimGraphI.cpp#9.1.1:cpp:4
Successors:
	SimGraphI.cpp#11:cpp:4
	SimGraphI.cpp#10.1.1:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#11 (cpp:4)
Owner:   yakovt
State:   sqa
Created: Thu Jun 28 16:10:13 2007
Task:    29162
Comment:
by tadmon
Predecessors:
	SimGraphI.cpp#10:cpp:4
Successors:
	SimGraphI.cpp#12:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#12 (cpp:4)
Owner:   yturgman
State:   sqa
Created: Sun Jul 08 19:18:34 2007
Task:    29188
Comment:
by tadmon
Predecessors:
	SimGraphI.cpp#11:cpp:4
Successors:
	SimGraphI.cpp#13:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#13 (cpp:4)
Owner:   yturgman
State:   sqa
Created: Sun Jul 15 15:05:10 2007
Task:    29315
Comment:
by tadmon
Predecessors:
	SimGraphI.cpp#12:cpp:4
Successors:
	SimGraphI.cpp#14:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#14 (cpp:4)
Owner:   yakovt
State:   sqa
Created: Sat Jul 21 11:39:39 2007
Task:    29407
Comment:
by tadmon
Predecessors:
	SimGraphI.cpp#13:cpp:4
Successors:
	SimGraphI.cpp#15:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#15 (cpp:4)
Owner:   yakovt
State:   sqa
Created: Mon Jul 23 13:55:57 2007
Task:    29426
Comment:
by tadmon
Predecessors:
	SimGraphI.cpp#14:cpp:4
Successors:
	SimGraphI.cpp#16:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#16 (cpp:4)
Owner:   yakovt
State:   sqa
Created: Wed Jul 25 10:52:13 2007
Task:    29458
Comment:
by tadmon
Predecessors:
	SimGraphI.cpp#15:cpp:4
Successors:
	SimGraphI.cpp#17:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#10.1.1 (cpp:4)
Owner:   rgalia
State:   sqa
Created: Mon Jul 30 17:08:33 2007
Task:    29528
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#10:cpp:4
Successors:
	SimGraphI.cpp#10.1.2:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#10.1.2 (cpp:4)
Owner:   rgalia
State:   sqa
Created: Tue Jul 31 07:53:23 2007
Task:    29536
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#10.1.1:cpp:4
Successors:
	SimGraphI.cpp#21:cpp:4
	SimGraphI.cpp#10.1.3:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#17 (cpp:4)
Owner:   tadmon
State:   sqa
Created: Thu Aug 02 15:13:33 2007
Task:    29614
Comment:
by tadmon
Predecessors:
	SimGraphI.cpp#16:cpp:4
Successors:
	SimGraphI.cpp#18:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#18 (cpp:4)
Owner:   tadmon
State:   sqa
Created: Tue Aug 14 13:55:24 2007
Task:    29568
Comment:
by tadmon
Predecessors:
	SimGraphI.cpp#17:cpp:4
Successors:
	SimGraphI.cpp#19:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#19 (cpp:4)
Owner:   tadmon
State:   sqa
Created: Sun Sep 02 14:57:39 2007
Task:    29899
Comment:
by tadmon
Predecessors:
	SimGraphI.cpp#18:cpp:4
Successors:
	SimGraphI.cpp#21:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#21 (cpp:4)
Owner:   tadmon
State:   sqa
Created: Sun Sep 02 15:22:46 2007
Task:    29901
Comment:
Merged 'SimGraphI.cpp#10.1.2' with 'SimGraphI.cpp#19'.
by tadmon
Predecessors:
	SimGraphI.cpp#10.1.2:cpp:4
	SimGraphI.cpp#19:cpp:4
Successors:
	SimGraphI.cpp#22:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#22 (cpp:4)
Owner:   tadmon
State:   sqa
Created: Sun Sep 02 17:48:29 2007
Task:    29905
Comment:
by tadmon
Predecessors:
	SimGraphI.cpp#21:cpp:4
Successors:
	SimGraphI.cpp#23:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#23 (cpp:4)
Owner:   tadmon
State:   sqa
Created: Tue Sep 04 10:13:54 2007
Task:    29943
Comment:
by tadmon
Predecessors:
	SimGraphI.cpp#22:cpp:4
Successors:
	SimGraphI.cpp#24:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#24 (cpp:4)
Owner:   yakovt
State:   sqa
Created: Tue Sep 11 14:56:43 2007
Task:    30036
Comment:
by tadmon
Predecessors:
	SimGraphI.cpp#23:cpp:4
Successors:
	SimGraphI.cpp#25:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#25 (cpp:4)
Owner:   eyals
State:   sqa
Created: Wed Sep 19 18:37:15 2007
Task:    30152
Comment:
by tadmon
Predecessors:
	SimGraphI.cpp#24:cpp:4
Successors:
	SimGraphI.cpp#26:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#26 (cpp:4)
Owner:   yturgman
State:   sqa
Created: Sun Oct 14 10:14:02 2007
Task:    30351
Comment:
by tadmon
Predecessors:
	SimGraphI.cpp#25:cpp:4
Successors:
	SimGraphI.cpp#27:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#27 (cpp:4)
Owner:   yturgman
State:   sqa
Created: Mon Oct 22 11:41:08 2007
Task:    30609
Comment:
by tadmon
Predecessors:
	SimGraphI.cpp#26:cpp:4
Successors:
	SimGraphI.cpp#28:cpp:4
	SimGraphI.cpp#27.1.1:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#28 (cpp:4)
Owner:   tadmon
State:   sqa
Created: Thu Oct 25 12:08:09 2007
Task:    30686
Comment:
by tadmon
Predecessors:
	SimGraphI.cpp#27:cpp:4
Successors:
	SimGraphI.cpp#29:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#29 (cpp:4)
Owner:   tadmon
State:   sqa
Created: Thu Oct 25 14:25:19 2007
Task:    30690
Comment:
by tadmon
Predecessors:
	SimGraphI.cpp#28:cpp:4
Successors:
	SimGraphI.cpp#30:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#27.1.1 (cpp:4)
Owner:   yturgman
State:   sqa
Created: Mon Oct 29 19:12:16 2007
Task:    30676
Comment:
by tadmon
Predecessors:
	SimGraphI.cpp#27:cpp:4
Successors:
	SimGraphI.cpp#30:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#30 (cpp:4)
Owner:   yturgman
State:   sqa
Created: Thu Nov 01 20:29:43 2007
Task:    30676
Comment:
Merged 'SimGraphI.cpp#27.1.1' with 'SimGraphI.cpp#29'.
by tadmon
Predecessors:
	SimGraphI.cpp#29:cpp:4
	SimGraphI.cpp#27.1.1:cpp:4
Successors:
	SimGraphI.cpp#10.1.4.1.1:cpp:4
	SimGraphI.cpp#31:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#10.1.3 (cpp:4)
Owner:   rgalia
State:   sqa
Created: Wed Nov 07 13:26:02 2007
Task:    30910
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#10.1.2:cpp:4
Successors:
	SimGraphI.cpp#10.1.4:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#10.1.4 (cpp:4)
Owner:   rgalia
State:   sqa
Created: Thu Nov 08 13:06:10 2007
Task:    30910
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#10.1.3:cpp:4
Successors:
	SimGraphI.cpp#10.1.4.1.1:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#10.1.4.1.1 (cpp:4)
Owner:   tadmon
State:   sqa
Created: Wed Nov 21 17:59:28 2007
Task:    31132
Comment:
Merged 'SimGraphI.cpp#10.1.4' with 'SimGraphI.cpp#30'.
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#30:cpp:4
	SimGraphI.cpp#10.1.4:cpp:4
Successors:
	SimGraphI.cpp#32:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#31 (cpp:4)
Owner:   yturgman
State:   sqa
Created: Sun Nov 25 17:44:36 2007
Task:    31172
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#30:cpp:4
Successors:
	SimGraphI.cpp#32:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#32 (cpp:4)
Owner:   yturgman
State:   sqa
Created: Sun Nov 25 18:51:16 2007
Task:    31180
Comment:
Merged 'SimGraphI.cpp#10.1.4.1.1' with 'SimGraphI.cpp#31'.
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#10.1.4.1.1:cpp:4
	SimGraphI.cpp#31:cpp:4
Successors:
	SimGraphI.cpp#33:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#33 (cpp:4)
Owner:   tadmon
State:   sqa
Created: Thu Dec 13 14:55:13 2007
Task:    31424
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#32:cpp:4
Successors:
	SimGraphI.cpp#34:cpp:4
	SimGraphI.cpp#33.1.1:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#34 (cpp:4)
Owner:   yturgman
State:   sqa
Created: Thu Dec 27 13:24:06 2007
Task:    31674
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#33:cpp:4
Successors:
	SimGraphI.cpp#35:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#35 (cpp:4)
Owner:   eyals
State:   sqa
Created: Wed Jan 02 09:23:01 2008
Task:    31773
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#34:cpp:4
Successors:
	SimGraphI.cpp#36:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#33.1.1 (cpp:4)
Owner:   tadmon
State:   sqa
Created: Wed Jan 02 09:35:10 2008
Task:    31527
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#33:cpp:4
Successors:
	SimGraphI.cpp#36:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#36 (cpp:4)
Owner:   tadmon
State:   sqa
Created: Wed Jan 02 14:46:57 2008
Task:    31794
Comment:
Merged 'SimGraphI.cpp#35' with 'SimGraphI.cpp#33.1.1'.
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#35:cpp:4
	SimGraphI.cpp#33.1.1:cpp:4
Successors:
	SimGraphI.cpp#37:cpp:4
	SimGraphI.cpp#36.1.1:cpp:4
	SimGraphI.cpp#36.2.1:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#37 (cpp:4)
Owner:   tadmon
State:   sqa
Created: Tue Jan 15 15:07:17 2008
Task:    32066
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#36:cpp:4
Successors:
	SimGraphI.cpp#38:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#36.1.1 (cpp:4)
Owner:   yakovt
State:   sqa
Created: Wed Jan 16 14:54:02 2008
Task:    32075
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#36:cpp:4
Successors:
	SimGraphI.cpp#38:cpp:4
	SimGraphI.cpp#36.1.2:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#38 (cpp:4)
Owner:   yakovt
State:   sqa
Created: Wed Jan 16 14:57:22 2008
Task:    32083
Comment:
Merged 'SimGraphI.cpp#37' with 'SimGraphI.cpp#36.1.1'.
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#37:cpp:4
	SimGraphI.cpp#36.1.1:cpp:4
Successors:
	SimGraphI.cpp#39:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#36.2.1 (cpp:4)
Owner:   yturgman
State:   sqa
Created: Sun Jan 20 19:04:39 2008
Task:    32048
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#36:cpp:4
Successors:
	SimGraphI.cpp#36.1.2:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#36.1.2 (cpp:4)
Owner:   yturgman
State:   sqa
Created: Tue Jan 22 09:55:43 2008
Task:    32048
Comment:
Merged 'SimGraphI.cpp#36.1.1' with 'SimGraphI.cpp#36.2.1'.
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#36.1.1:cpp:4
	SimGraphI.cpp#36.2.1:cpp:4
Successors:
	SimGraphI.cpp#39:cpp:4
	SimGraphI.cpp#36.1.3:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#39 (cpp:4)
Owner:   yturgman
State:   sqa
Created: Tue Jan 22 10:46:28 2008
Task:    32146
Comment:
Merged 'SimGraphI.cpp#38' with 'SimGraphI.cpp#36.1.2'.
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#38:cpp:4
	SimGraphI.cpp#36.1.2:cpp:4
Successors:
	SimGraphI.cpp#40:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#36.1.3 (cpp:4)
Owner:   yturgman
State:   sqa
Created: Sun Jan 27 12:23:07 2008
Task:    32215
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#36.1.2:cpp:4
Successors:
	SimGraphI.cpp#40:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#40 (cpp:4)
Owner:   yturgman
State:   sqa
Created: Thu Jan 31 19:32:33 2008
Task:    32297
Comment:
Merged 'SimGraphI.cpp#39' with 'SimGraphI.cpp#36.1.3'.
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#39:cpp:4
	SimGraphI.cpp#36.1.3:cpp:4
Successors:
	SimGraphI.cpp#41:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#41 (cpp:4)
Owner:   tadmon
State:   sqa
Created: Mon Feb 04 14:08:34 2008
Task:    32334
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#40:cpp:4
Successors:
	SimGraphI.cpp#42:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#42 (cpp:4)
Owner:   tadmon
State:   sqa
Created: Wed Feb 06 09:39:43 2008
Task:    32376
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#41:cpp:4
Successors:
	SimGraphI.cpp#43:cpp:4
	SimGraphI.cpp#42.1.1:cpp:4
	SimGraphI.cpp#42.2.1:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#43 (cpp:4)
Owner:   hagitr
State:   sqa
Created: Thu Feb 07 15:43:02 2008
Task:    32209
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#42:cpp:4
Successors:
	SimGraphI.cpp#45:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#42.1.1 (cpp:4)
Owner:   kduchan
State:   sqa
Created: Thu Feb 14 13:05:25 2008
Task:    32471
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#42:cpp:4
Successors:
	SimGraphI.cpp#42.1.2:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#42.2.1 (cpp:4)
Owner:   tadmon
State:   sqa
Created: Thu Feb 21 16:42:54 2008
Task:    32700
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#42:cpp:4
Successors:
	SimGraphI.cpp#42.1.2:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#42.1.2 (cpp:4)
Owner:   tadmon
State:   sqa
Created: Thu Feb 21 17:16:17 2008
Task:    32705
Comment:
Merged 'SimGraphI.cpp#42.1.1' with 'SimGraphI.cpp#42.2.1'.
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#42.1.1:cpp:4
	SimGraphI.cpp#42.2.1:cpp:4
Successors:
	SimGraphI.cpp#42.1.3:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#42.1.3 (cpp:4)
Owner:   tadmon
State:   sqa
Created: Tue Feb 26 17:23:34 2008
Task:    32808
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#42.1.2:cpp:4
Successors:
	SimGraphI.cpp#42.1.4:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#42.1.4 (cpp:4)
Owner:   tadmon
State:   sqa
Created: Wed Feb 27 11:30:06 2008
Task:    32818
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#42.1.3:cpp:4
Successors:
	SimGraphI.cpp#42.1.5:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#42.1.5 (cpp:4)
Owner:   tadmon
State:   sqa
Created: Wed Mar 05 16:12:18 2008
Task:    33026
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#42.1.4:cpp:4
Successors:
	SimGraphI.cpp#44:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#44 (cpp:4)
Owner:   yakovt
State:   sqa
Created: Tue Mar 25 15:04:14 2008
Task:    33527
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#42.1.5:cpp:4
Successors:
	SimGraphI.cpp#45:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#45 (cpp:4)
Owner:   hagitr
State:   sqa
Created: Tue Mar 25 15:20:59 2008
Task:    33528
Comment:
Merged 'SimGraphI.cpp#44' with 'SimGraphI.cpp#43'.
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#43:cpp:4
	SimGraphI.cpp#44:cpp:4
Successors:
	SimGraphI.cpp#46:cpp:4
	SimGraphI.cpp#45.1.1:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#46 (cpp:4)
Owner:   yakovt
State:   sqa
Created: Thu Apr 10 17:25:22 2008
Task:    33845
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#45:cpp:4
Successors:
	SimGraphI.cpp#47:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#45.1.1 (cpp:4)
Owner:   yturgman
State:   sqa
Created: Tue Apr 22 14:05:51 2008
Task:    33978
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#45:cpp:4
Successors:
	SimGraphI.cpp#47:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#47 (cpp:4)
Owner:   yturgman
State:   sqa
Created: Tue Apr 22 14:28:58 2008
Task:    33980
Comment:
Merged 'SimGraphI.cpp#46' with 'SimGraphI.cpp#45.1.1'.
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#46:cpp:4
	SimGraphI.cpp#45.1.1:cpp:4
Successors:
	SimGraphI.cpp#48:cpp:4
	SimGraphI.cpp#47.1.1:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#48 (cpp:4)
Owner:   yakovt
State:   sqa
Created: Wed Apr 30 18:09:20 2008
Task:    34169
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#47:cpp:4
Successors:
	SimGraphI.cpp#49:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#47.1.1 (cpp:4)
Owner:   yturgman
State:   sqa
Created: Thu May 01 13:11:48 2008
Task:    34190
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#47:cpp:4
Successors:
	SimGraphI.cpp#49:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#49 (cpp:4)
Owner:   yturgman
State:   sqa
Created: Mon May 05 09:35:34 2008
Task:    34190
Comment:
Merged 'SimGraphI.cpp#48' with 'SimGraphI.cpp#47.1.1'.
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#48:cpp:4
	SimGraphI.cpp#47.1.1:cpp:4
Successors:
	SimGraphI.cpp#50:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#50 (cpp:4)
Owner:   yakovt
State:   released
Created: Tue May 20 17:48:04 2008
Task:    34522
Comment:
changed to sqa state by GAP automatic approval

Predecessors:
	SimGraphI.cpp#49:cpp:4
Successors:
	SimGraphI.cpp#51:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#51 (cpp:4)
Owner:   tadmon
State:   sqa
Created: Thu Jun 19 14:46:51 2008
Task:    34973
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#50:cpp:4
Successors:
	SimGraphI.cpp#52:cpp:4
	SimGraphI.cpp#51.1.1:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#52 (cpp:4)
Owner:   yakovt
State:   sqa
Created: Tue Jul 01 17:21:37 2008
Task:    35048
Comment:
checked in by tamar
Predecessors:
	SimGraphI.cpp#51:cpp:4
Successors:
	SimGraphI.cpp#53:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#53 (cpp:4)
Owner:   yakovt
State:   sqa
Created: Tue Jul 08 14:06:34 2008
Task:    35119
Comment:
checked in by tamar
Predecessors:
	SimGraphI.cpp#52:cpp:4
Successors:
	SimGraphI.cpp#54:cpp:4
	SimGraphI.cpp#53.1.1:cpp:4
	SimGraphI.cpp#53.2.1:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#54 (cpp:4)
Owner:   yakovt
State:   sqa
Created: Tue Jul 08 18:41:17 2008
Task:    35469
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#53:cpp:4
Successors:
	SimGraphI.cpp#55:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#53.1.1 (cpp:4)
Owner:   tadmon
State:   sqa
Created: Mon Aug 04 15:28:08 2008
Task:    35455
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#53:cpp:4
Successors:
	SimGraphI.cpp#53.2.2:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#53.2.1 (cpp:4)
Owner:   yturgman
State:   sqa
Created: Sun Aug 10 09:00:20 2008
Task:    33515
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#53:cpp:4
Successors:
	SimGraphI.cpp#53.2.2:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#53.2.2 (cpp:4)
Owner:   yturgman
State:   sqa
Created: Tue Sep 02 15:50:47 2008
Task:    35710
Comment:
Merged 'SimGraphI.cpp#53.2.1' with 'SimGraphI.cpp#53.1.1'.
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#53.1.1:cpp:4
	SimGraphI.cpp#53.2.1:cpp:4
Successors:
	SimGraphI.cpp#53.2.3:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#53.2.3 (cpp:4)
Owner:   yturgman
State:   sqa
Created: Tue Sep 02 18:38:23 2008
Task:    35724
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#53.2.2:cpp:4
Successors:
	SimGraphI.cpp#56:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#51.1.1 (cpp:4)
Owner:   tadmon
State:   sqa
Created: Sun Sep 07 13:53:01 2008
Task:    35795
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#51:cpp:4
Successors:
	SimGraphI.cpp#56:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#56 (cpp:4)
Owner:   tadmon
State:   sqa
Created: Mon Sep 08 11:24:27 2008
Task:    35825
Comment:
Merged 'SimGraphI.cpp#51.1.1' with 'SimGraphI.cpp#53.2.3'.
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#53.2.3:cpp:4
	SimGraphI.cpp#51.1.1:cpp:4
Successors:
	SimGraphI.cpp#57:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#57 (cpp:4)
Owner:   yturgman
State:   sqa
Created: Thu Sep 11 18:45:07 2008
Task:    35916
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#56:cpp:4
Successors:
	SimGraphI.cpp#55:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#55 (cpp:4)
Owner:   yakovt
State:   sqa
Created: Mon Sep 15 13:14:27 2008
Task:    35469
Comment:
Merged 'SimGraphI.cpp#54' with 'SimGraphI.cpp#57'.
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#54:cpp:4
	SimGraphI.cpp#57:cpp:4
Successors:
	SimGraphI.cpp#58:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#58 (cpp:4)
Owner:   yakovt
State:   sqa
Created: Mon Sep 22 11:59:47 2008
Task:    36060
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#55:cpp:4
Successors:
	SimGraphI.cpp#59:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#59 (cpp:4)
Owner:   yakovt
State:   sqa
Created: Wed Sep 24 11:39:25 2008
Task:    36103
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#58:cpp:4
Successors:
	SimGraphI.cpp#60:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#60 (cpp:4)
Owner:   yakovt
State:   sqa
Created: Wed Sep 24 20:26:15 2008
Task:    36130
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#59:cpp:4
Successors:
	SimGraphI.cpp#61:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#61 (cpp:4)
Owner:   yakovt
State:   sqa
Created: Sun Sep 28 16:06:43 2008
Task:    36171
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#60:cpp:4
Successors:
	SimGraphI.cpp#62:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#62 (cpp:4)
Owner:   yakovt
State:   sqa
Created: Sun Oct 05 16:55:37 2008
Task:    36203
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#61:cpp:4
Successors:
	SimGraphI.cpp#63:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#63 (cpp:4)
Owner:   yakovt
State:   sqa
Created: Mon Oct 06 07:54:44 2008
Task:    36206
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#62:cpp:4
Successors:
	SimGraphI.cpp#64:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#64 (cpp:4)
Owner:   yakovt
State:   sqa
Created: Thu Oct 16 12:51:25 2008
Task:    36255
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#63:cpp:4
Successors:
	SimGraphI.cpp#65:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#65 (cpp:4)
Owner:   eyals
State:   sqa
Created: Sun Nov 30 15:01:20 2008
Task:    36885
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#64:cpp:4
Successors:
	SimGraphI.cpp#66:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#66 (cpp:4)
Owner:   yakovt
State:   sqa
Created: Wed Dec 10 18:37:09 2008
Task:    37107
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#65:cpp:4
Successors:
	SimGraphI.cpp#67:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#67 (cpp:4)
Owner:   yakovt
State:   released
Created: Tue Dec 30 16:35:11 2008
Task:    37477
Comment:
changed to sqa state by GAP automatic approval

Predecessors:
	SimGraphI.cpp#66:cpp:4
Successors:
	SimGraphI.cpp#68:cpp:4
	SimGraphI.cpp#71:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#68 (cpp:4)
Owner:   yturgman
State:   sqa
Created: Wed Mar 25 21:52:40 2009
Task:    38860
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#67:cpp:4
Successors:
	SimGraphI.cpp#69:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#69 (cpp:4)
Owner:   yturgman
State:   sqa
Created: Mon Mar 30 14:49:41 2009
Task:    38905
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#68:cpp:4
Successors:
	SimGraphI.cpp#70:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#70 (cpp:4)
Owner:   yturgman
State:   released
Created: Wed Apr 01 18:18:37 2009
Task:    38955
Comment:
changed to sqa state by GAP automatic approval

Predecessors:
	SimGraphI.cpp#69:cpp:4
Successors:
	SimGraphI.cpp#70.1.1:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#71 (cpp:4)
Owner:   yakovt
State:   sqa
Created: Thu Apr 23 17:11:40 2009
Task:    39168
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#67:cpp:4
Successors:
	SimGraphI.cpp#72:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#70.1.1 (cpp:4)
Owner:   yturgman
State:   released
Created: Thu May 07 14:01:25 2009
Task:    39342
Comment:
changed to sqa state by GAP automatic approval

Predecessors:
	SimGraphI.cpp#70:cpp:4
Successors:
	SimGraphI.cpp#72:cpp:4
	SimGraphI.cpp#81:cpp:4
	SimGraphI.cpp#70.1.2:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#72 (cpp:4)
Owner:   yakovt
State:   sqa
Created: Sun May 10 15:01:04 2009
Task:    39374
Comment:
Merged 'SimGraphI.cpp#70.1.1' with 'SimGraphI.cpp#71'.
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#71:cpp:4
	SimGraphI.cpp#70.1.1:cpp:4
Successors:
	SimGraphI.cpp#73:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#73 (cpp:4)
Owner:   tadmon
State:   sqa
Created: Sun May 31 09:51:24 2009
Task:    39678
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#72:cpp:4
Successors:
	SimGraphI.cpp#74:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#74 (cpp:4)
Owner:   tadmon
State:   sqa
Created: Wed Jun 03 14:25:27 2009
Task:    39744
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#73:cpp:4
Successors:
	SimGraphI.cpp#75:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#75 (cpp:4)
Owner:   yakovt
State:   sqa
Created: Mon Jun 08 11:24:05 2009
Task:    39821
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#74:cpp:4
Successors:
	SimGraphI.cpp#76:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#76 (cpp:4)
Owner:   yakovt
State:   sqa
Created: Mon Jun 08 16:32:38 2009
Task:    39793
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#75:cpp:4
Successors:
	SimGraphI.cpp#77:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#77 (cpp:4)
Owner:   yakovt
State:   sqa
Created: Sun Jun 21 14:53:47 2009
Task:    39990
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#76:cpp:4
Successors:
	SimGraphI.cpp#78:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#78 (cpp:4)
Owner:   yakovt
State:   sqa
Created: Mon Jun 22 16:08:46 2009
Task:    39993
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#77:cpp:4
Successors:
	SimGraphI.cpp#79:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#79 (cpp:4)
Owner:   yakovt
State:   sqa
Created: Thu Jun 25 17:31:16 2009
Task:    40021
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#78:cpp:4
Successors:
	SimGraphI.cpp#80:cpp:4
	SimGraphI.cpp#79.1.1:cpp:4
	SimGraphI.cpp#79.2.1:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#80 (cpp:4)
Owner:   tadmon
State:   sqa
Created: Mon Jun 29 15:03:32 2009
Task:    39986
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#79:cpp:4
Successors:
	SimGraphI.cpp#79.1.2:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#79.1.1 (cpp:4)
Owner:   yakovt
State:   sqa
Created: Tue Jun 30 19:24:22 2009
Task:    40107
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#79:cpp:4
Successors:
	SimGraphI.cpp#79.1.2:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#79.2.1 (cpp:4)
Owner:   barak
State:   sqa
Created: Thu Jul 02 18:09:30 2009
Task:    40085
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#79:cpp:4
Successors:
	SimGraphI.cpp#83:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#79.1.2 (cpp:4)
Owner:   tadmon
State:   sqa
Created: Mon Jul 06 14:37:41 2009
Task:    40177
Comment:
Merged 'SimGraphI.cpp#79.1.1' with 'SimGraphI.cpp#80'.
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#80:cpp:4
	SimGraphI.cpp#79.1.1:cpp:4
Successors:
	SimGraphI.cpp#79.1.3:cpp:4
	SimGraphI.cpp#79.1.2.1.1:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#79.1.3 (cpp:4)
Owner:   yakovt
State:   sqa
Created: Thu Jul 09 12:54:05 2009
Task:    40215
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#79.1.2:cpp:4
Successors:
	SimGraphI.cpp#79.1.4:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#79.1.2.1.1 (cpp:4)
Owner:   tadmon
State:   sqa
Created: Thu Jul 09 15:56:31 2009
Task:    40181
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#79.1.2:cpp:4
Successors:
	SimGraphI.cpp#79.1.2.1.2:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#79.1.4 (cpp:4)
Owner:   yakovt
State:   sqa
Created: Thu Jul 09 17:28:12 2009
Task:    40227
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#79.1.3:cpp:4
Successors:
	SimGraphI.cpp#79.1.5:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#79.1.5 (cpp:4)
Owner:   yakovt
State:   sqa
Created: Sun Jul 12 16:54:10 2009
Task:    40237
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#79.1.4:cpp:4
Successors:
	SimGraphI.cpp#79.1.6:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#79.1.6 (cpp:4)
Owner:   yakovt
State:   sqa
Created: Mon Jul 13 11:05:48 2009
Task:    40249
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#79.1.5:cpp:4
Successors:
	SimGraphI.cpp#82:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#81 (cpp:4)
Owner:   yakovt
State:   sqa
Created: Tue Jul 14 11:44:14 2009
Task:    40272
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#70.1.1:cpp:4
Successors:
	SimGraphI.cpp#82:cpp:4
	SimGraphI.cpp#81.1.1:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#82 (cpp:4)
Owner:   yakovt
State:   sqa
Created: Tue Jul 14 13:12:50 2009
Task:    40277
Comment:
Merged 'SimGraphI.cpp#81' with 'SimGraphI.cpp#79.1.6'.
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#79.1.6:cpp:4
	SimGraphI.cpp#81:cpp:4
Successors:
	SimGraphI.cpp#83:cpp:4
	SimGraphI.cpp#79.1.2.1.2:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#83 (cpp:4)
Owner:   barak
State:   sqa
Created: Sun Jul 19 13:25:25 2009
Task:    40265
Comment:
Merged 'SimGraphI.cpp#82' with 'SimGraphI.cpp#79.2.1'.
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#79.2.1:cpp:4
	SimGraphI.cpp#82:cpp:4
Successors:
	SimGraphI.cpp#84:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#79.1.2.1.2 (cpp:4)
Owner:   tadmon
State:   sqa
Created: Sun Jul 19 15:08:04 2009
Task:    40321
Comment:
Merged 'SimGraphI.cpp#79.1.2.1.1' with 'SimGraphI.cpp#82'.
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#79.1.2.1.1:cpp:4
	SimGraphI.cpp#82:cpp:4
Successors:
	SimGraphI.cpp#84:cpp:4
	SimGraphI.cpp#79.1.2.1.3:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#84 (cpp:4)
Owner:   barak
State:   sqa
Created: Sun Jul 19 18:30:22 2009
Task:    40265
Comment:
Merged 'SimGraphI.cpp#83' with 'SimGraphI.cpp#79.1.2.1.2'.
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#83:cpp:4
	SimGraphI.cpp#79.1.2.1.2:cpp:4
Successors:
	SimGraphI.cpp#85:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#79.1.2.1.3 (cpp:4)
Owner:   evgenir
State:   sqa
Created: Mon Jul 20 14:28:16 2009
Task:    40344
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#79.1.2.1.2:cpp:4
Successors:
	SimGraphI.cpp#85:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#85 (cpp:4)
Owner:   evgenir
State:   sqa
Created: Tue Jul 21 11:50:42 2009
Task:    40381
Comment:
Merged 'SimGraphI.cpp#79.1.2.1.3' with 'SimGraphI.cpp#84'.
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#84:cpp:4
	SimGraphI.cpp#79.1.2.1.3:cpp:4
Successors:
	SimGraphI.cpp#86:cpp:4
	SimGraphI.cpp#85.1.1:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#86 (cpp:4)
Owner:   barak
State:   sqa
Created: Fri Jul 24 23:05:56 2009
Task:    40469
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#85:cpp:4
Successors:
	SimGraphI.cpp#87:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#85.1.1 (cpp:4)
Owner:   tadmon
State:   sqa
Created: Sun Jul 26 11:24:07 2009
Task:    40333
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#85:cpp:4
Successors:
	SimGraphI.cpp#85.1.2:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#87 (cpp:4)
Owner:   evgenir
State:   sqa
Created: Wed Jul 29 12:14:17 2009
Task:    40584
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#86:cpp:4
Successors:
	SimGraphI.cpp#88:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#88 (cpp:4)
Owner:   yakovt
State:   sqa
Created: Wed Jul 29 15:23:09 2009
Task:    40595
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#87:cpp:4
Successors:
	SimGraphI.cpp#89:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#85.1.2 (cpp:4)
Owner:   tadmon
State:   sqa
Created: Mon Aug 03 11:37:30 2009
Task:    40596
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#85.1.1:cpp:4
Successors:
	SimGraphI.cpp#89:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#89 (cpp:4)
Owner:   tadmon
State:   sqa
Created: Mon Aug 03 12:34:06 2009
Task:    40635
Comment:
Merged 'SimGraphI.cpp#85.1.2' with 'SimGraphI.cpp#88'.
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#88:cpp:4
	SimGraphI.cpp#85.1.2:cpp:4
Successors:
	SimGraphI.cpp#90:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#81.1.1 (cpp:4)
Owner:   yakovt
State:   sqa
Created: Wed Aug 12 17:08:22 2009
Task:    41856
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#81:cpp:4
Successors:
	SimGraphI.cpp#92.1.1:cpp:4
	SimGraphI.cpp#81.1.2:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#90 (cpp:4)
Owner:   tadmon
State:   sqa
Created: Wed Aug 19 18:18:11 2009
Task:    40804
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#89:cpp:4
Successors:
	SimGraphI.cpp#91:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#91 (cpp:4)
Owner:   tadmon
State:   sqa
Created: Mon Sep 21 14:20:31 2009
Task:    41571
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#90:cpp:4
Successors:
	SimGraphI.cpp#92:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#92 (cpp:4)
Owner:   evgenir
State:   sqa
Created: Tue Oct 06 15:56:00 2009
Task:    41680
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#91:cpp:4
Successors:
	SimGraphI.cpp#93:cpp:4
	SimGraphI.cpp#92.1.1:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#93 (cpp:4)
Owner:   mgendelm
State:   sqa
Created: Wed Oct 21 21:38:29 2009
Task:    12802
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#92:cpp:4
Successors:
	SimGraphI.cpp#94:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#92.1.1 (cpp:4)
Owner:   yakovt
State:   sqa
Created: Thu Oct 22 17:30:37 2009
Task:    42084
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#81.1.1:cpp:4
	SimGraphI.cpp#92:cpp:4
Successors:
	SimGraphI.cpp#94:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#94 (cpp:4)
Owner:   yakovt
State:   sqa
Created: Thu Oct 22 18:32:28 2009
Task:    42097
Comment:
Merged 'SimGraphI.cpp#93' with 'SimGraphI.cpp#92.1.1'.
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#93:cpp:4
	SimGraphI.cpp#92.1.1:cpp:4
Successors:
	SimGraphI.cpp#95:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#81.1.2 (cpp:4)
Owner:   yturgman
State:   sqa
Created: Sun Nov 01 21:13:16 2009
Task:    42305
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#81.1.1:cpp:4
Successors:
	SimGraphI.cpp#95:cpp:4
	SimGraphI.cpp#81.1.3:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#95 (cpp:4)
Owner:   yturgman
State:   sqa
Created: Sun Nov 01 21:30:13 2009
Task:    42306
Comment:
Merged 'SimGraphI.cpp#94' with 'SimGraphI.cpp#81.1.2'.
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#94:cpp:4
	SimGraphI.cpp#81.1.2:cpp:4
Successors:
	SimGraphI.cpp#96:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#70.1.2 (cpp:4)
Owner:   yturgman
State:   sqa
Created: Thu Nov 05 14:22:37 2009
Task:    42420
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#70.1.1:cpp:4
Successors:
	SimGraphI.cpp#81.1.3:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#81.1.3 (cpp:4)
Owner:   yturgman
State:   sqa
Created: Thu Nov 05 21:12:55 2009
Task:    42443
Comment:
Merged 'SimGraphI.cpp#81.1.2' with 'SimGraphI.cpp#70.1.2'.
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#81.1.2:cpp:4
	SimGraphI.cpp#70.1.2:cpp:4
Successors:
	SimGraphI.cpp#96:cpp:4
	SimGraphI.cpp#81.1.4:cpp:4
	SimGraphI.cpp#81.1.3.1.1:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#96 (cpp:4)
Owner:   yturgman
State:   sqa
Created: Thu Nov 05 23:30:40 2009
Task:    42446
Comment:
Merged 'SimGraphI.cpp#95' with 'SimGraphI.cpp#81.1.3'.
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#95:cpp:4
	SimGraphI.cpp#81.1.3:cpp:4
Successors:
	SimGraphI.cpp#97:cpp:4
	SimGraphI.cpp#96.1.1:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#97 (cpp:4)
Owner:   shmelame
State:   sqa
Created: Wed Nov 18 13:44:24 2009
Task:    42726
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#96:cpp:4
Successors:
	SimGraphI.cpp#98:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#98 (cpp:4)
Owner:   mgendelm
State:   sqa
Created: Sun Nov 22 17:50:47 2009
Task:    42739
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#97:cpp:4
Successors:
	SimGraphI.cpp#99:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#96.1.1 (cpp:4)
Owner:   yakovt
State:   sqa
Created: Wed Nov 25 14:44:42 2009
Task:    42852
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#96:cpp:4
Successors:
	SimGraphI.cpp#99:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#99 (cpp:4)
Owner:   yakovt
State:   sqa
Created: Wed Nov 25 18:57:11 2009
Task:    42852
Comment:
Merged 'SimGraphI.cpp#98' with 'SimGraphI.cpp#96.1.1'.
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#98:cpp:4
	SimGraphI.cpp#96.1.1:cpp:4
Successors:
	SimGraphI.cpp#81.1.5:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#81.1.4 (cpp:4)
Owner:   barak
State:   integrate
Created: Mon Dec 07 13:08:06 2009
Task:    43501
Comment:

Predecessors:
	SimGraphI.cpp#81.1.3:cpp:4
Successors:
	SimGraphI.cpp#81.1.5:cpp:4
	SimGraphI.cpp#81.1.3.1.2:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#81.1.5 (cpp:4)
Owner:   tadmon
State:   sqa
Created: Tue Dec 08 18:26:23 2009
Task:    43595
Comment:
Merged 'SimGraphI.cpp#81.1.4' with 'SimGraphI.cpp#99'.
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#99:cpp:4
	SimGraphI.cpp#81.1.4:cpp:4
Successors:
	SimGraphI.cpp#81.1.6:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#81.1.3.1.1 (cpp:4)
Owner:   yakovt
State:   sqa
Created: Thu Dec 10 12:06:20 2009
Task:    43659
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#81.1.3:cpp:4
Successors:
	SimGraphI.cpp#81.1.3.1.2:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#81.1.3.1.2 (cpp:4)
Owner:   yakovt
State:   released
Created: Thu Dec 10 13:24:06 2009
Task:    43659
Comment:
Merged 'SimGraphI.cpp#81.1.3.1.1' with 'SimGraphI.cpp#81.1.4'.
changed to sqa state by GAP automatic approval

Predecessors:
	SimGraphI.cpp#81.1.4:cpp:4
	SimGraphI.cpp#81.1.3.1.1:cpp:4
Successors:
	SimGraphI.cpp#81.1.6:cpp:4
	SimGraphI.cpp#81.1.3.1.3:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#81.1.6 (cpp:4)
Owner:   yakovt
State:   sqa
Created: Thu Dec 10 13:40:24 2009
Task:    43681
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI.cpp#81.1.5:cpp:4
	SimGraphI.cpp#81.1.3.1.2:cpp:4
Successors:
	SimGraphI.cpp#81.1.7:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#81.1.3.1.3 (cpp:4)
Owner:   yakovt
State:   integrate
Created: Tue Dec 15 10:03:08 2009
Task:    43731
Comment:
<void>
Predecessors:
	SimGraphI.cpp#81.1.3.1.2:cpp:4
Successors:
	SimGraphI.cpp#81.1.7:cpp:4
*****************************************************************************
Object:  SimGraphI.cpp#81.1.7 (cpp:4)
Owner:   yakovt
State:   integrate
Created: Wed Dec 23 17:11:35 2009
Task:    43956
Comment:

Predecessors:
	SimGraphI.cpp#81.1.6:cpp:4
	SimGraphI.cpp#81.1.3.1.3:cpp:4
Successors:
*****************************************************************************

OUTPUT_END
Execute (c:\utils\ccm_task_diff.pl:157): EXECUTE_CMD: ccm finduse SimGraphI.cpp#81.1.7:cpp:4
Execute (c:\utils\ccm_task_diff.pl:157): OUTPUT_BEGIN
SimGraphI.cpp#81.1.7 integrate yakovt cpp EcsTopnew 4 43956
	ECSNT\ForecastService\SimGraphI.cpp#81.1.7@ECSNT#700yakovt-win:project:4
	ECSNT\ForecastService\SimGraphI.cpp#81.1.7@ECSNT#700_hani_win:project:4
	ECSNT\ForecastService\SimGraphI.cpp#81.1.7@ECSNT#bldrem_EM700_U_CI:project:4
	ECSNT\ForecastService\SimGraphI.cpp#81.1.7@ECSNT#bldrem_EM700_W_CI:project:4
	ECSNT\ForecastService\SimGraphI.cpp#81.1.7@ECSNT#galia700windows2:project:4

OUTPUT_END
Execute (c:\utils\ccm_task_diff.pl:174): EXECUTE_CMD: ccm cat SimGraphI.cpp#81.1.3.1.3:cpp:4
Execute (c:\utils\ccm_task_diff.pl:174): OUTPUT_BEGIN
/*
 *  Copyright (c) 2005
 *  BMC Software Inc.
 *
 *	file %name:	SimGraphI.cpp %
 *	%date_created:	Tue Dec 15 10:03:08 2009 %
 *	description:	
 *
 */

#ifndef lint 
static const char _SimGraphI_cpp_cpp[] = "@(#) %name: SimGraphI.cpp %, %cvtype: cpp %, %date_modified: %, %derived_by: yakovt %, %version: 81.1.3.1.3 %, %instance: 4 %, %compiled: "__DATE__", "__TIME__" %, %file_path: "__FILE__ " %(#)@";
#endif

#include "stdafx.h"
#include <Common/pragma_begin.h>

#include "tao/TAO_Export.h"
#include "tao/Sequence_T.h"
#include <ace/Method_Request.h>
#include <Common/pragma_end.h>
#include "forecastservice_export.h"
#include "Session.h"
#include "ForecastDAL/DALMgr.h"
#include "ForecastDAL/Definition.h"
#include "ForecastDAL/SimSystemState.h"
#include "BsmService/CrbConvert.h"
#include "DBJobPlanner.h"
#include "em_crb_foundations/ECSOrbCommon.h"
#include "DBJobSimulAdapter.h"
#include "DataCenterSimulAdapter.h"
#include "libfcengine/SimulatorFactory.h"
#include "libfcengine/DataCenterI.h"
#include "libfcengine/SimulJobI.h"
#include "libfcengine/SchedGroupI.h"
#include "libfcengine/InCondString.h"
#include "libfcengine/ConditionRuleI.h"
#include "em_foundations/ECSObjectWrappers.h"
//#include "SelectionDef/ECSSelectionDef.h"
#include "ForecastServiceI.h"
#include "em_db/ECSParams.h"			// db params table
#include "SimGraphI.h"
#include <em_foundations/EmException.h>
#include <em_foundations/EmHelper.h>
#include "ForecastDAL/WhatIf.h"
#include <ForecastService/ForecastParametersMgr.h>
#include <BsmService/PeriodicStatsAdapters.h>
#include "libfcengine/SimulJobI.h"
#include "libfcengine/BimSimulJobI.h"
#include "libfcengine/TraceAssumptionsMap.h"
#include <em_foundations/EmProfiler.h>
#include <BsmCommon/Helper.h>

#include <BsmCommon/DefJob.h>
#include <ForecastService/DefJobRepository.h>
#include <ForecastService/SenderToGui.h>
#include <ForecastService/SimGraphI_AddToSim.h>

DIAG_REGISTER_MODULE;


using namespace Forecast::DAL;

namespace	Forecast {
namespace	Service {

// helpers
namespace {

	class DefTableFields_TableIdLookup : public std::unary_function< const DefTableFields&, bool >
	{
	public:
		DefTableFields_TableIdLookup(int table_id) : m_table_id(table_id) 
		{
		}

		result_type operator()(argument_type a) const
		{
			return a.m_Table_ID == m_table_id;
		}

	private:
		int m_table_id;
	};

	class DCUDPairLookup : public std::unary_function< const std::pair< std::string, std::string >&, bool >
	{
	public:
		DCUDPairLookup(const std::string& dc, const std::string& ud) : m_dc(dc), m_ud(ud) {}
		result_type operator()(argument_type a) const
		{
			return a.first == m_dc && a.second == m_ud;
		}
	private:
		const std::string& m_dc;
		const std::string& m_ud;
	};

	class CountScope
	{
	public:
				CountScope(ACE_Atomic_Op<ACE_Thread_Mutex, long>& counter) : m_counter(counter) { 
					m_counter++; 
				}
		~CountScope() { m_counter--; }
	private:
		ACE_Atomic_Op<ACE_Thread_Mutex, long>&	m_counter;
	};

	inline size_t BooleanCount( const std::vector<bool>& vec, bool v )
	{
		//std::count is not supported on SUN and AIX
		//size_t n = std::count(jobdefsSend.begin(), jobdefsSend.end(), true);
		size_t n=0;
		for( std::vector< bool >::const_iterator it=vec.begin(), it_end=vec.end(); it!=it_end; ++it) 
		{
			if( *it == v ) ++n;
		}
		return n;
	}


} // unnamed namespace - helpers

/*static*/ const size_t SimGraphI::DEFAULT_CB_MAX_SEQ_SIZE = 25;

SimGraphI_SimRunner::SimGraphI_SimRunner(SimGraphI* sg)
	: m_sg(sg)
{
	// Construct
}

/*virtual*/ int SimGraphI_SimRunner::svc()
{
	DBG_FNC_ENTER("SimGraphI_SimRunner::svc");

	int rc = -1;
	if (m_sg != NULL)
	{
		try {
			rc = m_sg->RunSimulation();
		}
		catch( const EmAssertException& e)
		{
			DIAG_PDEF(DIAG_E, "EmAssertException Exception: " << e.what());
		}
		catch( const EmException& e)
		{
			DIAG_PDEF(DIAG_E, "EmException Exception: " << e.what());
		}
		catch( const std::exception& e)
		{
			DIAG_PDEF(DIAG_E, "std::exception: " << e.what());
		}
	}
	return rc;
}

/*static*/ ACE_Atomic_Op<ACE_Thread_Mutex, long> SimGraphI::m_gNextSimGraphId(1);
/*static*/ ACE_Atomic_Op<ACE_Thread_Mutex, long> SimGraphI::m_gTotalJobsInSimGraph(0);
/*static*/ ACE_Atomic_Op<ACE_Thread_Mutex, long> SimGraphI::m_gTotalRunSim(0);
		/*static*/ ACE_Atomic_Op<ACE_Thread_Mutex, long> SimGraphI::m_gMaxRunSim(0);
		/*static*/ ACE_Atomic_Op<ACE_Thread_Mutex, long> SimGraphI::m_gMaxTotalJobsInSimGraph(0);

SimGraphI::SimGraphI(PortableServer::POA_ptr poa, ForecastServiceI& fcService)
	: m_simRunner(this)
	, m_forecastService(fcService)
	, m_bimServiceMgr(m_simulator)
	, m_summary(this)
	, m_AdderToSim(m_simulator, m_params, m_bimServiceMgr, m_resourceId, m_LastReport, m_periodicStatsGetterImpl)
	, m_calendarCache( DALMgr::instance() )
{
	// Construct
	DBG_FNC_ENTER("SimGraphI::SimGraphI");
	ConstructResourceId();
	m_poa = PortableServer::POA::_duplicate(poa);
	m_graphStatus = Forecast::BUILD_STATUS_INIT;
	m_simStatus = Forecast::BUILD_STATUS_INIT;
	m_mySession = NULL;
	m_stopFlag = false;
	//m_cb = Forecast::SimGraphCB::_nil();
	m_simulator = NULL;
	m_nextOrderId = 1;
	m_bFilterDc = false;
	m_totalJobsInSimGraph = 0;

	ForecastParametersMgr* params_mgr = ForecastParametersMgr::Instance();
	params_mgr->LoadSystemParameters();
	m_params = params_mgr->GetParameters();
	// allocate simulator if needed
	if (m_simulator == NULL)
	{
		m_simulator = CSimulatorFactory::CreateSimulator( ); 
		if (m_simulator == NULL)
		{
			DIAG_PDEF(DIAG_E, "Failed to create simulation engine");
			SetGraphStatus(Forecast::BUILD_STATUS_ERROR);
		}
		m_bimServiceMgr.SetSimulator(m_simulator);
	}

	m_periodicStatsGetterImpl.SetParams(m_params.CollectStatByField);
}



/*virtual*/ SimGraphI::~SimGraphI()
{
	// Destruct - should be called because of 'Destroy'
	//		reference drop to zero, than delete this.
	//		we just make sure that all thread done
	DBG_FNC_ENTER("SimGraphI::~SimGraphI");
	WaitTillAllTasksComplete();
	DIAG_PDEF(DIAG_D,"After Wait");;

	// update total counter
	m_gTotalJobsInSimGraph -= m_totalJobsInSimGraph;

	// release simulator
	delete m_simulator;
	std::pair< size_t, size_t > size_count = bsm::GetTotalMemoryInUse();
	DIAG_P(DIAGC_BIM, DIAG_I, "Total allocated so far: " << size_count.first << " in " << size_count.second << " blocks " );

}

/*virtual*/ void SimGraphI::RunSim()
      ACE_THROW_SPEC ((
        CORBA::SystemException,
		Forecast::Simulator::RESOURCE_EXCEPTION
      ))
{
	// check out current status, run simulation
	DBG_FNC_ENTER("SimGraphI::RunSim");
	DIAG_P(DIAGC_TIME, DIAG_I, m_resourceId << " request to run simulation");

	CountScope runSimCount(m_gTotalRunSim);

	// check if worker thread already running
	if (m_simRunner.thr_count() > 0)
	{
		// thread already running simulation, nothing to do
		DIAG_PDEF(DIAG_E, m_resourceId << " simulation thread is already running");
		return ;
	}

	if (GetGraphStatus() != Forecast::BUILD_STATUS_COMPLETE)
	{
		// limit check - number of running simulations
		long currTotalRunSim = m_gTotalRunSim.value();
		if (m_params.MaxForecastRunningRequests >= 0 && currTotalRunSim >  m_params.MaxForecastRunningRequests)
		{
			DIAG_PDEF(DIAG_I, m_resourceId << " number of current RunSim (" 
				<< currTotalRunSim << ") exceeded the limit (" << m_params.MaxForecastRunningRequests << ")");
			Forecast::Simulator::RESOURCE_EXCEPTION ex;
			ex.Reason = CORBA::string_dup("Max running requests exceeded");
			throw ex;

		}
				if(currTotalRunSim > m_gMaxRunSim.value()){
					m_gMaxRunSim = currTotalRunSim;
				}

		// limit check - number of loaded jobs
		long currTotalJobsInSimGraph = m_gTotalJobsInSimGraph.value();

				if(currTotalJobsInSimGraph > m_gMaxTotalJobsInSimGraph.value()){
					m_gMaxTotalJobsInSimGraph = currTotalJobsInSimGraph;
				}

		if (m_params.MaxForecastJobsInMem >= 0 && currTotalJobsInSimGraph > m_params.MaxForecastJobsInMem)
		{
			DIAG_PDEF(DIAG_I, m_resourceId << " number of jobs in SimGraph (" 
				<< currTotalJobsInSimGraph << ") exceeded the limit (" << m_params.MaxForecastJobsInMem << ")");
			Forecast::Simulator::RESOURCE_EXCEPTION ex;
			ex.Reason = CORBA::string_dup("Max number of jobs in memory exceeded");
			throw ex;
		}
	}

	// create thread to execute SimGraph build
	m_stopFlag = false;

	int r = m_simRunner.activate();
	if (r != 0)
	{
		DIAG_PDEF(DIAG_E, "Fatal error - " << m_resourceId << " thread creation failed, rc=" << r);
		Forecast::Simulator::RESOURCE_EXCEPTION ex;
		ex.Reason = CORBA::string_dup("Simulation thread creation failed");
		throw ex;
	}
}

/*virtual*/ void SimGraphI::StopSim()
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ))
{
	// check current status, set stop flag
	DBG_FNC_ENTER("SimGraphI::StopSim");
	WaitTillAllTasksComplete();
}

/*virtual*/ Forecast::BuildStatusEnum SimGraphI::GetSimStatus()
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ))
{
	ACE_Guard< ACE_Thread_Mutex > guard(m_lock);
	return m_simStatus;
}

		void DumpAsInSecFrom(Forecast::JobSimInfo& SimJobInfo,unsigned int NumberOfExecTime,SimulJobI& Job,
			const TimeValue& From)
		{
			for(unsigned int t=0; t< NumberOfExecTime;++t)
			{
				(SimJobInfo.exec_info)[t].started=static_cast<Forecast::SimTime>(TimeValue::NO_TIME);
				(SimJobInfo.exec_info)[t].ended=static_cast<Forecast::SimTime>(TimeValue::NO_TIME);

				if(Job.GetStartedTimeIx(t).IsNeqNoTime())
				{
					(SimJobInfo.exec_info)[t].started=
						static_cast<Forecast::SimTime>(Job.GetStartedTimeIx(t).ToSecFrom(From));
				}
				if(Job.GetEndedTimeIx(t).IsNeqNoTime())
				{
					(SimJobInfo.exec_info)[t].ended=
						static_cast<Forecast::SimTime>(Job.GetEndedTimeIx(t).ToSecFrom(From));
				}
			}
		}

		void DumpAsTime_T(Forecast::JobSimInfo& SimJobInfo,unsigned int NumberOfExecTime,SimulJobI& Job)
		{
			for(unsigned int t=0; t< NumberOfExecTime;++t)
			{
				(SimJobInfo.exec_info)[t].started=static_cast<Forecast::SimTime>(TimeValue::NO_TIME);
				(SimJobInfo.exec_info)[t].ended=static_cast<Forecast::SimTime>(TimeValue::NO_TIME);

				if(Job.GetStartedTimeIx(t).IsNeqNoTime())
				{
					(SimJobInfo.exec_info)[t].started=
						static_cast<Forecast::SimTime>(Job.GetStartedTimeIx(t).ToTime_t());
				}
				if(Job.GetEndedTimeIx(t).IsNeqNoTime())
				{
					(SimJobInfo.exec_info)[t].ended=
						static_cast<Forecast::SimTime>(Job.GetEndedTimeIx(t).ToTime_t());
				}
			}
		}

		/*virtual*/ void SimGraphI::GetSimResultList(CORBA::Long how_many,
			Forecast::DataCenterSimInfoSeq_out siminfo_seq,
			Forecast::DataCenterJobsInfoIterator_out dcinfo_it)
			ACE_THROW_SPEC ((CORBA::SystemException))
		{
			GetSimulationResults(how_many,siminfo_seq,dcinfo_it,true);
		}

		/*virtual*/ void SimGraphI::GetSimResultList2(CORBA::Long how_many,
	Forecast::DataCenterSimInfoSeq_out siminfo_seq,
			Forecast::DataCenterJobsInfoIterator_out dcinfo_it)
			ACE_THROW_SPEC ((CORBA::SystemException))
		{
			GetSimulationResults(how_many,siminfo_seq,dcinfo_it,false);
		}



void SimGraphI::GetSimulationResults(CORBA::Long how_many,
	Forecast::DataCenterSimInfoSeq_out siminfo_seq,
	Forecast::DataCenterJobsInfoIterator_out dcinfo_it,
	bool ConvertTo24HoursInSec)
	ACE_THROW_SPEC ((CORBA::SystemException))
{
	// 
	DBG_FNC_ENTER("SimGraphI::GetSimResultList");
	siminfo_seq = new Forecast::DataCenterSimInfoSeq;
	dcinfo_it = Forecast::DataCenterJobsInfoIterator::_nil();

	Forecast::BuildStatusEnum simStat = SimGraphI::GetSimStatus();
	if (simStat != Forecast::BUILD_STATUS_COMPLETE)
	{
        DIAG_PDEF(DIAG_I, m_resourceId << " simulator didn't complete, return empty results");
		return;
	}

	AutoIter<DataCenterI>  DcIter=m_simulator->GetDataCenterIter();
	int TotalNumOfJobs(0);
	std::vector<DataCenterI*> DcVec;
	while(*DcIter!=NULL)
	{
		int DcNumOfJobs=(*DcIter)->GetNumOfJobs(true);
		if(DcNumOfJobs > 0)
		{
			DcVec.push_back(*DcIter);
		}
		TotalNumOfJobs+=DcNumOfJobs;
		++DcIter;
	}
	siminfo_seq->length(DcVec.size());

	if(DcVec.size()==0 || TotalNumOfJobs == 0)
	{
		//add debug log  - todo yoel
		return;
	}
	if(TotalNumOfJobs > how_many)
	{
		//TODO barak yoel - We need to init DataCenterJobsInfoIterator 
	}
	
	how_many=TotalNumOfJobs; //we will change it when we implemnt DataCenterJobsInfoIterator
	unsigned int i=0;
	int JobCounter=0;
	while(JobCounter < how_many && i < DcVec.size())
	{
		Forecast::DataCenterSimInfo& DcSimInfo= (*siminfo_seq)[i];
		DcSimInfo.datacenter = DcVec[i]->GetDataCenterName().c_str();
		DcSimInfo.job_siminfo_seq.length(DcVec[i]->GetNumOfJobs(true));
		DataCenterI::JobIterator& JobIter = DcVec[i]->GetJobIter();
		int j=0;
		while(JobCounter < how_many && (*JobIter) != NULL)
		{
			Forecast::JobSimInfo& SimJobInfo = (DcSimInfo.job_siminfo_seq)[j];
			SimulJobI& Job = (*(*JobIter));
			SimJobInfo.oid =  Job.GetOrderID();
			unsigned int NumberOfExecTime=Job.GetNumberOfExecTime();
			SimJobInfo.exec_info.length(NumberOfExecTime);
					if(ConvertTo24HoursInSec==true)
						DumpAsInSecFrom(SimJobInfo,NumberOfExecTime,Job,DcVec[i]->GetOdateMidnight());
					else
						DumpAsTime_T(SimJobInfo,NumberOfExecTime,Job);
			++JobCounter;
			++JobIter;
			++j;
		}
		delete &JobIter;
		++i;
	}
}

/*virtual*/ Forecast::BuildStatusEnum SimGraphI::GetGraphStatus()
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ))
{
	ACE_Guard< ACE_Thread_Mutex > guard(m_lock);
	return m_graphStatus;
}

/*virtual*/ void SimGraphI::BuildGraph()
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ))
{
	// TODO: in a thread context run only build graph
	DBG_FNC_ENTER("SimGraphI::BuildGraph");
	//CountScope runSimCount(m_gTotalRunSim);
	DIAG_P(DIAGC_TIME, DIAG_I, "Start: Build Graph " << m_resourceId);
	int rc = 0;
	try
	{
		SetSimStatus(Forecast::BUILD_STATUS_EXEC);
		m_SenderToGui.NotifyCBHelper("build graph begin", std::mem_fun<void, Forecast::SimGraphCB>(&Forecast::SimGraphCB::SimCB_Begin) );

		// nothing to build if graph status complete
		if (GetGraphStatus() != Forecast::BUILD_STATUS_COMPLETE)
		{
			int rc = RunBuildGraph(NULL);
		}
		
		SetSimStatus(Forecast::BUILD_STATUS_COMPLETE);
		m_SenderToGui.NotifyCBHelper("build graph end",	std::mem_fun<void, Forecast::SimGraphCB>(&Forecast::SimGraphCB::SimCB_End) );
	}
	catch(CORBA::SystemException& se)
	{
		DIAG_PDEF(DIAG_E, "Got system exception during simulation : " << se);
		m_stopFlag = true;
		rc = -1;
		SetSimStatus(Forecast::BUILD_STATUS_ERROR);
	}
	catch(std::exception& se)
	{
		DIAG_PDEF(DIAG_E, "Got an exception during simulation : " << se.what());
		m_stopFlag = true;
		rc = -1;
		SetSimStatus(Forecast::BUILD_STATUS_ERROR);
	}

	DIAG_P(DIAGC_TIME, DIAG_I, "End: Build Graph " << m_resourceId);
}

/*virtual*/ void SimGraphI::BuildGraphExt(Forecast::SingleJobExtInfoSeq_out job_seq)
ACE_THROW_SPEC ((
				CORBA::SystemException
				))
{
	// TODO: in a thread context run only build graph
	DBG_FNC_ENTER("SimGraphI::BuildGraph");
	//CountScope runSimCount(m_gTotalRunSim);
	DIAG_P(DIAGC_TIME, DIAG_I, "Start: Build Graph " << m_resourceId);
	int rc = 0;
	try
	{

		// it is called under Batch Discovery and read more data
		DefJobRepository::Instance()->SetExtMode(true);

		SetSimStatus(Forecast::BUILD_STATUS_EXEC);
		m_SenderToGui.NotifyCBHelper("build graph begin", std::mem_fun<void, Forecast::SimGraphCB>(&Forecast::SimGraphCB::SimCB_Begin) );

		// nothing to build if graph status complete
		if (GetGraphStatus() != Forecast::BUILD_STATUS_COMPLETE)
		{	
			job_seq   = new Forecast::SingleJobExtInfoSeq; 
			job_seq->length(0);
			int rc = RunBuildGraph(job_seq);
		}

		SetSimStatus(Forecast::BUILD_STATUS_COMPLETE);
		m_SenderToGui.NotifyCBHelper("build graph end", std::mem_fun<void, Forecast::SimGraphCB>(&Forecast::SimGraphCB::SimCB_End) );
			
		// update all the dependencies of the BIM services in the simulator.
		// needed by Batch Discovery - the only user of the BuildGraphExt method.
		m_simulator->UpdateAllBimServices();
			
	}
	catch(CORBA::SystemException& se)
	{
		DIAG_PDEF(DIAG_E, "Got system exception during simulation : " << se);
		m_stopFlag = true;
		rc = -1;
		SetSimStatus(Forecast::BUILD_STATUS_ERROR);
	}
	catch(std::exception& se)
	{
		DIAG_PDEF(DIAG_E, "Got an exception during simulation : " << se.what());
		m_stopFlag = true;
		rc = -1;
		SetSimStatus(Forecast::BUILD_STATUS_ERROR);
	}
	DIAG_P(DIAGC_TIME, DIAG_I, "End: Build Graph " << m_resourceId);
}


/*virtual*/ void SimGraphI::GetBimServiceList(Forecast::OrderIdSeq_out oid_seq)
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ))
{
	DBG_FNC_ENTER("SimGraphI::GetBimServiceList");
	oid_seq = new Forecast::OrderIdSeq;
	oid_seq->length(0);

	Forecast::BuildStatusEnum simStat = SimGraphI::GetSimStatus();
	if (simStat != Forecast::BUILD_STATUS_COMPLETE || m_simulator == NULL)
	{
        DIAG_PDEF(DIAG_I, m_resourceId << " simulator didn't complete, return empty list");
		return;
	}

	m_bimServiceMgr.GetBimServiceList(oid_seq);
}

/*virtual*/ void SimGraphI::GetBimServiceLateList(Forecast::OrderIdSeq_out oid_seq)
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ))
{
	// 
	DBG_FNC_ENTER("SimGraphI::GetBimServiceLateList");
	oid_seq = new Forecast::OrderIdSeq;
	oid_seq->length(0);

	Forecast::BuildStatusEnum simStat = SimGraphI::GetSimStatus();
	if (simStat != Forecast::BUILD_STATUS_COMPLETE || m_simulator == NULL)
	{
        DIAG_PDEF(DIAG_I, m_resourceId << " simulator didn't complete, return empty list");
		return;
	}

	m_bimServiceMgr.GetBimServiceLateList(oid_seq);
}

void SimGraphI::GetJobByOid(Forecast::OrderId orderid, 	Forecast::SingleJobInfo_out   corbajob)
ACE_THROW_SPEC ((
				CORBA::SystemException
				))
{
	DBG_FNC_ENTER("SimGraphI::GetJobByOid");
	// SimGraph status validation checks
	Forecast::BuildStatusEnum graphStat = SimGraphI::GetGraphStatus();
	if (graphStat != Forecast::BUILD_STATUS_COMPLETE)
	{
		DIAG_PDEF(DIAG_I, m_resourceId << " no complete graph, fail to get job dependency list");
		// TODO: throw an exception - graph build didn't complete
	}

	if (m_simulator == NULL)
	{
		DIAG_PDEF(DIAG_E, m_resourceId << " no simulator, probably a bug");
		return;
	}

	SimulJobI * simjob =  m_simulator->GetJobByOid(orderid);
	
	corbajob = new  Forecast::SingleJobInfo();

	corbajob->Name = simjob->GetJobName().c_str();
	corbajob->Node = simjob->GetNode().c_str();
	return;
}

/*virtual*/ void SimGraphI::GetDepJobList(
	const char							*dep_type,
	Forecast::OrderId					oid,
	Forecast::OrderIdSeq_out			oid_seq)
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ))
{
	// 
	DBG_FNC_ENTER("SimGraphI::GetDepJobList");

	oid_seq = new Forecast::OrderIdSeq;
	oid_seq->length(0);

	// SimGraph status validation checks
	Forecast::BuildStatusEnum graphStat = SimGraphI::GetGraphStatus();
	if (graphStat != Forecast::BUILD_STATUS_COMPLETE)
	{
        DIAG_PDEF(DIAG_I, m_resourceId << " no complete graph, fail to get job dependency list");
		// TODO: throw an exception - graph build didn't complete
	}

	if (m_simulator == NULL)
	{
        DIAG_PDEF(DIAG_E, m_resourceId << " no simulator, probably a bug");
		return;
	}

	// generate list of depended jobs, by type of 
	if (strcmp(dep_type, "bim") == 0)
	{
		m_bimServiceMgr.GenBimIndicatorJobList(BimServiceMgr::en_IndicatorBim, oid, oid_seq);
	}
	else if (strcmp(dep_type, "bim_crit_min") == 0)
	{
		m_bimServiceMgr.GenBimIndicatorJobList(BimServiceMgr::en_IndicatorCritMin, oid, oid_seq);
	}
	else if (strcmp(dep_type, "bim_crit_all") == 0)
	{
		m_bimServiceMgr.GenBimIndicatorJobList(BimServiceMgr::en_IndicatorCritAll, oid, oid_seq);
	}
	else
	{
		DIAG_PDEF(DIAG_E, "unknown dependency check type '" << dep_type <<"'");
		// TODO: unknown dependency check, throw exception
	}
}

/*virtual*/ char *SimGraphI::GetResourceId()
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ))
{
	// 
	CORBA::String_var resId = CORBA::string_dup( m_resourceId.c_str() );
	return resId._retn();
}

//////////////////////////////////////////////////////////////////////////
// deactivate object and remove last reference
//
/*virtual*/ void SimGraphI::Destroy()
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ))
{
	DBG_FNC_ENTER("SimGraphI::Destroy");

	m_SenderToGui.Cancel();
	m_AdderToSim.Cancel();
	m_stopFlag = true;

	try
	{
		EM_ASSERT( !CORBA::is_nil(m_poa), "Doesn't have POA, must be a bug" );

		m_mySession->UnregisterAndDestroy(this, m_poa);
	}
	catch( const std::exception& e)
	{
		DIAG_PDEF(DIAG_E, "Error: " << e.what());
	}

}

//////////////////////////////////////////////////////////////////////////
//
/*virtual*/ void SimGraphI::SetSimGraphCallback(Forecast::SimGraphCB_ptr cb)
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ))
{
	ACE_Guard< ACE_Thread_Mutex > guard(m_lock);
	m_SenderToGui.SetSimGraphCallback(cb);
	m_SenderToGui.Open();
}

/*virtual*/ char * SimGraphI::GetGraphInfo (const char * attr)
ACE_THROW_SPEC ((CORBA::SystemException))
{
	DBG_FNC_ENTER("SimGraphI::GetGraphInfo ");

	ACE_Guard< ACE_Thread_Mutex > guard(m_lock);

	if (strcmp(attr,"Job Definition Size") == 0)
	{
		int nJobDefSize = GetJobDefinitionSize();

		char szJobDefSize[30];
		szJobDefSize[0] = NULL;
		ACE_OS::itoa(nJobDefSize,szJobDefSize, 10);

		CORBA::String_var sTmp = CORBA::string_dup(szJobDefSize);

		return sTmp._retn();
	}
	else if (strcmp(attr,"Summary") == 0)
	{
		std::string out;
		m_summary.Caclulate();
		m_summary.WriteToXml(out);

		if (IS_PRINTABLE_DIAG_PDEF(DIAG_I))
		{
			DIAG_PDEF(DIAG_I, "Summary:\n");

			std::ostringstream str;
			m_summary.Print(str);
			TDiag *pTheDiag = TDiag::Instance(); 
			pTheDiag->PrintDirectly(str.str().c_str());
			pTheDiag->flush(); 
		}


		CORBA::String_var sTmp = CORBA::string_dup(out.c_str());
		return sTmp._retn();
	}
	else
	{
		{
			CORBA::String_var sTmp = CORBA::string_dup("Not Implemented");	
			return sTmp;
		}
	}
}



/*virtual*/ Forecast::SimGraphCB_ptr SimGraphI::GetSimGraphCallback()
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ))
{
	ACE_Guard< ACE_Thread_Mutex > guard(m_lock);
	//return Forecast::SimGraphCB::_duplicate(m_cb);
	return m_SenderToGui.GetSimGraphCallback();
}


//New---Graph
void SimGraphI::GetValuesList (
									   const char * entityName,
									   const char * filter,
									   ::stringSeq_out values,
									   ::CORBA::Long maxValues,
									   ::CORBA::Long_out existValues
									   )
									   ACE_THROW_SPEC ((
									   CORBA::SystemException,
									   ::Forecast::SCENARIO_EXCEPTION
									   ))
{
	DBG_FNC_ENTER("SimGraphI::GetValuesList");
	DIAG_P(DIAGC_CORBA_INCOMING, DIAG_D, "entityName: " << entityName << " filter: " << filter);
	
	//out:
	values = new stringSeq;
	existValues = 0;

	std::vector<std::string> names;
	GetValuesList(entityName, names);

	existValues = names.size();
	if( maxValues >0 && (size_t)maxValues < names.size() )
	{
		names.resize(maxValues);
	}
	StlVector2CorbaSequence(names, *values);

}

//New---Simulate

//////////////////////////////////////////////////////////////////////////
//
void SimGraphI::SetScenario (
	const char * data
	)
	ACE_THROW_SPEC ((
	CORBA::SystemException,
	::Forecast::SCENARIO_EXCEPTION
	))
{
	DBG_FNC_ENTER("SimGraphI::SetScenario");
	DIAG_P(DIAGC_CORBA_INCOMING, DIAG_D, "data: " << "");

	std::string XMLData=data;
	if(XMLData.empty()==true)
	{
		throw Forecast::SCENARIO_EXCEPTION(en_SCENARIO_EXCEPTION_Error,"Scenario XML is empty");
	}

	if(XMLData.size() > (size_t)m_params.ScenarioMaxSize*1024) //in KB
	{
		throw Forecast::SCENARIO_EXCEPTION(en_SCENARIO_EXCEPTION_ScenarioMaxSize,"Scenario data size is more then 'ScenarioMaxSize' system parameter");
	}

	if (SimGraphI::GetGraphStatus() != Forecast::BUILD_STATUS_COMPLETE)
	{
		m_ScenarioXMLStr=XMLData;
		DIAG_PDEF(DIAG_I,"Forecast graph is not build/ready, only saving Scenario XML String");
		return;
	}
	//else
	try{
		LoadScenarioToGraph(XMLData);
	}
	catch(Forecast::Common::WhatIfValidationException& refEx)
	{
		LoadScenarioToGraph(m_ScenarioXMLStr);
		if(SimGraphI::GetSimStatus() == Forecast::BUILD_STATUS_COMPLETE)
			m_simulator->RunSimulation();
		throw Forecast::SCENARIO_EXCEPTION(en_SCENARIO_EXCEPTION_Error,refEx.what());
	}
	catch (Forecast::Common::FcException& refEx)
	{
		std::string err = "Not valid Scenario XML: "+std::string(refEx.what());
		throw Forecast::SCENARIO_EXCEPTION(en_SCENARIO_EXCEPTION_Error,err.c_str());
	}
	catch(std::exception& e)
	{
		throw Forecast::SCENARIO_EXCEPTION(en_SCENARIO_EXCEPTION_Error,e.what());
	}

}

void SimGraphI::LoadSystemScenario()
{
	try
	{
		Forecast::DAL::WhatIf wf(DALMgr::instance());
		RWCString scenarioData;
		wf.ReadSystemScenario(scenarioData);
		Forecast::Common::Scenario_type Scenario;
		Scenario.LoadFromXml(scenarioData.std());
		std::vector<Forecast::Common::RuleBase_type*> RuleVec;
		Scenario.GetRules(RuleVec);
		Scenario.SetRuleOwner(false);
		m_simulator->SetSystemScenario(RuleVec);
	}
	catch(Forecast::Common::WhatIfValidationException& refEx)
	{
		ThrowFatalError("build graph", 1, "Failed to read <SYSTEM> scenario, " + em::tos(refEx.what()));
	}
}

void SimGraphI::LoadScenarioToGraph(const std::string& ScenarioXMLStr)
{
	DBG_FNC_ENTER("SimGraphI::SetScenario");
	
	Forecast::Common::Scenario_type Scenario;
	Scenario.LoadFromXml(ScenarioXMLStr);
	std::vector<Forecast::Common::RuleBase_type*> RuleVec;
	Scenario.GetRules(RuleVec);
	m_simulator->SetScenario(RuleVec);
	Scenario.SetRuleOwner(false);
	m_ScenarioXMLStr=ScenarioXMLStr;
}

//////////////////////////////////////////////////////////////////////////
//
void SimGraphI::GetScenario (
	CORBA::String_out data
	)
	ACE_THROW_SPEC ((
	CORBA::SystemException,
	::Forecast::SCENARIO_EXCEPTION
	))
{
	DBG_FNC_ENTER("SimGraphI::GetScenario");

	std::string s_data;
	Forecast::Common::Scenario_type Scenario;
	Scenario.SetRuleOwner(false);
	std::vector<Forecast::Common::RuleBase_type*> RuleVec;
	m_simulator->GetScenario(RuleVec);
	Scenario.SetRules(RuleVec);
	Scenario.WriteToXml(s_data);
	data = CORBA::string_dup(s_data.c_str());

	DIAG_P(DIAGC_CORBA_INCOMING, DIAG_D, "data: " << data);
}

//////////////////////////////////////////////////////////////////////////
//
void SimGraphI::CRB_GetAllServicesInformation (
	::ECSCorbaAttrHolderSeq_out servicesList
	)
	ACE_THROW_SPEC ((
	CORBA::SystemException,
	::Forecast::GENERAL_EXCEPTION
	))
{
	DBG_FNC_ENTER("SimGraphI::CRB_GetAllServicesInformation ");
	DIAG_P(DIAGC_CORBA_INCOMING, DIAG_D, "()" );

	servicesList = new ::ECSCorbaAttrHolderSeq;

	Forecast::BuildStatusEnum simStat = SimGraphI::GetSimStatus();
	if (simStat != Forecast::BUILD_STATUS_COMPLETE || m_simulator == NULL)
	{
		DIAG_PDEF(DIAG_I, m_resourceId << " simulator didn't complete, return empty list");
		return;
	}

	m_bimServiceMgr.GetAllServicesInformation(servicesList);
}


//virtual
void SimGraphI::CRB_UpdateFilter (
					   const char * plan_filter,
					   const char * display_filter
					   )
					   ACE_THROW_SPEC ((
					   CORBA::SystemException,
					   ::Forecast::GENERAL_EXCEPTION
					   ))
{
	DBG_FNC_ENTER("SimGraphI::CRB_UpdateFilter ");
	DIAG_P(DIAGC_CORBA_INCOMING, DIAG_D, "()" );

	try
	{
		EM_ASSERT(m_SenderToGui.IsOpen(), "Sender is not open during update filter");

		SetSimStatus(Forecast::BUILD_STATUS_EXEC);
		m_SenderToGui.NotifyCBHelper("build graph begin", std::mem_fun<void, Forecast::SimGraphCB>(&Forecast::SimGraphCB::SimCB_Begin) );

		//set new filter
		SetPlanFilterStr(plan_filter);
		SetDisplayFilterStr(display_filter);

		//Filter flags
		bool bDcMatch = true;
		bool bTblMatch = true;
		bool bUDMatch = true;

		//* traverse through all jobs in simulator
		for( AutoIter<DataCenterI>  dc_iter = m_simulator->GetDataCenterIter(); dc_iter.HasMore(); ++dc_iter )
		{
			DataCenterI* dc = *dc_iter;
			const std::string& dc_name = dc->GetDataCenterName();
		
			bDcMatch = m_Matcher.DatacenterDoesItMatch(dc_name);

			int totalJobSent =0;

			const bsm::DefTableInfos& defTables = DefJobRepository::Instance()->GetDefTables();
			for( bsm::DefTableInfos::const_iterator tbl_it = defTables.begin(), tbl_it_end = defTables.end(); 
				tbl_it != tbl_it_end; ++tbl_it)
			{
				const bsm::DefTableInfo& defTableInfo = *tbl_it;
				const std::string& table_name = defTableInfo.m_SchedTable;
				const std::string& table_lib = defTableInfo.m_DSN;
				const std::string& table_dc_name = defTableInfo.m_DataCenter;
				if( table_dc_name != dc_name )
					continue;

				bTblMatch = m_Matcher.IsTableAuthorized(defTableInfo, BROWSE_ACCESS);

				// get iterator for all simulation job belonging to the table
				AutoIter<SimulJobI> job_it = dc->GetSimulJobsItersByTableNameAndLib(table_name, table_lib);
				if( !job_it.IsValid() )
				{
					continue; //the table is not found in simulator, probably it is new table.
				}

				// traverse through all table's job to find corresponding db-job 
				std::vector< bool > jobdefsSend( job_it.Size(), false );
				std::vector< size_t > joboidSend( job_it.Size(), 0 );
				bsm::DefJobVec jobdefs( job_it.Size(), NULL ); //will be formed due existed simulation job

				bool isMemberSigned = false;
				int grp_pos = 0;
				SimulJobI* grp_job = NULL;
				for( int i=0; job_it.HasMore(); ++job_it, ++i)
				{
					SimulJobI* sim_job = *job_it;

					//* get DefJob from Repository by table_id and job_id
					int table_id	= defTableInfo.m_Table_ID;
					int job_id		= sim_job->GetJobId();
					bsm::DefJob* dbjob = DefJobRepository::Instance()->GetDefJobsByTableAndJobId(table_id, job_id);
					if( dbjob == NULL)
					{
						// db-job is not found in repository, probably definition were changed
						DIAG_PDEF(DIAG_I, "Def job is not found by table_id: " << table_id  << " and job_id: " << em::tos(job_id) );
						continue; 
					}

					jobdefs[i] = dbjob;
					joboidSend[i] = sim_job->GetOrderID();

					bTblMatch = m_Matcher.TableDoesItMatch(defTableInfo.m_SchedTable);
					bUDMatch = m_Matcher.UserDailyDoesItMatch(defTableInfo.m_User_Daily);
					bool bTableAuthorized = m_Matcher.IsTableAuthorized(defTableInfo, BROWSE_ACCESS);

					// filter job
					bool bPassedFilter = bTableAuthorized 
						&& bDcMatch 
						&& bTblMatch 
						&& m_Matcher.DisplayDoesItFit(*dbjob)
						;

					DIAG_PDEF( DIAG_D, "job " << dbjob->GetName() << " is passed filter: " << bPassedFilter );

					//* set new Signed value for simulation job
					sim_job->SetSigned(bPassedFilter);
					jobdefsSend[i] = bPassedFilter;

					if( bPassedFilter )
						isMemberSigned = true;

					//store the group job position to swap it to first place
					if( dynamic_cast< SchedGroupI*>(sim_job) != NULL )
					{
						grp_job = const_cast<SimulJobI*>(sim_job);
						grp_pos = i;
					}

				} //end for tables's job

				if( grp_pos != 0 )
				{
					std::swap( jobdefs[0], jobdefs[grp_pos]);
					std::swap( joboidSend[0], joboidSend[grp_pos]);
					//std::swap( jobdefsSend[0], jobdefsSend[grp_pos]); //std::swap cannot work with std::vector<bool>
					bool tmp = jobdefsSend[0]; jobdefsSend[0] = jobdefsSend[grp_pos]; jobdefsSend[grp_pos] = tmp;
				}

				//force signing the parent group in case if one of its member is signed
				if( isMemberSigned && grp_job != NULL)
				{
					grp_job->SetSigned( true );
					jobdefsSend[0] = true; //the group is first job in the table
				}

				int n = BooleanCount( jobdefsSend, true );
				totalJobSent += n;
				if( n > 0 )
				{
					m_SenderToGui.AddDefJobs(defTableInfo, jobdefs, jobdefsSend, joboidSend, n, 
						m_GlobalCondSearcher, dc_name);
				}

			} //end for tables

			DIAG_PDEF( DIAG_D, "new number of signed jobs for DC: " << dc_name << " = " << totalJobSent );
			dc->SetNumOfSignedJobs(totalJobSent);
		
		} //end for dc


		//* send end message 
		m_SenderToGui.NotifyCBHelper("build graph end",	std::mem_fun<void, Forecast::SimGraphCB>(&Forecast::SimGraphCB::SimCB_End) );
		m_SenderToGui.NotifyCBHelper("simulation begin", std::mem_fun<void, Forecast::SimGraphCB>(&Forecast::SimGraphCB::SimCB_Begin) );
		//dummy calculation, but we need update services because signing
		m_bimServiceMgr.Calculate();
		m_SenderToGui.NotifyCBHelper("simulation end", std::mem_fun<void, Forecast::SimGraphCB>(&Forecast::SimGraphCB::SimCB_End) );

		SetSimStatus(Forecast::BUILD_STATUS_COMPLETE);
	}
	catch (const std::exception& e)
	{
		std::string errMsg = "exception during filter update: " +  em::tos(e.what());
		DIAG_PDEF(DIAG_E, errMsg);
		m_SenderToGui.NotifyCBErrorMessage("update filter", 1, errMsg.c_str(), true); //true is fatal error

		throw Forecast::GENERAL_EXCEPTION( errMsg.c_str() );
	}

}


//////////////////////////////////////////////////////////////////////////
//
void SimGraphI::GetSimParameters (
	CORBA::String_out crb_xml
	)
	ACE_THROW_SPEC ((
	CORBA::SystemException
	))
{
	DBG_FNC_ENTER("SimGraphI::GetSimParameters");

	ACE_Guard< ACE_Thread_Mutex > guard(m_lock);

	DIAG_P(DIAGC_CORBA_INCOMING, DIAG_D, "()" );

	std::string str_xml;

	try {
		str_xml = m_params.ToXml();
	}
	catch( const EmException& e)
	{
		DIAG_PDEF(DIAG_E, "Error parameters get: " << e.what());
	}

	CRB::Convert(str_xml,crb_xml);
}

//////////////////////////////////////////////////////////////////////////
//
void SimGraphI::SetSimParameters (
						const char* xml
						)
						ACE_THROW_SPEC ((
						CORBA::SystemException
						))
{

	DBG_FNC_ENTER("SimGraphI::SetSimParameters");

	ACE_Guard< ACE_Thread_Mutex > guard(m_lock);

	DIAG_P(DIAGC_CORBA_INCOMING, DIAG_D, "()" );

	try 
	{
		m_params.LoadFromXml(xml);
		static char *IGNORE_GC = getenv("IGNORE_GC");

		// enable dc filter (perform forecast on selected DC only)
		if (m_params.IgnoreGlobalConditions || IGNORE_GC)
			m_bFilterDc = true;

		// it has to be called before build graph!!!
		DefJobRepository::Instance()->SetConfiguration(m_params); 
	}
	catch( const EmException& e)
	{
		DIAG_PDEF(DIAG_E, "Error parameters set: " << e.what());
	}
}


//------





const std::string& SimGraphI::GetPlanOrderDateStr() const
{
	return m_planOrderDateStr;
}

void SimGraphI::SetPlanOrderDateStr(const std::string& odate)
{
	m_planOrderDateStr = odate;
	m_simulator->SetPlanOrderDateStr(odate);
}

void SimGraphI::SetPlanFilterStr(const std::string& filt)
{
	m_Matcher.SetPlanFilterStr(filt);
}


void SimGraphI::SetDisplayFilterStr(const std::string& filt)
{
	m_Matcher.SetDisplayFilterStr(filt);
}

int SimGraphI::WaitTillAllTasksComplete()
{
	m_stopFlag = true;
	m_simRunner.wait();
	m_SenderToGui.CloseAndWait(); //send end marker and wait to completion, after this is's impossible to send message to GUI
	return 0;
}

void SimGraphI::SetGraphStatus(Forecast::BuildStatusEnum e)
{
	ACE_Guard< ACE_Thread_Mutex > guard(m_lock);
	m_graphStatus = e;
}

void SimGraphI::SetSimStatus(Forecast::BuildStatusEnum e)
{
	ACE_Guard< ACE_Thread_Mutex > guard(m_lock);
	m_simStatus = e;
}

/*virtual*/ int SimGraphI::RunSimulation()
{
	// 
    DBG_FNC_ENTER("SimGraphI::RunSimulation");
	EM_PROFILER_FUNC;

	bsm::MemoryWatcher memoryWatcher;
	memoryWatcher.Start();

	CountScope runSimCount(m_gTotalRunSim);
	DIAG_P(DIAGC_TIME, DIAG_I, "Start: RunSimulation " << m_resourceId);
	
	int rc = -1; //will be 0 in case success
	
	std::string  exceptionMsg = ""; //no error by default
	try
	{
		SetSimStatus(Forecast::BUILD_STATUS_EXEC);
		m_SenderToGui.NotifyCBHelper("simulation begin", std::mem_fun<void, Forecast::SimGraphCB>(&Forecast::SimGraphCB::SimCB_Begin) );

		// nothing to build if graph status complete
		if (GetGraphStatus() != Forecast::BUILD_STATUS_COMPLETE)
		{
			RunBuildGraph(NULL);
		}

		m_simulator->RunSimulation();

		SetSimStatus(Forecast::BUILD_STATUS_COMPLETE);

		m_bimServiceMgr.Calculate();

		m_SenderToGui.NotifyCBHelper("simulation end", std::mem_fun<void, Forecast::SimGraphCB>(&Forecast::SimGraphCB::SimCB_End) );

		rc = 0;
	}
	catch(CORBA::SystemException& se)
	{
		exceptionMsg = "Got CORBA system exception during simulation : " + em::tos(se);
	}
	catch( const Forecast::Common::FcException& e)
	{
		exceptionMsg = "Got Forecast exception: " + em::tos(e.what());
		m_SenderToGui.NotifyCBErrorMessage("Run Simulation", 1, exceptionMsg, true);
	}
	catch( const FatalError&  e)
	{
		exceptionMsg = "Got FatalError: " + em::tos(e.what());
		//do nothing -- error handling was in ThrowFatalError
	}
	catch( const EmException& e )
	{
		exceptionMsg = "Got EM exception: " + em::tos(e.what());
		m_SenderToGui.NotifyCBErrorMessage("Run Simulation", 1, exceptionMsg, true);
	}

	if( rc != 0 )
	{
		DIAG_PDEF( DIAG_W, exceptionMsg );
		m_stopFlag = true;
		SetSimStatus(Forecast::BUILD_STATUS_ERROR);
	}
	DIAG_P(DIAGC_TIME, DIAG_I, "End: RunSimulation " << m_resourceId);

	EM_PROFILER_FUNC_STOP; //to include this function in the latest report as well
	em::ProfilerMgr::Instance()->Reset();

	memoryWatcher.Stop();
	DIAG_P(DIAGC_BIM, DIAG_I, "SimAllocated: " << memoryWatcher.GetSize() << " in " << memoryWatcher.GetCount() << " blocks " )
	
	std::pair< size_t, size_t > size_count = bsm::GetTotalMemoryInUse();
	DIAG_P(DIAGC_BIM, DIAG_I, "Total allocated so far: " << size_count.first << " in " << size_count.second << " blocks " );
	
	return rc;
}


int SimGraphI::RunBuildGraph(Forecast::SingleJobExtInfoSeq * extjob_seq)
{
	// 
	DBG_FNC_ENTER("SimGraphI::RunBuildGraph");
	EM_PROFILER_FUNC;
	EM_PROFILER_MANUAL(P_BuildGraph);
	EM_PROFILER_MANUAL(P_Plan);
	EM_PROFILER_MANUAL(P_AddToSimulator);
	EM_PROFILER_MANUAL(P_DataLoad);
	EM_PROFILER_MANUAL(P_SendToGUI);
	EM_PROFILER_MANUAL(P_LoadStatFromDb);

	EM_ASSERT (m_simulator != NULL, "simulation engine doesn't exist");

	DIAG_P(DIAGC_TIME, DIAG_I, "Start: BuildGraph" << m_resourceId);

	EM_PROFILER_MANUAL_START(P_BuildGraph);

	SetGraphStatus(Forecast::BUILD_STATUS_EXEC);
	m_SenderToGui.NotifyCBHelper("graph begin", std::mem_fun<void, Forecast::SimGraphCB>(&Forecast::SimGraphCB::GraphCB_Begin));

	//T: Explicitly disable assumptions
	TraceAssumptionsMap::Instance()->SetTrace(false);
	
	m_LastReport.Init();

	//
	// update the def repository, lock it for read and check if there are no any errors
	//
	DefJobRepository::Instance()->Update(); 
	DefJobRepositoryAutoReadLocker aDefJobRepositoryAutoReadLocker; //lock our repository for read until end of function
	if( DefJobRepository::Instance()->IsError() )
	{
		ThrowFatalError("Read jobs", 1, "error during job definitions read");
	}

	//
	//start a separate thread to add new jobs to the simulator.
	// it will be close near end of this function
	//
	m_AdderToSim.Open(); 

	// Progress time indicator
	time_t progressUpdateTime = time(0); 

	// reference the DataAccessLayer and allocate database connection for the next db access
	Definition defDal(DALMgr::instance());
	RWDBConnection conn = DALMgr::instance()->GetConnection();

	const bsm::DefTableInfos& defTables = DefJobRepository::Instance()->GetDefTables();

	ReadCalendarInformation();

	// read system state information
	DIAG_PDEF(DIAG_D, m_resourceId << ": read system state information");
	Forecast::DAL::SimSystemState simSystemState( DALMgr::instance() );

	Forecast::DAL::SimSystemState::DataCenterMap dataCenterMap;
	if(extjob_seq){
		//For Batch Discovery
		simSystemState.ReadAllDataCenters(dataCenterMap, &conn);
	}
	else{
		simSystemState.ReadFullDataCenterInfo(dataCenterMap, &conn);
	}

	m_LastReport.m_MaxRunSims = m_gMaxRunSim.value();
	m_LastReport.m_MaxTotalJobsInSimGraph = m_gMaxTotalJobsInSimGraph.value();

	m_simulator->SetPeriodicStatsGetter(&m_periodicStatsGetterImpl);
	m_simulator->SetSimulStep(m_params.SimulatorEngineStep);
	m_simulator->SetNumberOfDaysToSimulate(m_params.MaxSimulationDays);
	m_simulator->SetNumberOfSimulationThreads(m_params.MaxNumDetectThreads);

	const Definition::CommDomVec& commVec = DefJobRepository::Instance()->GetDataCenters();

	FillEngineWithDatacenterInformation(commVec);

	LoadQuantitativeResources(defDal, commVec);

	SetupGlobalConditionPrefixSearcher(defDal, commVec);

	// set dbjob planner
	DBJobPlanner planner;
	planner.SetCalendarDefCached(&m_calendarCache);

	DataCenterUserDailyVec dy_user_daily_to_process;
	DataCenterUserDailyVec dy_user_daily_processed;

	// table progress counters
	int progressMaxPos = 0;
	int progressCurPos = 0;

	// job processing & display counters
	m_totalJobsInSimGraph = 0;
	unsigned int totalJobSent = 0;
	long totalJobsProcessed = 0;

	//Filter flags
	bool bDcMatch = true;
	bool bTblMatch = true;
	bool bUDMatch = true;

	do 
	{
		// clear the list of dynamic user daily, we fill it up while processing jobs
		dy_user_daily_to_process.clear();

		// count number of tables we will process
		progressMaxPos += CountNumberOfTablesToProcess(dataCenterMap);
		m_SenderToGui.UpdateCBWithProgress("planning", progressUpdateTime, progressCurPos, progressMaxPos, true);

		// for-each datacenter
		for (Forecast::DAL::SimSystemState::DataCenterMap::iterator dcIt = dataCenterMap.begin()
			; dcIt != dataCenterMap.end() && !m_stopFlag
			; ++dcIt)
		{
			const std::string& data_center = (*dcIt).first;

			bDcMatch = m_Matcher.DatacenterDoesItMatch(data_center);

			if(m_bFilterDc == true && bDcMatch ==  false)
			{
				continue;
			}
			Forecast::DAL::SimSystemState::UserDailyMap& user_dailyMap = (*dcIt).second;

			// set data center information into the planner
			planner.SetDataCenterName( data_center );
			// scan comm, for each datacenter add SYSTEM user daily
			DCLookup dc(data_center);
			Definition::CommDomVec::const_iterator it = std::find_if(commVec.begin(), commVec.end(), dc);
			if ( it == commVec.end() )
			{
				planner.SetFirstDayOfTheWeek(dy_cb_base::eMONDAY);
			}
			else
			{
				planner.SetFirstDayOfTheWeek(it->start_day_of_week());
			}
			// set plan system features by platform
			if (it->platform() == "MVS")
				planner.SetPlanSystemSettings(dy_planner::MVS_PLAN_SYSTEM);
			else
				planner.SetPlanSystemSettings(dy_planner::MPM_PLAN_SYSTEM);

			// for-each user daily
			for (Forecast::DAL::SimSystemState::UserDailyMap::iterator udIt = user_dailyMap.begin()
				; udIt != user_dailyMap.end() && !m_stopFlag
				; ++udIt)
			{
				const std::string& user_daily = (*udIt).first;
				Forecast::DAL::SimSystemState::TimeTableIdsPair udTimeTableIds = (*udIt).second;
				const std::string& user_dailyTime = udTimeTableIds.first;
				Forecast::DAL::SimSystemState::TableIdVec& table_ids = udTimeTableIds.second;

				// remember which user daily we processed
				dy_user_daily_processed.push_back( std::make_pair( data_center, user_daily ) );

				// user user daily information into the simulator engine
				if (user_daily != "SYSTEM")
				{
					m_simulator->UpdateUserDaily(data_center, user_daily, user_dailyTime);
				}

				size_t lastGroupOrderId(0);
				// foreach table id
				for (Forecast::DAL::SimSystemState::TableIdVec::iterator idIt = table_ids.begin()
					; idIt != table_ids.end() && !m_stopFlag
					; ++idIt)
				{

					//TODO: REFACT: handle one scheduler table
					int table_id = (*idIt);

					DIAG_PDEF(DIAG_I, "Graph " << m_resourceId 
						<< " datacenter: " << data_center 
						<< " user daily: " << user_daily 
						<< " table id: " << table_id
						);

					// update callback with progress information
					++progressCurPos;
					m_SenderToGui.UpdateCBWithProgress("planning", progressUpdateTime, progressCurPos, progressMaxPos);


					bsm::DefJobVec jobdefs;
					DefJobRepository::Instance()->GetDefJobsByTableId( table_id, jobdefs );

					planner.InitPlan( GetPlanOrderDateStr() );

					// find table definition by table_id
					DefTableFields_TableIdLookup defTableLookup(table_id);
					bsm::DefTableInfos::const_iterator defTableIt = std::find_if(defTables.begin(), defTables.end(), defTableLookup);
					if (defTableIt == defTables.end())
					{
						DIAG_PDEF(DIAG_E, "table id " << table_id << ", not found, must be a bug! (skip to next table)");
						continue;
					}
					const DefTableFields& deftblFields = (*defTableIt);
					bTblMatch = m_Matcher.TableDoesItMatch(deftblFields.m_SchedTable);

					bUDMatch = m_Matcher.UserDailyDoesItMatch(deftblFields.m_User_Daily);
					if (bUDMatch == false)
						continue;

					// check security filter
					bool bTableAuthorized = m_Matcher.IsTableAuthorized(deftblFields, BROWSE_ACCESS);

					// manage scheduling group information
					lastGroupOrderId = 0;
					bool bSchedulingGroupTbl = false;
					std::vector< bool > jobdefsSend( jobdefs.size(), false );
					std::vector< size_t > joboidSend( jobdefs.size(), 0 );

					DIAG_PDEF(DIAG_D, m_resourceId << ": Check planning for table id " 
						<< table_id << " (" << jobdefs.size() << " jobs)");


					long totalJobsFromTable = 0;
					ACE_Time_Value planningStartTime( ACE_OS::gettimeofday() );
					for (size_t i = 0; i != jobdefs.size() ; ++i)
					{
						bsm::DefJob& dbjob = *jobdefs[i];
						bool bSchedulingGroupJob = false;

						if (i == 0)
						{
							// check if this is a scheduling group
							if (dbjob.Base().f_DBF_DEF_JOB_TASK_TYPE == "Scheduling Group")
							{
								bSchedulingGroupTbl = true;
								bSchedulingGroupJob = true;
								lastGroupOrderId = m_nextOrderId;
								DIAG_PDEF(DIAG_D, m_resourceId << ": table id " << table_id << " is a scheduling group");
							}
						}

						// plan job
						DIAG_PDEF(DIAG_D, m_resourceId << ": plan job information for table id " 
							<< table_id << ", job id " << dbjob.Base().f_DBF_DEF_JOB_JOB_ID );

						// count number of jobs we processed
						++totalJobsProcessed;

						bool bJobOrdered = true;

						if(!extjob_seq)
						{
							//For Forecast
							EM_PROFILER_MANUAL_START(P_Plan);
							bJobOrdered = planner.ProcessDBJob(dbjob);
							EM_PROFILER_MANUAL_STOP(P_Plan);
						}

						if (!bJobOrdered) 
						{
							// if this is a scheduling group we don't need to check the reset of the table
							if (i==0 && bSchedulingGroupTbl == true)
							{
								DIAG_PDEF(DIAG_D, m_resourceId << ": sched group is not ordered, we skip all table");
								jobdefsSend.clear();
								joboidSend.clear();
								// skip table
								break;
							}

							// skip to next job
							continue;
						}

						// Get parsed command type jobs for user daily commands
						std::string JobToOrderName = dbjob.GetUserDailyNameToOrder();
						if ( !JobToOrderName.empty() ) //the job has some user daily
						{
							DIAG_PDEF(DIAG_D, std::string("job ") + dbjob.GetName() + " orders table " +  JobToOrderName);
							ProcessJobDynamicUserDaily( JobToOrderName, user_dailyMap, data_center, dy_user_daily_processed, dy_user_daily_to_process );
						}

						// setup order id for this job
						size_t jobOrderId = m_nextOrderId++;
						DIAG_PDEF(DIAG_D, m_resourceId << ": job is ordered with oid = " << jobOrderId);

						// filter job
						bool bPassedFilter = bTableAuthorized 
							&& bDcMatch 
							&& bTblMatch 
							&& m_Matcher.DisplayDoesItFit(dbjob)
							;


						joboidSend[i] = jobOrderId;
						jobdefsSend[i] = bPassedFilter;
						
						//put the dbjob in queue for adding to the simulator in another thread
						{  
							EM_PROFILER_SCOPE(P_AddToSimulator_0);
		
							m_AdderToSim.Put( new 
								SimGraphI_AddToSim::Message_AddToSimulator(
							dbjob, 
							jobOrderId,
								bSchedulingGroupJob ? 0 : lastGroupOrderId,//for scheduled group the group id is 0
							planner.GetNextOrderDay(),
							planner.GetPrevOredrDay(),
							user_daily,
							deftblFields,
							bPassedFilter,
								m_params.UseDoConditions,
								extjob_seq)
							);

						}

						++m_totalJobsInSimGraph;
						++totalJobsFromTable;

					} // for-each job definitions

					if (totalJobsFromTable > 0)
					{
						// update global counter
						m_gTotalJobsInSimGraph += totalJobsFromTable;
					}

					size_t n = BooleanCount(jobdefsSend, true);

					if (n > 0)
					{
						//if the table is a scheduling group we must verify the scheduled group job is send/signed
							if(bSchedulingGroupTbl==true && jobdefsSend[0]==false)
							{
								++n;
								m_simulator->SetJobSign(JobFindHint(lastGroupOrderId,(*dcIt).first,true),true);
								jobdefsSend[0]=true;
							}

						m_SenderToGui.AddDefJobs(deftblFields, jobdefs, jobdefsSend, joboidSend, n, 
							m_GlobalCondSearcher, data_center);

								// force progress update
						m_SenderToGui.UpdateCBWithProgress("planning", progressUpdateTime, progressCurPos, progressMaxPos, true);

							// count number of jobs sent
							totalJobSent += n;
					}


				} // for-each table definition
			} // for-each user daily
		} // for-each datacenter

		dataCenterMap.clear();

		ProcessDynamicUserDailyInformation(dy_user_daily_to_process, defTables, dataCenterMap);

	} while (m_stopFlag == false && !dy_user_daily_to_process.empty());



	DIAG_PDEF(DIAG_I, "wait until finish adding to sim and close those working thread" << m_resourceId);
	m_AdderToSim.CloseAndWait(); 
	DIAG_PDEF(DIAG_I, "all jobs were added to the simulator" << m_resourceId);
	//Distribute global conditions - 
	//must be called after all jobs where loaded and the global conditions rules where loaded  
	LoadSystemScenario();
	m_simulator->DistributeAndCalcOrpahnCondsForAllDc();

	// in case we stopped by request
	if (m_stopFlag == true)
	{
		SetGraphStatus(Forecast::BUILD_STATUS_ERROR);
		DIAG_PDEF(DIAG_I, m_resourceId << ": Stop flag was raised, planning was stopped");
		return -1;
	}

	try{
		if( !m_ScenarioXMLStr.empty() )
	{
			DIAG_PDEF(DIAG_D, "Load Scenario To Graph");
			LoadScenarioToGraph(m_ScenarioXMLStr);
	}
	}
	catch(Forecast::Common::WhatIfValidationException& /*refEx*/)
	{
		//yoel todo
		m_ScenarioXMLStr.clear();
	}
	catch (Forecast::Common::FcException& /*refEx*/)
	{
		//yoel todo
		m_ScenarioXMLStr.clear();
	}

	SetGraphStatus(Forecast::BUILD_STATUS_COMPLETE);
	m_SenderToGui.NotifyCBHelper("graph end",std::mem_fun<void, Forecast::SimGraphCB>(&Forecast::SimGraphCB::GraphCB_End));

	//cleaning. should be last step (m_AdderToSim uses its)
	m_simulator->SetPeriodicStatsGetter(NULL);

	EM_PROFILER_MANUAL_STOP(P_BuildGraph);

	m_LastReport.m_LapTime=	EM_PROFILER_MANUAL_LAP_STRING(P_BuildGraph);
	m_LastReport.m_totalJobsProcessed=totalJobsProcessed;
	m_LastReport.m_PlanLapTime= EM_PROFILER_MANUAL_LAP_STRING(P_Plan);
	m_LastReport.m_LoadToGraphLapTime= EM_PROFILER_MANUAL_LAP_STRING(P_AddToSimulator);
	m_LastReport.m_DbLapTime= EM_PROFILER_MANUAL_LAP_STRING(P_DataLoad); 
	m_LastReport.m_CrbLapTime= EM_PROFILER_MANUAL_LAP_STRING(P_SendToGUI);
	m_LastReport.m_JobStatLoadLapTime= EM_PROFILER_MANUAL_LAP_STRING(P_LoadStatFromDb);
	m_LastReport.m_JobsSent=totalJobSent;
	m_LastReport.m_JobsInGraph=m_totalJobsInSimGraph;
	DIAG_P(DIAGC_TIME, DIAG_I, "End: BuildGraph" << m_resourceId);
	if (IS_PRINTABLE_DIAG_P(DIAGC_BIM, DIAG_I))
	{
		std::ostringstream Report;
		GetLastReport(Report);
		DIAG_P(DIAGC_BIM, DIAG_I,Report.str().c_str());
	}

	return 0;
}

void SimGraphI::GetLastReport(std::ostringstream& Rep)
{
	Rep<<std::endl<<"("<<m_LastReport.m_ReportTime.to_string("%d/%m/%Y %H:%M:%S:%q")
				<<") Report Build Graph : LapTime="<<m_LastReport.m_LapTime
		<<" TotalJobsProcessed="<<m_LastReport.m_totalJobsProcessed
		<<" JobsInGraph="<<m_LastReport.m_JobsInGraph
				<<" MaxTotalJobsInGraph="<<m_LastReport.m_MaxTotalJobsInSimGraph
				<<" MaxRunSimul="<<m_LastReport.m_MaxRunSims
		<<" DBaccess="<<m_LastReport.m_DbLapTime
		<<" Planning="<<m_LastReport.m_PlanLapTime
		<<" LoadToGraph="<<m_LastReport.m_LoadToGraphLapTime
		<<" Sending="<<m_LastReport.m_CrbLapTime
		<<" JobsSent="<<m_LastReport.m_JobsSent
		<<" LoadStatFromDb="<<m_LastReport.m_JobStatLoadLapTime
		;
}

void SimGraphI::ConstructResourceId()
{
	// setup SimGraphI resource id string
	DBG_FNC_ENTER("SimGraphI::ConstructResourceId");
	m_resourceId = "SimGraph:";
	size_t newId = m_gNextSimGraphId++;
	char szId[20] = {0};
	ACE_OS::itoa(newId, szId, 10);// 32_TO_64: Need to have ltoa 
	m_resourceId += szId;
}

void SimGraphI::SetSession(Session* s)
{
	DBG_FNC_ENTER("SimGraphI::SetSession");
	EM_ASSERT( "s != 0", "setting null session" );

	if( m_mySession )
	{
		m_mySession->Unregister(this, m_poa);
	}
	m_mySession = s;
	m_mySession->Register(this, m_poa);

	m_Matcher.SetSession(m_mySession);
}

Session* SimGraphI::GetSession()
{
	return m_mySession;
}

/*virtual*/ void SimGraphI::SetTraceOrderIds(const Forecast::OrderIdSeq & oid_seq) 
	ACE_THROW_SPEC ((CORBA::SystemException))
{
    DBG_FNC_ENTER("SimGraphI::SetTraceOrderIds");
	Forecast::BuildStatusEnum simStat = SimGraphI::GetSimStatus();
	if (simStat == Forecast::BUILD_STATUS_EXEC)
	{
        DIAG_PDEF(DIAG_I, m_resourceId << " simulator executed, can't set trace order ids");
		return;
	}

	if (m_simulator == NULL)
	{
		DIAG_PDEF(DIAG_I, m_resourceId << " no simulator was allocated");
		return;
	}

	std::vector< size_t > ids;
	CORBA::ULong len = oid_seq.length();
	for (CORBA::ULong i = 0; i < len; ++i)
	{
		ids.push_back(oid_seq[i]);
	}

	ACE_Guard< ACE_Thread_Mutex > guard(m_lock);
	m_simulator->SetTraceTojobs(ids);
}

/*virtual*/ Forecast::OrderIdSeq * SimGraphI::GetTraceOrderIds()
	ACE_THROW_SPEC((CORBA::SystemException))
{
    DBG_FNC_ENTER("SimGraphI::GetTraceOrderIds");
	Forecast::OrderIdSeq_var oid_seq = new Forecast::OrderIdSeq();
	Forecast::BuildStatusEnum simStat = SimGraphI::GetSimStatus();
	if (simStat == Forecast::BUILD_STATUS_EXEC)
	{
        DIAG_PDEF(DIAG_I, m_resourceId << " simulator executed, return empty list");
		return oid_seq.out();
	}

	if (m_simulator == NULL)
	{
		DIAG_PDEF(DIAG_I, m_resourceId << " no simulator was allocated");
		return oid_seq.out();
	}

	ACE_Guard< ACE_Thread_Mutex > guard(m_lock);
	std::vector< SimulJobI* >& ids = m_simulator->GetTraceJobsVec();
	oid_seq->length((CORBA::ULong)ids.size());
	for (CORBA::ULong i = 0; i < ids.size(); ++i)
	{
		SimulJobI* pJob = ids[i];
		oid_seq[i] = pJob->GetOrderID();// 32_TO_64: TODO: when EM clients support 64-bit,
										// OrderId in forecast's IDLs should be defined as a 64-bit variable
										// (CORBA::ULongLong - ?)
	}
	return oid_seq.out();
}

/*virtual*/ CORBA::Boolean SimGraphI::GetTraceInfo(
	Forecast::OrderId oid,
	CORBA::Long       Version,
	CORBA::String_out traceInfoAsXml
	) ACE_THROW_SPEC((CORBA::SystemException))
{
    DBG_FNC_ENTER("SimGraphI::GetTraceInfo");
	Forecast::BuildStatusEnum simStat = SimGraphI::GetSimStatus();
	if (simStat == Forecast::BUILD_STATUS_EXEC)
	{
        DIAG_PDEF(DIAG_I, m_resourceId << " simulator executed, can't clear trace results");
		traceInfoAsXml = CORBA::string_dup("");
		return false;
	}

	if (m_simulator == NULL)
	{
		DIAG_PDEF(DIAG_I, m_resourceId << " no simulator was allocated");
		traceInfoAsXml = CORBA::string_dup("");
		return false;
	}

	// TODO: lookup oid in simulator and get simulation result for oid as xml
	ACE_Guard< ACE_Thread_Mutex > guard(m_lock);
	std::vector< SimulJobI* >& ids = m_simulator->GetTraceJobsVec();
	SimulJobI* pJob = NULL;
	for (size_t i = 0; pJob == NULL && i < ids.size(); ++i)
	{
		SimulJobI* tmpJob = ids[i];
		if (tmpJob->GetOrderID()  == oid)
		{
			pJob = tmpJob;
		}
	}
	
	if (pJob == NULL)
	{
		// job not found or no log
		traceInfoAsXml = CORBA::string_dup("");
		return false;
	}

	// get job WhyLog information as xml
	
	std::ostringstream oss;
	pJob->DumpTraceAsXml(oss,Version);
	std::string xmlLog = oss.str();
	traceInfoAsXml = CORBA::string_dup(xmlLog.c_str());
	if (IS_PRINTABLE_DIAG_PDEF(DIAG_I))
	{
		DIAG_PDEF(DIAG_I, "Why as xml for job " << pJob->GetOrderID() << ":\n");

		oss << "\n" << std::endl;
		TDiag *pTheDiag = TDiag::Instance(); 
		pTheDiag->PrintDirectly(oss.str().c_str());
		pTheDiag->flush(); 
	}

	return true;
}

/*virtual*/ void SimGraphI::ClearTraceInfo() ACE_THROW_SPEC((CORBA::SystemException))
{
	// engine - release trace information 
    DBG_FNC_ENTER("SimGraphI::ClearTraceInfo");
	Forecast::BuildStatusEnum simStat = SimGraphI::GetSimStatus();
	if (simStat == Forecast::BUILD_STATUS_EXEC)
	{
        DIAG_PDEF(DIAG_I, m_resourceId << " simulator executed, can't clear trace results");
		return;
	}

	if (m_simulator == NULL)
	{
		DIAG_PDEF(DIAG_I, m_resourceId << " no simulator was allocated");
		return;
	}
	
	ACE_Guard< ACE_Thread_Mutex > guard(m_lock);
	m_simulator->ClearJobTrace();
}


int SimGraphI::GetJobDefinitionSize()
{
	Definition defDal(DALMgr::instance());

	int nJobDefSize = defDal.GetJobDefinitionSize();

	return nJobDefSize;
}


//////////////////////////////////////////////////////////////////////////
//
void SimGraphI::GetValuesList( const std::string& entityName, std::vector<std::string>& names )
{
	DBG_FNC_ENTER("SimGraphI::GetValuesList");

	AutoIter<DataCenterI>  DcIter=m_simulator->GetDataCenterIter();

	while(*DcIter!=NULL)
	{
		if(0); //switch by entity name
		else if( entityName == Forecast::Graph::en_entityDataCenter )
		{
			names.push_back((*DcIter)->GetDataCenterName());
		}
		else if( entityName == Forecast::Graph::en_entityQuantityResource )
		{
			(*DcIter)->GetQuantityResourceNameList(names);
		}
		else if( entityName == Forecast::Graph::en_entityControlResource)
		{
			(*DcIter)->GetControlResourceNameList(names);
		}
		else if( entityName == Forecast::Graph::en_entityApplication)
		{
			(*DcIter)->GetApplicationNameList(names);
		}
		else if( entityName == Forecast::Graph::en_entityGroup)
		{
			(*DcIter)->GetGroupNameList(names);
		}
		else if( entityName == Forecast::Graph::en_entitySchedTable)
		{
			(*DcIter)->GetSchedTableNameList(names);
		}

		++DcIter;
	}

	//remove duplicated 
	std::sort(names.begin(), names.end());
	std::vector<std::string>::iterator e = std::unique(names.begin(), names.end());
	names.erase(e, names.end());
}

//////////////////////////////////////////////////////////////////////////
//
void SimGraphI::SetupGlobalConditionPrefixSearcher(
	Definition& defDal,
	const Definition::CommDomVec& commVec)
{
	DBG_FNC_ENTER("SimGraphI::SetupGlobalConditionPrefixSearcher");

	RWDBConnection conn = DALMgr::instance()->GetConnection();

	// read global condition prefixes, and add them to the engine
	Forecast::DAL::GlobalCondVec globalCondVec;
	int rc = defDal.ReadGlobalCondList(globalCondVec, &conn);
	if (rc != 0)
	{
		DIAG_PDEF(DIAG_E, "failed to read global condition prefixes, run without (rc: " << rc << ")");
		m_SenderToGui.NotifyCBErrorMessage("build graph", 2, "fail to read global condition prefixes from database", false);
	}
	else
	{
		// add them into the simulator
		for (Forecast::DAL::GlobalCondVec::const_iterator it = globalCondVec.begin()
			; it != globalCondVec.end()
			; ++it)
		{
			const Forecast::DAL::GlobalCondInfo& gci = *it;
			const std::string& fromdc = gci.from_dc.std();
			const std::string& todc = gci.to_dc.std();
			const std::string& prefix = gci.prefix.std();
			m_simulator->GlobalCondRule(fromdc, todc, prefix);
		}
		// resolve global conditions 
		m_simulator->GlobalCondsResolveDc();
	}

	// setup global condition prefix searcher
	m_GlobalCondSearcher.Build(globalCondVec, commVec);
}

//////////////////////////////////////////////////////////////////////////
//
void SimGraphI::ReadCalendarInformation()
{
	DBG_FNC_ENTER("SimGraphI::ReadCalendarInformation");

	DIAG_PDEF(DIAG_D, m_resourceId << ": read calendar information");
	if (m_calendarCache.ReadRefresh() != 0)
	{
		ThrowFatalError("build graph", 1, "fail to read calendar information from database");
	}

}

//////////////////////////////////////////////////////////////////////////
// used to interrupt the normal flow.
// client will get the message throw callback
// throw a 'fatal error' exception to catch on high level to return -1
void SimGraphI::ThrowFatalError( const std::string& context, long errCode, const std::string& errMsg) throw ( FatalError )
{
	DBG_FNC_ENTER("SimGraphI::ThrowFatalError");
	DIAG_PDEF(DIAG_E, m_resourceId << ": " << errMsg);
	SetGraphStatus(Forecast::BUILD_STATUS_ERROR);
	m_SenderToGui.NotifyCBErrorMessage(context.c_str(), errCode, errMsg.c_str(), true); //true is fatal error
	throw FatalError( context, errCode, errMsg);
}

//////////////////////////////////////////////////////////////////////////
// fill engine with datacenter information
//
void SimGraphI::FillEngineWithDatacenterInformation(const DAL::Definition::CommDomVec& commVec)
{
	DBG_FNC_ENTER("SimGraphI::FillEngineWithDatacenterInformation");

	CCondition::SetAddVirtualOrphanConditions(m_params.AddVirtualOrphanConditions);

	for (size_t i = 0; i < commVec.size();  ++i)
	{
		const commDom& c = commVec[i];
		if (c.enabled() == "0" || c.control_m_ver() < "610")
			continue;

		DIAG_PDEF(DIAG_D, m_resourceId << ": fill engine with datacenter information : " << c.data_center());
		DataCenterSimulAdapter dcAdapter(c);
		DataCenterI* pDc = m_simulator->CreateDataCenter(dcAdapter);
		// set data center parameters
		pDc->SetStatisticsRunType((short)m_params.StatisticsRunType);
		pDc->SetAutoOrphan(CCondition::ConditionMode(m_params.AddAllOrphanConditions));
		pDc->SetAutoConfirmMode(DataCenterI::ConfirmMode(m_params.ExecuteConfirmedJobs));
		pDc->SetDefaultElapsedTime(m_params.DefaultJobElapsedTime);
		pDc->SetPeriodicStatsGetter(&m_periodicStatsGetterImpl);
		pDc->SetDiscardOrphanConditions( m_params.DiscardOrphanConditions > 0 );
	}
}

//////////////////////////////////////////////////////////////////////////
//
void SimGraphI::LoadQuantitativeResources(DAL::Definition& defDal, const DAL::Definition::CommDomVec& commVec)
{
	DBG_FNC_ENTER("SimGraphI::LoadQuantitativeResources");

	RWDBConnection conn = DALMgr::instance()->GetConnection();

	DcQuanResDataVector DcQuantVec;
	if(defDal.ReadQuantResources(DcQuantVec,true, commVec, &conn) !=0 )
	{
		ThrowFatalError("build graph", 1, "fail to read Quantitative resources definitions from database");
	}
	m_simulator->UpdateQuantResources(DcQuantVec);

}

//////////////////////////////////////////////////////////////////////////
//
int SimGraphI::CountNumberOfTablesToProcess(const DAL::SimSystemState::DataCenterMap& dataCenterMap)
{
	DBG_FNC_ENTER("SimGraphI::CountNumberOfTablesToProcess");
	int progressMaxPos = 0;

	for (Forecast::DAL::SimSystemState::DataCenterMap::const_iterator dcIt = dataCenterMap.begin()
		; dcIt != dataCenterMap.end() && !m_stopFlag
		; ++dcIt)
	{
		const Forecast::DAL::SimSystemState::UserDailyMap& user_dailyMap = (*dcIt).second;
		// for each datacenter
		for (Forecast::DAL::SimSystemState::UserDailyMap::const_iterator udIt = user_dailyMap.begin()
			; udIt != user_dailyMap.end() && !m_stopFlag
			; ++udIt)
		{
			// for each user daily
			Forecast::DAL::SimSystemState::TimeTableIdsPair udTimeTableIds = (*udIt).second;
			Forecast::DAL::SimSystemState::TableIdVec& table_ids = udTimeTableIds.second;
			progressMaxPos += (int)table_ids.size();
		}
	}

	return progressMaxPos;

}

//////////////////////////////////////////////////////////////////////////
// process dynamic user daily information into 'dataCenterMap'
//
void SimGraphI::ProcessDynamicUserDailyInformation(
	const DataCenterUserDailyVec& dy_user_daily_to_process,
	const bsm::DefTableInfos& defTables,
	DAL::SimSystemState::DataCenterMap& dataCenterMap)
{
	DBG_FNC_ENTER("SimGraphI::ProcessDynamicUserDailyInformation");

	DataCenterUserDailyVec::const_iterator dyUdIt = dy_user_daily_to_process.begin();
	for (; dyUdIt != dy_user_daily_to_process.end(); ++dyUdIt)
	{
		const std::string& dc = (*dyUdIt).first;
		const std::string& ud = (*dyUdIt).second;
		Forecast::DAL::SimSystemState::TimeTableIdsPair& p = dataCenterMap[dc][ud];

		for (size_t i = 0; i < defTables.size(); ++i)
		{
			if (defTables[i].m_DataCenter == dc && defTables[i].m_User_Daily == ud)
			{
				int table_id = defTables[i].m_Table_ID;
				p.second.push_back(table_id);
			}
		}
	}

}

//////////////////////////////////////////////////////////////////////////
//
void SimGraphI::ProcessJobDynamicUserDaily( const std::string& JobToOrderName,
						   const Forecast::DAL::SimSystemState::UserDailyMap& user_dailyMap,
						   const std::string& data_center,
						   const DataCenterUserDailyVec& dy_user_daily_processed,
						   DataCenterUserDailyVec& dy_user_daily_to_process
						   )
{
	DBG_FNC_ENTER("SimGraphI::ProcessJobDynamicUserDaily");

	//If we are not going to process it
	if(user_dailyMap.find(JobToOrderName)==user_dailyMap.end())
	{
		// if we didn't processed this user daily
		DataCenterUserDailyVec::const_iterator dcudIt = std::find_if( 
			dy_user_daily_processed.begin(), 
			dy_user_daily_processed.end(), 
			DCUDPairLookup(data_center,JobToOrderName ));

		if (dcudIt == dy_user_daily_processed.end())
		{
			// if it is not in our current processing list
			dcudIt = std::find_if( 
				dy_user_daily_to_process.begin(), 
				dy_user_daily_to_process.end(), 
				DCUDPairLookup(data_center, JobToOrderName));
			if (dcudIt == dy_user_daily_to_process.end())
			{
				// add data_center and user_daliy to our processing list
				dy_user_daily_to_process.push_back( 
					std::make_pair( data_center, JobToOrderName ));
			}
		}
	}

}

}}	// Forecast::Service


OUTPUT_END
Execute (c:\utils\ccm_task_diff.pl:128): EXECUTE_CMD: ccm diff -vc  SimGraphI.cpp#81.1.3.1.3:cpp:4
Execute (c:\utils\ccm_task_diff.pl:128): OUTPUT_BEGIN
Attribute name            SimGraphI.cpp#81.1.3.1.2   SimGraphI.cpp#81.1.3.1.3  
------------------------- -------------------------- --------------------------
create_time               Thu Dec 10 13:24:06 2009   Tue Dec 15 10:03:08 2009  
modify_time               Tue Dec 22 18:31:04 2009   Wed Dec 23 13:25:06 2009  
release                   6.4.0.03                   6.4.0.04                  
status                    released                   integrate                 
version                   81.1.3.1.2                 81.1.3.1.3                
comment                   Merged 'SimGraphI.cpp#8... <doesn't exist>           
source_create_time        Thu Dec 10 13:24:07 2009   Tue Dec 15 10:03:09 2009  
source_modify_time        Thu Dec 10 13:24:11 2009   Tue Dec 15 10:04:43 2009  

===============================================================================
Associated tasks differs:

SimGraphI.cpp#81.1.3.1.2
43659: 640fp3: forecast: add system parameter: discard virtual cond 

SimGraphI.cpp#81.1.3.1.3
43731: 640.4: bsm: forecast: diag: print bim data  w/o name

===============================================================================
Text attribute 'source' differs:

6c6
<  *	%date_created:	Thu Dec 10 13:24:06 2009 %
---
>  *	%date_created:	Tue Dec 15 10:03:08 2009 %
12c12
< static const char _SimGraphI_cpp_cpp[] = "@(#) %name: SimGraphI.cpp %, %cvtype: cpp %, %date_modified: %, %derived_by: yakovt %, %version: 81.1.3.1.2 %, %instance: 4 %, %compiled: "__DATE__", "__TIME__" %, %file_path: "__FILE__ " %(#)@";
---
> static const char _SimGraphI_cpp_cpp[] = "@(#) %name: SimGraphI.cpp %, %cvtype: cpp %, %date_modified: %, %derived_by: yakovt %, %version: 81.1.3.1.3 %, %instance: 4 %, %compiled: "__DATE__", "__TIME__" %, %file_path: "__FILE__ " %(#)@";
1260c1260
< 		exceptionMsg = "Got system exception during simulation : " + em::tos(se);
---
> 		exceptionMsg = "Got CORBA system exception during simulation : " + em::tos(se);
1267c1267
< 	catch( const FatalError&  )
---
> 	catch( const FatalError&  e)
1268a1269
> 		exceptionMsg = "Got FatalError: " + em::tos(e.what());
1279c1280
< 		DIAG_PDEF( DIAG_D, exceptionMsg );
---
> 		DIAG_PDEF( DIAG_W, exceptionMsg );

===============================================================================
Text attribute 'status_log' differs:

1,4c1,2
< Thu Dec 10 13:24:06 2009: Status set to 'working' by yakovt in role developer
< Thu Dec 10 13:25:01 2009: Status set to 'integrate' by yakovt in role developer
< Wed Dec 16 14:00:42 2009: Status set to 'sqa' by bldrem in role build_mgr
< Tue Dec 22 18:31:04 2009: Status set to 'released' by bldrem in role build_mgr
---
> Tue Dec 15 10:03:08 2009: Status set to 'working' by yakovt in role developer
> Wed Dec 23 13:25:06 2009: Status set to 'integrate' by yakovt in role developer


OUTPUT_END
Execute (c:\utils\ccm_task_diff.pl:174): EXECUTE_CMD: ccm cat SimGraphI.cpp#81.1.3.1.2:cpp:4
Execute (c:\utils\ccm_task_diff.pl:174): OUTPUT_BEGIN
/*
 *  Copyright (c) 2005
 *  BMC Software Inc.
 *
 *	file %name:	SimGraphI.cpp %
 *	%date_created:	Thu Dec 10 13:24:06 2009 %
 *	description:	
 *
 */

#ifndef lint 
static const char _SimGraphI_cpp_cpp[] = "@(#) %name: SimGraphI.cpp %, %cvtype: cpp %, %date_modified: %, %derived_by: yakovt %, %version: 81.1.3.1.2 %, %instance: 4 %, %compiled: "__DATE__", "__TIME__" %, %file_path: "__FILE__ " %(#)@";
#endif

#include "stdafx.h"
#include <Common/pragma_begin.h>

#include "tao/TAO_Export.h"
#include "tao/Sequence_T.h"
#include <ace/Method_Request.h>
#include <Common/pragma_end.h>
#include "forecastservice_export.h"
#include "Session.h"
#include "ForecastDAL/DALMgr.h"
#include "ForecastDAL/Definition.h"
#include "ForecastDAL/SimSystemState.h"
#include "BsmService/CrbConvert.h"
#include "DBJobPlanner.h"
#include "em_crb_foundations/ECSOrbCommon.h"
#include "DBJobSimulAdapter.h"
#include "DataCenterSimulAdapter.h"
#include "libfcengine/SimulatorFactory.h"
#include "libfcengine/DataCenterI.h"
#include "libfcengine/SimulJobI.h"
#include "libfcengine/SchedGroupI.h"
#include "libfcengine/InCondString.h"
#include "libfcengine/ConditionRuleI.h"
#include "em_foundations/ECSObjectWrappers.h"
//#include "SelectionDef/ECSSelectionDef.h"
#include "ForecastServiceI.h"
#include "em_db/ECSParams.h"			// db params table
#include "SimGraphI.h"
#include <em_foundations/EmException.h>
#include <em_foundations/EmHelper.h>
#include "ForecastDAL/WhatIf.h"
#include <ForecastService/ForecastParametersMgr.h>
#include <BsmService/PeriodicStatsAdapters.h>
#include "libfcengine/SimulJobI.h"
#include "libfcengine/BimSimulJobI.h"
#include "libfcengine/TraceAssumptionsMap.h"
#include <em_foundations/EmProfiler.h>
#include <BsmCommon/Helper.h>

#include <BsmCommon/DefJob.h>
#include <ForecastService/DefJobRepository.h>
#include <ForecastService/SenderToGui.h>
#include <ForecastService/SimGraphI_AddToSim.h>

DIAG_REGISTER_MODULE;


using namespace Forecast::DAL;

namespace	Forecast {
namespace	Service {

// helpers
namespace {

	class DefTableFields_TableIdLookup : public std::unary_function< const DefTableFields&, bool >
	{
	public:
		DefTableFields_TableIdLookup(int table_id) : m_table_id(table_id) 
		{
		}

		result_type operator()(argument_type a) const
		{
			return a.m_Table_ID == m_table_id;
		}

	private:
		int m_table_id;
	};

	class DCUDPairLookup : public std::unary_function< const std::pair< std::string, std::string >&, bool >
	{
	public:
		DCUDPairLookup(const std::string& dc, const std::string& ud) : m_dc(dc), m_ud(ud) {}
		result_type operator()(argument_type a) const
		{
			return a.first == m_dc && a.second == m_ud;
		}
	private:
		const std::string& m_dc;
		const std::string& m_ud;
	};

	class CountScope
	{
	public:
				CountScope(ACE_Atomic_Op<ACE_Thread_Mutex, long>& counter) : m_counter(counter) { 
					m_counter++; 
				}
		~CountScope() { m_counter--; }
	private:
		ACE_Atomic_Op<ACE_Thread_Mutex, long>&	m_counter;
	};

	inline size_t BooleanCount( const std::vector<bool>& vec, bool v )
	{
		//std::count is not supported on SUN and AIX
		//size_t n = std::count(jobdefsSend.begin(), jobdefsSend.end(), true);
		size_t n=0;
		for( std::vector< bool >::const_iterator it=vec.begin(), it_end=vec.end(); it!=it_end; ++it) 
		{
			if( *it == v ) ++n;
		}
		return n;
	}


} // unnamed namespace - helpers

/*static*/ const size_t SimGraphI::DEFAULT_CB_MAX_SEQ_SIZE = 25;

SimGraphI_SimRunner::SimGraphI_SimRunner(SimGraphI* sg)
	: m_sg(sg)
{
	// Construct
}

/*virtual*/ int SimGraphI_SimRunner::svc()
{
	DBG_FNC_ENTER("SimGraphI_SimRunner::svc");

	int rc = -1;
	if (m_sg != NULL)
	{
		try {
			rc = m_sg->RunSimulation();
		}
		catch( const EmAssertException& e)
		{
			DIAG_PDEF(DIAG_E, "EmAssertException Exception: " << e.what());
		}
		catch( const EmException& e)
		{
			DIAG_PDEF(DIAG_E, "EmException Exception: " << e.what());
		}
		catch( const std::exception& e)
		{
			DIAG_PDEF(DIAG_E, "std::exception: " << e.what());
		}
	}
	return rc;
}

/*static*/ ACE_Atomic_Op<ACE_Thread_Mutex, long> SimGraphI::m_gNextSimGraphId(1);
/*static*/ ACE_Atomic_Op<ACE_Thread_Mutex, long> SimGraphI::m_gTotalJobsInSimGraph(0);
/*static*/ ACE_Atomic_Op<ACE_Thread_Mutex, long> SimGraphI::m_gTotalRunSim(0);
		/*static*/ ACE_Atomic_Op<ACE_Thread_Mutex, long> SimGraphI::m_gMaxRunSim(0);
		/*static*/ ACE_Atomic_Op<ACE_Thread_Mutex, long> SimGraphI::m_gMaxTotalJobsInSimGraph(0);

SimGraphI::SimGraphI(PortableServer::POA_ptr poa, ForecastServiceI& fcService)
	: m_simRunner(this)
	, m_forecastService(fcService)
	, m_bimServiceMgr(m_simulator)
	, m_summary(this)
	, m_AdderToSim(m_simulator, m_params, m_bimServiceMgr, m_resourceId, m_LastReport, m_periodicStatsGetterImpl)
	, m_calendarCache( DALMgr::instance() )
{
	// Construct
	DBG_FNC_ENTER("SimGraphI::SimGraphI");
	ConstructResourceId();
	m_poa = PortableServer::POA::_duplicate(poa);
	m_graphStatus = Forecast::BUILD_STATUS_INIT;
	m_simStatus = Forecast::BUILD_STATUS_INIT;
	m_mySession = NULL;
	m_stopFlag = false;
	//m_cb = Forecast::SimGraphCB::_nil();
	m_simulator = NULL;
	m_nextOrderId = 1;
	m_bFilterDc = false;
	m_totalJobsInSimGraph = 0;

	ForecastParametersMgr* params_mgr = ForecastParametersMgr::Instance();
	params_mgr->LoadSystemParameters();
	m_params = params_mgr->GetParameters();
	// allocate simulator if needed
	if (m_simulator == NULL)
	{
		m_simulator = CSimulatorFactory::CreateSimulator( ); 
		if (m_simulator == NULL)
		{
			DIAG_PDEF(DIAG_E, "Failed to create simulation engine");
			SetGraphStatus(Forecast::BUILD_STATUS_ERROR);
		}
		m_bimServiceMgr.SetSimulator(m_simulator);
	}

	m_periodicStatsGetterImpl.SetParams(m_params.CollectStatByField);
}



/*virtual*/ SimGraphI::~SimGraphI()
{
	// Destruct - should be called because of 'Destroy'
	//		reference drop to zero, than delete this.
	//		we just make sure that all thread done
	DBG_FNC_ENTER("SimGraphI::~SimGraphI");
	WaitTillAllTasksComplete();
	DIAG_PDEF(DIAG_D,"After Wait");;

	// update total counter
	m_gTotalJobsInSimGraph -= m_totalJobsInSimGraph;

	// release simulator
	delete m_simulator;
	std::pair< size_t, size_t > size_count = bsm::GetTotalMemoryInUse();
	DIAG_P(DIAGC_BIM, DIAG_I, "Total allocated so far: " << size_count.first << " in " << size_count.second << " blocks " );

}

/*virtual*/ void SimGraphI::RunSim()
      ACE_THROW_SPEC ((
        CORBA::SystemException,
		Forecast::Simulator::RESOURCE_EXCEPTION
      ))
{
	// check out current status, run simulation
	DBG_FNC_ENTER("SimGraphI::RunSim");
	DIAG_P(DIAGC_TIME, DIAG_I, m_resourceId << " request to run simulation");

	CountScope runSimCount(m_gTotalRunSim);

	// check if worker thread already running
	if (m_simRunner.thr_count() > 0)
	{
		// thread already running simulation, nothing to do
		DIAG_PDEF(DIAG_E, m_resourceId << " simulation thread is already running");
		return ;
	}

	if (GetGraphStatus() != Forecast::BUILD_STATUS_COMPLETE)
	{
		// limit check - number of running simulations
		long currTotalRunSim = m_gTotalRunSim.value();
		if (m_params.MaxForecastRunningRequests >= 0 && currTotalRunSim >  m_params.MaxForecastRunningRequests)
		{
			DIAG_PDEF(DIAG_I, m_resourceId << " number of current RunSim (" 
				<< currTotalRunSim << ") exceeded the limit (" << m_params.MaxForecastRunningRequests << ")");
			Forecast::Simulator::RESOURCE_EXCEPTION ex;
			ex.Reason = CORBA::string_dup("Max running requests exceeded");
			throw ex;

		}
				if(currTotalRunSim > m_gMaxRunSim.value()){
					m_gMaxRunSim = currTotalRunSim;
				}

		// limit check - number of loaded jobs
		long currTotalJobsInSimGraph = m_gTotalJobsInSimGraph.value();

				if(currTotalJobsInSimGraph > m_gMaxTotalJobsInSimGraph.value()){
					m_gMaxTotalJobsInSimGraph = currTotalJobsInSimGraph;
				}

		if (m_params.MaxForecastJobsInMem >= 0 && currTotalJobsInSimGraph > m_params.MaxForecastJobsInMem)
		{
			DIAG_PDEF(DIAG_I, m_resourceId << " number of jobs in SimGraph (" 
				<< currTotalJobsInSimGraph << ") exceeded the limit (" << m_params.MaxForecastJobsInMem << ")");
			Forecast::Simulator::RESOURCE_EXCEPTION ex;
			ex.Reason = CORBA::string_dup("Max number of jobs in memory exceeded");
			throw ex;
		}
	}

	// create thread to execute SimGraph build
	m_stopFlag = false;

	int r = m_simRunner.activate();
	if (r != 0)
	{
		DIAG_PDEF(DIAG_E, "Fatal error - " << m_resourceId << " thread creation failed, rc=" << r);
		Forecast::Simulator::RESOURCE_EXCEPTION ex;
		ex.Reason = CORBA::string_dup("Simulation thread creation failed");
		throw ex;
	}
}

/*virtual*/ void SimGraphI::StopSim()
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ))
{
	// check current status, set stop flag
	DBG_FNC_ENTER("SimGraphI::StopSim");
	WaitTillAllTasksComplete();
}

/*virtual*/ Forecast::BuildStatusEnum SimGraphI::GetSimStatus()
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ))
{
	ACE_Guard< ACE_Thread_Mutex > guard(m_lock);
	return m_simStatus;
}

		void DumpAsInSecFrom(Forecast::JobSimInfo& SimJobInfo,unsigned int NumberOfExecTime,SimulJobI& Job,
			const TimeValue& From)
		{
			for(unsigned int t=0; t< NumberOfExecTime;++t)
			{
				(SimJobInfo.exec_info)[t].started=static_cast<Forecast::SimTime>(TimeValue::NO_TIME);
				(SimJobInfo.exec_info)[t].ended=static_cast<Forecast::SimTime>(TimeValue::NO_TIME);

				if(Job.GetStartedTimeIx(t).IsNeqNoTime())
				{
					(SimJobInfo.exec_info)[t].started=
						static_cast<Forecast::SimTime>(Job.GetStartedTimeIx(t).ToSecFrom(From));
				}
				if(Job.GetEndedTimeIx(t).IsNeqNoTime())
				{
					(SimJobInfo.exec_info)[t].ended=
						static_cast<Forecast::SimTime>(Job.GetEndedTimeIx(t).ToSecFrom(From));
				}
			}
		}

		void DumpAsTime_T(Forecast::JobSimInfo& SimJobInfo,unsigned int NumberOfExecTime,SimulJobI& Job)
		{
			for(unsigned int t=0; t< NumberOfExecTime;++t)
			{
				(SimJobInfo.exec_info)[t].started=static_cast<Forecast::SimTime>(TimeValue::NO_TIME);
				(SimJobInfo.exec_info)[t].ended=static_cast<Forecast::SimTime>(TimeValue::NO_TIME);

				if(Job.GetStartedTimeIx(t).IsNeqNoTime())
				{
					(SimJobInfo.exec_info)[t].started=
						static_cast<Forecast::SimTime>(Job.GetStartedTimeIx(t).ToTime_t());
				}
				if(Job.GetEndedTimeIx(t).IsNeqNoTime())
				{
					(SimJobInfo.exec_info)[t].ended=
						static_cast<Forecast::SimTime>(Job.GetEndedTimeIx(t).ToTime_t());
				}
			}
		}

		/*virtual*/ void SimGraphI::GetSimResultList(CORBA::Long how_many,
			Forecast::DataCenterSimInfoSeq_out siminfo_seq,
			Forecast::DataCenterJobsInfoIterator_out dcinfo_it)
			ACE_THROW_SPEC ((CORBA::SystemException))
		{
			GetSimulationResults(how_many,siminfo_seq,dcinfo_it,true);
		}

		/*virtual*/ void SimGraphI::GetSimResultList2(CORBA::Long how_many,
	Forecast::DataCenterSimInfoSeq_out siminfo_seq,
			Forecast::DataCenterJobsInfoIterator_out dcinfo_it)
			ACE_THROW_SPEC ((CORBA::SystemException))
		{
			GetSimulationResults(how_many,siminfo_seq,dcinfo_it,false);
		}



void SimGraphI::GetSimulationResults(CORBA::Long how_many,
	Forecast::DataCenterSimInfoSeq_out siminfo_seq,
	Forecast::DataCenterJobsInfoIterator_out dcinfo_it,
	bool ConvertTo24HoursInSec)
	ACE_THROW_SPEC ((CORBA::SystemException))
{
	// 
	DBG_FNC_ENTER("SimGraphI::GetSimResultList");
	siminfo_seq = new Forecast::DataCenterSimInfoSeq;
	dcinfo_it = Forecast::DataCenterJobsInfoIterator::_nil();

	Forecast::BuildStatusEnum simStat = SimGraphI::GetSimStatus();
	if (simStat != Forecast::BUILD_STATUS_COMPLETE)
	{
        DIAG_PDEF(DIAG_I, m_resourceId << " simulator didn't complete, return empty results");
		return;
	}

	AutoIter<DataCenterI>  DcIter=m_simulator->GetDataCenterIter();
	int TotalNumOfJobs(0);
	std::vector<DataCenterI*> DcVec;
	while(*DcIter!=NULL)
	{
		int DcNumOfJobs=(*DcIter)->GetNumOfJobs(true);
		if(DcNumOfJobs > 0)
		{
			DcVec.push_back(*DcIter);
		}
		TotalNumOfJobs+=DcNumOfJobs;
		++DcIter;
	}
	siminfo_seq->length(DcVec.size());

	if(DcVec.size()==0 || TotalNumOfJobs == 0)
	{
		//add debug log  - todo yoel
		return;
	}
	if(TotalNumOfJobs > how_many)
	{
		//TODO barak yoel - We need to init DataCenterJobsInfoIterator 
	}
	
	how_many=TotalNumOfJobs; //we will change it when we implemnt DataCenterJobsInfoIterator
	unsigned int i=0;
	int JobCounter=0;
	while(JobCounter < how_many && i < DcVec.size())
	{
		Forecast::DataCenterSimInfo& DcSimInfo= (*siminfo_seq)[i];
		DcSimInfo.datacenter = DcVec[i]->GetDataCenterName().c_str();
		DcSimInfo.job_siminfo_seq.length(DcVec[i]->GetNumOfJobs(true));
		DataCenterI::JobIterator& JobIter = DcVec[i]->GetJobIter();
		int j=0;
		while(JobCounter < how_many && (*JobIter) != NULL)
		{
			Forecast::JobSimInfo& SimJobInfo = (DcSimInfo.job_siminfo_seq)[j];
			SimulJobI& Job = (*(*JobIter));
			SimJobInfo.oid =  Job.GetOrderID();
			unsigned int NumberOfExecTime=Job.GetNumberOfExecTime();
			SimJobInfo.exec_info.length(NumberOfExecTime);
					if(ConvertTo24HoursInSec==true)
						DumpAsInSecFrom(SimJobInfo,NumberOfExecTime,Job,DcVec[i]->GetOdateMidnight());
					else
						DumpAsTime_T(SimJobInfo,NumberOfExecTime,Job);
			++JobCounter;
			++JobIter;
			++j;
		}
		delete &JobIter;
		++i;
	}
}

/*virtual*/ Forecast::BuildStatusEnum SimGraphI::GetGraphStatus()
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ))
{
	ACE_Guard< ACE_Thread_Mutex > guard(m_lock);
	return m_graphStatus;
}

/*virtual*/ void SimGraphI::BuildGraph()
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ))
{
	// TODO: in a thread context run only build graph
	DBG_FNC_ENTER("SimGraphI::BuildGraph");
	//CountScope runSimCount(m_gTotalRunSim);
	DIAG_P(DIAGC_TIME, DIAG_I, "Start: Build Graph " << m_resourceId);
	int rc = 0;
	try
	{
		SetSimStatus(Forecast::BUILD_STATUS_EXEC);
		m_SenderToGui.NotifyCBHelper("build graph begin", std::mem_fun<void, Forecast::SimGraphCB>(&Forecast::SimGraphCB::SimCB_Begin) );

		// nothing to build if graph status complete
		if (GetGraphStatus() != Forecast::BUILD_STATUS_COMPLETE)
		{
			int rc = RunBuildGraph(NULL);
		}
		
		SetSimStatus(Forecast::BUILD_STATUS_COMPLETE);
		m_SenderToGui.NotifyCBHelper("build graph end",	std::mem_fun<void, Forecast::SimGraphCB>(&Forecast::SimGraphCB::SimCB_End) );
	}
	catch(CORBA::SystemException& se)
	{
		DIAG_PDEF(DIAG_E, "Got system exception during simulation : " << se);
		m_stopFlag = true;
		rc = -1;
		SetSimStatus(Forecast::BUILD_STATUS_ERROR);
	}
	catch(std::exception& se)
	{
		DIAG_PDEF(DIAG_E, "Got an exception during simulation : " << se.what());
		m_stopFlag = true;
		rc = -1;
		SetSimStatus(Forecast::BUILD_STATUS_ERROR);
	}

	DIAG_P(DIAGC_TIME, DIAG_I, "End: Build Graph " << m_resourceId);
}

/*virtual*/ void SimGraphI::BuildGraphExt(Forecast::SingleJobExtInfoSeq_out job_seq)
ACE_THROW_SPEC ((
				CORBA::SystemException
				))
{
	// TODO: in a thread context run only build graph
	DBG_FNC_ENTER("SimGraphI::BuildGraph");
	//CountScope runSimCount(m_gTotalRunSim);
	DIAG_P(DIAGC_TIME, DIAG_I, "Start: Build Graph " << m_resourceId);
	int rc = 0;
	try
	{

		// it is called under Batch Discovery and read more data
		DefJobRepository::Instance()->SetExtMode(true);

		SetSimStatus(Forecast::BUILD_STATUS_EXEC);
		m_SenderToGui.NotifyCBHelper("build graph begin", std::mem_fun<void, Forecast::SimGraphCB>(&Forecast::SimGraphCB::SimCB_Begin) );

		// nothing to build if graph status complete
		if (GetGraphStatus() != Forecast::BUILD_STATUS_COMPLETE)
		{	
			job_seq   = new Forecast::SingleJobExtInfoSeq; 
			job_seq->length(0);
			int rc = RunBuildGraph(job_seq);
		}

		SetSimStatus(Forecast::BUILD_STATUS_COMPLETE);
		m_SenderToGui.NotifyCBHelper("build graph end", std::mem_fun<void, Forecast::SimGraphCB>(&Forecast::SimGraphCB::SimCB_End) );
			
		// update all the dependencies of the BIM services in the simulator.
		// needed by Batch Discovery - the only user of the BuildGraphExt method.
		m_simulator->UpdateAllBimServices();
			
	}
	catch(CORBA::SystemException& se)
	{
		DIAG_PDEF(DIAG_E, "Got system exception during simulation : " << se);
		m_stopFlag = true;
		rc = -1;
		SetSimStatus(Forecast::BUILD_STATUS_ERROR);
	}
	catch(std::exception& se)
	{
		DIAG_PDEF(DIAG_E, "Got an exception during simulation : " << se.what());
		m_stopFlag = true;
		rc = -1;
		SetSimStatus(Forecast::BUILD_STATUS_ERROR);
	}
	DIAG_P(DIAGC_TIME, DIAG_I, "End: Build Graph " << m_resourceId);
}


/*virtual*/ void SimGraphI::GetBimServiceList(Forecast::OrderIdSeq_out oid_seq)
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ))
{
	DBG_FNC_ENTER("SimGraphI::GetBimServiceList");
	oid_seq = new Forecast::OrderIdSeq;
	oid_seq->length(0);

	Forecast::BuildStatusEnum simStat = SimGraphI::GetSimStatus();
	if (simStat != Forecast::BUILD_STATUS_COMPLETE || m_simulator == NULL)
	{
        DIAG_PDEF(DIAG_I, m_resourceId << " simulator didn't complete, return empty list");
		return;
	}

	m_bimServiceMgr.GetBimServiceList(oid_seq);
}

/*virtual*/ void SimGraphI::GetBimServiceLateList(Forecast::OrderIdSeq_out oid_seq)
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ))
{
	// 
	DBG_FNC_ENTER("SimGraphI::GetBimServiceLateList");
	oid_seq = new Forecast::OrderIdSeq;
	oid_seq->length(0);

	Forecast::BuildStatusEnum simStat = SimGraphI::GetSimStatus();
	if (simStat != Forecast::BUILD_STATUS_COMPLETE || m_simulator == NULL)
	{
        DIAG_PDEF(DIAG_I, m_resourceId << " simulator didn't complete, return empty list");
		return;
	}

	m_bimServiceMgr.GetBimServiceLateList(oid_seq);
}

void SimGraphI::GetJobByOid(Forecast::OrderId orderid, 	Forecast::SingleJobInfo_out   corbajob)
ACE_THROW_SPEC ((
				CORBA::SystemException
				))
{
	DBG_FNC_ENTER("SimGraphI::GetJobByOid");
	// SimGraph status validation checks
	Forecast::BuildStatusEnum graphStat = SimGraphI::GetGraphStatus();
	if (graphStat != Forecast::BUILD_STATUS_COMPLETE)
	{
		DIAG_PDEF(DIAG_I, m_resourceId << " no complete graph, fail to get job dependency list");
		// TODO: throw an exception - graph build didn't complete
	}

	if (m_simulator == NULL)
	{
		DIAG_PDEF(DIAG_E, m_resourceId << " no simulator, probably a bug");
		return;
	}

	SimulJobI * simjob =  m_simulator->GetJobByOid(orderid);
	
	corbajob = new  Forecast::SingleJobInfo();

	corbajob->Name = simjob->GetJobName().c_str();
	corbajob->Node = simjob->GetNode().c_str();
	return;
}

/*virtual*/ void SimGraphI::GetDepJobList(
	const char							*dep_type,
	Forecast::OrderId					oid,
	Forecast::OrderIdSeq_out			oid_seq)
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ))
{
	// 
	DBG_FNC_ENTER("SimGraphI::GetDepJobList");

	oid_seq = new Forecast::OrderIdSeq;
	oid_seq->length(0);

	// SimGraph status validation checks
	Forecast::BuildStatusEnum graphStat = SimGraphI::GetGraphStatus();
	if (graphStat != Forecast::BUILD_STATUS_COMPLETE)
	{
        DIAG_PDEF(DIAG_I, m_resourceId << " no complete graph, fail to get job dependency list");
		// TODO: throw an exception - graph build didn't complete
	}

	if (m_simulator == NULL)
	{
        DIAG_PDEF(DIAG_E, m_resourceId << " no simulator, probably a bug");
		return;
	}

	// generate list of depended jobs, by type of 
	if (strcmp(dep_type, "bim") == 0)
	{
		m_bimServiceMgr.GenBimIndicatorJobList(BimServiceMgr::en_IndicatorBim, oid, oid_seq);
	}
	else if (strcmp(dep_type, "bim_crit_min") == 0)
	{
		m_bimServiceMgr.GenBimIndicatorJobList(BimServiceMgr::en_IndicatorCritMin, oid, oid_seq);
	}
	else if (strcmp(dep_type, "bim_crit_all") == 0)
	{
		m_bimServiceMgr.GenBimIndicatorJobList(BimServiceMgr::en_IndicatorCritAll, oid, oid_seq);
	}
	else
	{
		DIAG_PDEF(DIAG_E, "unknown dependency check type '" << dep_type <<"'");
		// TODO: unknown dependency check, throw exception
	}
}

/*virtual*/ char *SimGraphI::GetResourceId()
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ))
{
	// 
	CORBA::String_var resId = CORBA::string_dup( m_resourceId.c_str() );
	return resId._retn();
}

//////////////////////////////////////////////////////////////////////////
// deactivate object and remove last reference
//
/*virtual*/ void SimGraphI::Destroy()
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ))
{
	DBG_FNC_ENTER("SimGraphI::Destroy");

	m_SenderToGui.Cancel();
	m_AdderToSim.Cancel();
	m_stopFlag = true;

	try
	{
		EM_ASSERT( !CORBA::is_nil(m_poa), "Doesn't have POA, must be a bug" );

		m_mySession->UnregisterAndDestroy(this, m_poa);
	}
	catch( const std::exception& e)
	{
		DIAG_PDEF(DIAG_E, "Error: " << e.what());
	}

}

//////////////////////////////////////////////////////////////////////////
//
/*virtual*/ void SimGraphI::SetSimGraphCallback(Forecast::SimGraphCB_ptr cb)
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ))
{
	ACE_Guard< ACE_Thread_Mutex > guard(m_lock);
	m_SenderToGui.SetSimGraphCallback(cb);
	m_SenderToGui.Open();
}

/*virtual*/ char * SimGraphI::GetGraphInfo (const char * attr)
ACE_THROW_SPEC ((CORBA::SystemException))
{
	DBG_FNC_ENTER("SimGraphI::GetGraphInfo ");

	ACE_Guard< ACE_Thread_Mutex > guard(m_lock);

	if (strcmp(attr,"Job Definition Size") == 0)
	{
		int nJobDefSize = GetJobDefinitionSize();

		char szJobDefSize[30];
		szJobDefSize[0] = NULL;
		ACE_OS::itoa(nJobDefSize,szJobDefSize, 10);

		CORBA::String_var sTmp = CORBA::string_dup(szJobDefSize);

		return sTmp._retn();
	}
	else if (strcmp(attr,"Summary") == 0)
	{
		std::string out;
		m_summary.Caclulate();
		m_summary.WriteToXml(out);

		if (IS_PRINTABLE_DIAG_PDEF(DIAG_I))
		{
			DIAG_PDEF(DIAG_I, "Summary:\n");

			std::ostringstream str;
			m_summary.Print(str);
			TDiag *pTheDiag = TDiag::Instance(); 
			pTheDiag->PrintDirectly(str.str().c_str());
			pTheDiag->flush(); 
		}


		CORBA::String_var sTmp = CORBA::string_dup(out.c_str());
		return sTmp._retn();
	}
	else
	{
		{
			CORBA::String_var sTmp = CORBA::string_dup("Not Implemented");	
			return sTmp;
		}
	}
}



/*virtual*/ Forecast::SimGraphCB_ptr SimGraphI::GetSimGraphCallback()
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ))
{
	ACE_Guard< ACE_Thread_Mutex > guard(m_lock);
	//return Forecast::SimGraphCB::_duplicate(m_cb);
	return m_SenderToGui.GetSimGraphCallback();
}


//New---Graph
void SimGraphI::GetValuesList (
									   const char * entityName,
									   const char * filter,
									   ::stringSeq_out values,
									   ::CORBA::Long maxValues,
									   ::CORBA::Long_out existValues
									   )
									   ACE_THROW_SPEC ((
									   CORBA::SystemException,
									   ::Forecast::SCENARIO_EXCEPTION
									   ))
{
	DBG_FNC_ENTER("SimGraphI::GetValuesList");
	DIAG_P(DIAGC_CORBA_INCOMING, DIAG_D, "entityName: " << entityName << " filter: " << filter);
	
	//out:
	values = new stringSeq;
	existValues = 0;

	std::vector<std::string> names;
	GetValuesList(entityName, names);

	existValues = names.size();
	if( maxValues >0 && (size_t)maxValues < names.size() )
	{
		names.resize(maxValues);
	}
	StlVector2CorbaSequence(names, *values);

}

//New---Simulate

//////////////////////////////////////////////////////////////////////////
//
void SimGraphI::SetScenario (
	const char * data
	)
	ACE_THROW_SPEC ((
	CORBA::SystemException,
	::Forecast::SCENARIO_EXCEPTION
	))
{
	DBG_FNC_ENTER("SimGraphI::SetScenario");
	DIAG_P(DIAGC_CORBA_INCOMING, DIAG_D, "data: " << "");

	std::string XMLData=data;
	if(XMLData.empty()==true)
	{
		throw Forecast::SCENARIO_EXCEPTION(en_SCENARIO_EXCEPTION_Error,"Scenario XML is empty");
	}

	if(XMLData.size() > (size_t)m_params.ScenarioMaxSize*1024) //in KB
	{
		throw Forecast::SCENARIO_EXCEPTION(en_SCENARIO_EXCEPTION_ScenarioMaxSize,"Scenario data size is more then 'ScenarioMaxSize' system parameter");
	}

	if (SimGraphI::GetGraphStatus() != Forecast::BUILD_STATUS_COMPLETE)
	{
		m_ScenarioXMLStr=XMLData;
		DIAG_PDEF(DIAG_I,"Forecast graph is not build/ready, only saving Scenario XML String");
		return;
	}
	//else
	try{
		LoadScenarioToGraph(XMLData);
	}
	catch(Forecast::Common::WhatIfValidationException& refEx)
	{
		LoadScenarioToGraph(m_ScenarioXMLStr);
		if(SimGraphI::GetSimStatus() == Forecast::BUILD_STATUS_COMPLETE)
			m_simulator->RunSimulation();
		throw Forecast::SCENARIO_EXCEPTION(en_SCENARIO_EXCEPTION_Error,refEx.what());
	}
	catch (Forecast::Common::FcException& refEx)
	{
		std::string err = "Not valid Scenario XML: "+std::string(refEx.what());
		throw Forecast::SCENARIO_EXCEPTION(en_SCENARIO_EXCEPTION_Error,err.c_str());
	}
	catch(std::exception& e)
	{
		throw Forecast::SCENARIO_EXCEPTION(en_SCENARIO_EXCEPTION_Error,e.what());
	}

}

void SimGraphI::LoadSystemScenario()
{
	try
	{
		Forecast::DAL::WhatIf wf(DALMgr::instance());
		RWCString scenarioData;
		wf.ReadSystemScenario(scenarioData);
		Forecast::Common::Scenario_type Scenario;
		Scenario.LoadFromXml(scenarioData.std());
		std::vector<Forecast::Common::RuleBase_type*> RuleVec;
		Scenario.GetRules(RuleVec);
		Scenario.SetRuleOwner(false);
		m_simulator->SetSystemScenario(RuleVec);
	}
	catch(Forecast::Common::WhatIfValidationException& refEx)
	{
		ThrowFatalError("build graph", 1, "Failed to read <SYSTEM> scenario, " + em::tos(refEx.what()));
	}
}

void SimGraphI::LoadScenarioToGraph(const std::string& ScenarioXMLStr)
{
	DBG_FNC_ENTER("SimGraphI::SetScenario");
	
	Forecast::Common::Scenario_type Scenario;
	Scenario.LoadFromXml(ScenarioXMLStr);
	std::vector<Forecast::Common::RuleBase_type*> RuleVec;
	Scenario.GetRules(RuleVec);
	m_simulator->SetScenario(RuleVec);
	Scenario.SetRuleOwner(false);
	m_ScenarioXMLStr=ScenarioXMLStr;
}

//////////////////////////////////////////////////////////////////////////
//
void SimGraphI::GetScenario (
	CORBA::String_out data
	)
	ACE_THROW_SPEC ((
	CORBA::SystemException,
	::Forecast::SCENARIO_EXCEPTION
	))
{
	DBG_FNC_ENTER("SimGraphI::GetScenario");

	std::string s_data;
	Forecast::Common::Scenario_type Scenario;
	Scenario.SetRuleOwner(false);
	std::vector<Forecast::Common::RuleBase_type*> RuleVec;
	m_simulator->GetScenario(RuleVec);
	Scenario.SetRules(RuleVec);
	Scenario.WriteToXml(s_data);
	data = CORBA::string_dup(s_data.c_str());

	DIAG_P(DIAGC_CORBA_INCOMING, DIAG_D, "data: " << data);
}

//////////////////////////////////////////////////////////////////////////
//
void SimGraphI::CRB_GetAllServicesInformation (
	::ECSCorbaAttrHolderSeq_out servicesList
	)
	ACE_THROW_SPEC ((
	CORBA::SystemException,
	::Forecast::GENERAL_EXCEPTION
	))
{
	DBG_FNC_ENTER("SimGraphI::CRB_GetAllServicesInformation ");
	DIAG_P(DIAGC_CORBA_INCOMING, DIAG_D, "()" );

	servicesList = new ::ECSCorbaAttrHolderSeq;

	Forecast::BuildStatusEnum simStat = SimGraphI::GetSimStatus();
	if (simStat != Forecast::BUILD_STATUS_COMPLETE || m_simulator == NULL)
	{
		DIAG_PDEF(DIAG_I, m_resourceId << " simulator didn't complete, return empty list");
		return;
	}

	m_bimServiceMgr.GetAllServicesInformation(servicesList);
}


//virtual
void SimGraphI::CRB_UpdateFilter (
					   const char * plan_filter,
					   const char * display_filter
					   )
					   ACE_THROW_SPEC ((
					   CORBA::SystemException,
					   ::Forecast::GENERAL_EXCEPTION
					   ))
{
	DBG_FNC_ENTER("SimGraphI::CRB_UpdateFilter ");
	DIAG_P(DIAGC_CORBA_INCOMING, DIAG_D, "()" );

	try
	{
		EM_ASSERT(m_SenderToGui.IsOpen(), "Sender is not open during update filter");

		SetSimStatus(Forecast::BUILD_STATUS_EXEC);
		m_SenderToGui.NotifyCBHelper("build graph begin", std::mem_fun<void, Forecast::SimGraphCB>(&Forecast::SimGraphCB::SimCB_Begin) );

		//set new filter
		SetPlanFilterStr(plan_filter);
		SetDisplayFilterStr(display_filter);

		//Filter flags
		bool bDcMatch = true;
		bool bTblMatch = true;
		bool bUDMatch = true;

		//* traverse through all jobs in simulator
		for( AutoIter<DataCenterI>  dc_iter = m_simulator->GetDataCenterIter(); dc_iter.HasMore(); ++dc_iter )
		{
			DataCenterI* dc = *dc_iter;
			const std::string& dc_name = dc->GetDataCenterName();
		
			bDcMatch = m_Matcher.DatacenterDoesItMatch(dc_name);

			int totalJobSent =0;

			const bsm::DefTableInfos& defTables = DefJobRepository::Instance()->GetDefTables();
			for( bsm::DefTableInfos::const_iterator tbl_it = defTables.begin(), tbl_it_end = defTables.end(); 
				tbl_it != tbl_it_end; ++tbl_it)
			{
				const bsm::DefTableInfo& defTableInfo = *tbl_it;
				const std::string& table_name = defTableInfo.m_SchedTable;
				const std::string& table_lib = defTableInfo.m_DSN;
				const std::string& table_dc_name = defTableInfo.m_DataCenter;
				if( table_dc_name != dc_name )
					continue;

				bTblMatch = m_Matcher.IsTableAuthorized(defTableInfo, BROWSE_ACCESS);

				// get iterator for all simulation job belonging to the table
				AutoIter<SimulJobI> job_it = dc->GetSimulJobsItersByTableNameAndLib(table_name, table_lib);
				if( !job_it.IsValid() )
				{
					continue; //the table is not found in simulator, probably it is new table.
				}

				// traverse through all table's job to find corresponding db-job 
				std::vector< bool > jobdefsSend( job_it.Size(), false );
				std::vector< size_t > joboidSend( job_it.Size(), 0 );
				bsm::DefJobVec jobdefs( job_it.Size(), NULL ); //will be formed due existed simulation job

				bool isMemberSigned = false;
				int grp_pos = 0;
				SimulJobI* grp_job = NULL;
				for( int i=0; job_it.HasMore(); ++job_it, ++i)
				{
					SimulJobI* sim_job = *job_it;

					//* get DefJob from Repository by table_id and job_id
					int table_id	= defTableInfo.m_Table_ID;
					int job_id		= sim_job->GetJobId();
					bsm::DefJob* dbjob = DefJobRepository::Instance()->GetDefJobsByTableAndJobId(table_id, job_id);
					if( dbjob == NULL)
					{
						// db-job is not found in repository, probably definition were changed
						DIAG_PDEF(DIAG_I, "Def job is not found by table_id: " << table_id  << " and job_id: " << em::tos(job_id) );
						continue; 
					}

					jobdefs[i] = dbjob;
					joboidSend[i] = sim_job->GetOrderID();

					bTblMatch = m_Matcher.TableDoesItMatch(defTableInfo.m_SchedTable);
					bUDMatch = m_Matcher.UserDailyDoesItMatch(defTableInfo.m_User_Daily);
					bool bTableAuthorized = m_Matcher.IsTableAuthorized(defTableInfo, BROWSE_ACCESS);

					// filter job
					bool bPassedFilter = bTableAuthorized 
						&& bDcMatch 
						&& bTblMatch 
						&& m_Matcher.DisplayDoesItFit(*dbjob)
						;

					DIAG_PDEF( DIAG_D, "job " << dbjob->GetName() << " is passed filter: " << bPassedFilter );

					//* set new Signed value for simulation job
					sim_job->SetSigned(bPassedFilter);
					jobdefsSend[i] = bPassedFilter;

					if( bPassedFilter )
						isMemberSigned = true;

					//store the group job position to swap it to first place
					if( dynamic_cast< SchedGroupI*>(sim_job) != NULL )
					{
						grp_job = const_cast<SimulJobI*>(sim_job);
						grp_pos = i;
					}

				} //end for tables's job

				if( grp_pos != 0 )
				{
					std::swap( jobdefs[0], jobdefs[grp_pos]);
					std::swap( joboidSend[0], joboidSend[grp_pos]);
					//std::swap( jobdefsSend[0], jobdefsSend[grp_pos]); //std::swap cannot work with std::vector<bool>
					bool tmp = jobdefsSend[0]; jobdefsSend[0] = jobdefsSend[grp_pos]; jobdefsSend[grp_pos] = tmp;
				}

				//force signing the parent group in case if one of its member is signed
				if( isMemberSigned && grp_job != NULL)
				{
					grp_job->SetSigned( true );
					jobdefsSend[0] = true; //the group is first job in the table
				}

				int n = BooleanCount( jobdefsSend, true );
				totalJobSent += n;
				if( n > 0 )
				{
					m_SenderToGui.AddDefJobs(defTableInfo, jobdefs, jobdefsSend, joboidSend, n, 
						m_GlobalCondSearcher, dc_name);
				}

			} //end for tables

			DIAG_PDEF( DIAG_D, "new number of signed jobs for DC: " << dc_name << " = " << totalJobSent );
			dc->SetNumOfSignedJobs(totalJobSent);
		
		} //end for dc


		//* send end message 
		m_SenderToGui.NotifyCBHelper("build graph end",	std::mem_fun<void, Forecast::SimGraphCB>(&Forecast::SimGraphCB::SimCB_End) );
		m_SenderToGui.NotifyCBHelper("simulation begin", std::mem_fun<void, Forecast::SimGraphCB>(&Forecast::SimGraphCB::SimCB_Begin) );
		//dummy calculation, but we need update services because signing
		m_bimServiceMgr.Calculate();
		m_SenderToGui.NotifyCBHelper("simulation end", std::mem_fun<void, Forecast::SimGraphCB>(&Forecast::SimGraphCB::SimCB_End) );

		SetSimStatus(Forecast::BUILD_STATUS_COMPLETE);
	}
	catch (const std::exception& e)
	{
		std::string errMsg = "exception during filter update: " +  em::tos(e.what());
		DIAG_PDEF(DIAG_E, errMsg);
		m_SenderToGui.NotifyCBErrorMessage("update filter", 1, errMsg.c_str(), true); //true is fatal error

		throw Forecast::GENERAL_EXCEPTION( errMsg.c_str() );
	}

}


//////////////////////////////////////////////////////////////////////////
//
void SimGraphI::GetSimParameters (
	CORBA::String_out crb_xml
	)
	ACE_THROW_SPEC ((
	CORBA::SystemException
	))
{
	DBG_FNC_ENTER("SimGraphI::GetSimParameters");

	ACE_Guard< ACE_Thread_Mutex > guard(m_lock);

	DIAG_P(DIAGC_CORBA_INCOMING, DIAG_D, "()" );

	std::string str_xml;

	try {
		str_xml = m_params.ToXml();
	}
	catch( const EmException& e)
	{
		DIAG_PDEF(DIAG_E, "Error parameters get: " << e.what());
	}

	CRB::Convert(str_xml,crb_xml);
}

//////////////////////////////////////////////////////////////////////////
//
void SimGraphI::SetSimParameters (
						const char* xml
						)
						ACE_THROW_SPEC ((
						CORBA::SystemException
						))
{

	DBG_FNC_ENTER("SimGraphI::SetSimParameters");

	ACE_Guard< ACE_Thread_Mutex > guard(m_lock);

	DIAG_P(DIAGC_CORBA_INCOMING, DIAG_D, "()" );

	try 
	{
		m_params.LoadFromXml(xml);
		static char *IGNORE_GC = getenv("IGNORE_GC");

		// enable dc filter (perform forecast on selected DC only)
		if (m_params.IgnoreGlobalConditions || IGNORE_GC)
			m_bFilterDc = true;

		// it has to be called before build graph!!!
		DefJobRepository::Instance()->SetConfiguration(m_params); 
	}
	catch( const EmException& e)
	{
		DIAG_PDEF(DIAG_E, "Error parameters set: " << e.what());
	}
}


//------





const std::string& SimGraphI::GetPlanOrderDateStr() const
{
	return m_planOrderDateStr;
}

void SimGraphI::SetPlanOrderDateStr(const std::string& odate)
{
	m_planOrderDateStr = odate;
	m_simulator->SetPlanOrderDateStr(odate);
}

void SimGraphI::SetPlanFilterStr(const std::string& filt)
{
	m_Matcher.SetPlanFilterStr(filt);
}


void SimGraphI::SetDisplayFilterStr(const std::string& filt)
{
	m_Matcher.SetDisplayFilterStr(filt);
}

int SimGraphI::WaitTillAllTasksComplete()
{
	m_stopFlag = true;
	m_simRunner.wait();
	m_SenderToGui.CloseAndWait(); //send end marker and wait to completion, after this is's impossible to send message to GUI
	return 0;
}

void SimGraphI::SetGraphStatus(Forecast::BuildStatusEnum e)
{
	ACE_Guard< ACE_Thread_Mutex > guard(m_lock);
	m_graphStatus = e;
}

void SimGraphI::SetSimStatus(Forecast::BuildStatusEnum e)
{
	ACE_Guard< ACE_Thread_Mutex > guard(m_lock);
	m_simStatus = e;
}

/*virtual*/ int SimGraphI::RunSimulation()
{
	// 
    DBG_FNC_ENTER("SimGraphI::RunSimulation");
	EM_PROFILER_FUNC;

	bsm::MemoryWatcher memoryWatcher;
	memoryWatcher.Start();

	CountScope runSimCount(m_gTotalRunSim);
	DIAG_P(DIAGC_TIME, DIAG_I, "Start: RunSimulation " << m_resourceId);
	
	int rc = -1; //will be 0 in case success
	
	std::string  exceptionMsg = ""; //no error by default
	try
	{
		SetSimStatus(Forecast::BUILD_STATUS_EXEC);
		m_SenderToGui.NotifyCBHelper("simulation begin", std::mem_fun<void, Forecast::SimGraphCB>(&Forecast::SimGraphCB::SimCB_Begin) );

		// nothing to build if graph status complete
		if (GetGraphStatus() != Forecast::BUILD_STATUS_COMPLETE)
		{
			RunBuildGraph(NULL);
		}

		m_simulator->RunSimulation();

		SetSimStatus(Forecast::BUILD_STATUS_COMPLETE);

		m_bimServiceMgr.Calculate();

		m_SenderToGui.NotifyCBHelper("simulation end", std::mem_fun<void, Forecast::SimGraphCB>(&Forecast::SimGraphCB::SimCB_End) );

		rc = 0;
	}
	catch(CORBA::SystemException& se)
	{
		exceptionMsg = "Got system exception during simulation : " + em::tos(se);
	}
	catch( const Forecast::Common::FcException& e)
	{
		exceptionMsg = "Got Forecast exception: " + em::tos(e.what());
		m_SenderToGui.NotifyCBErrorMessage("Run Simulation", 1, exceptionMsg, true);
	}
	catch( const FatalError&  )
	{
		//do nothing -- error handling was in ThrowFatalError
	}
	catch( const EmException& e )
	{
		exceptionMsg = "Got EM exception: " + em::tos(e.what());
		m_SenderToGui.NotifyCBErrorMessage("Run Simulation", 1, exceptionMsg, true);
	}

	if( rc != 0 )
	{
		DIAG_PDEF( DIAG_D, exceptionMsg );
		m_stopFlag = true;
		SetSimStatus(Forecast::BUILD_STATUS_ERROR);
	}
	DIAG_P(DIAGC_TIME, DIAG_I, "End: RunSimulation " << m_resourceId);

	EM_PROFILER_FUNC_STOP; //to include this function in the latest report as well
	em::ProfilerMgr::Instance()->Reset();

	memoryWatcher.Stop();
	DIAG_P(DIAGC_BIM, DIAG_I, "SimAllocated: " << memoryWatcher.GetSize() << " in " << memoryWatcher.GetCount() << " blocks " )
	
	std::pair< size_t, size_t > size_count = bsm::GetTotalMemoryInUse();
	DIAG_P(DIAGC_BIM, DIAG_I, "Total allocated so far: " << size_count.first << " in " << size_count.second << " blocks " );
	
	return rc;
}


int SimGraphI::RunBuildGraph(Forecast::SingleJobExtInfoSeq * extjob_seq)
{
	// 
	DBG_FNC_ENTER("SimGraphI::RunBuildGraph");
	EM_PROFILER_FUNC;
	EM_PROFILER_MANUAL(P_BuildGraph);
	EM_PROFILER_MANUAL(P_Plan);
	EM_PROFILER_MANUAL(P_AddToSimulator);
	EM_PROFILER_MANUAL(P_DataLoad);
	EM_PROFILER_MANUAL(P_SendToGUI);
	EM_PROFILER_MANUAL(P_LoadStatFromDb);

	EM_ASSERT (m_simulator != NULL, "simulation engine doesn't exist");

	DIAG_P(DIAGC_TIME, DIAG_I, "Start: BuildGraph" << m_resourceId);

	EM_PROFILER_MANUAL_START(P_BuildGraph);

	SetGraphStatus(Forecast::BUILD_STATUS_EXEC);
	m_SenderToGui.NotifyCBHelper("graph begin", std::mem_fun<void, Forecast::SimGraphCB>(&Forecast::SimGraphCB::GraphCB_Begin));

	//T: Explicitly disable assumptions
	TraceAssumptionsMap::Instance()->SetTrace(false);
	
	m_LastReport.Init();

	//
	// update the def repository, lock it for read and check if there are no any errors
	//
	DefJobRepository::Instance()->Update(); 
	DefJobRepositoryAutoReadLocker aDefJobRepositoryAutoReadLocker; //lock our repository for read until end of function
	if( DefJobRepository::Instance()->IsError() )
	{
		ThrowFatalError("Read jobs", 1, "error during job definitions read");
	}

	//
	//start a separate thread to add new jobs to the simulator.
	// it will be close near end of this function
	//
	m_AdderToSim.Open(); 

	// Progress time indicator
	time_t progressUpdateTime = time(0); 

	// reference the DataAccessLayer and allocate database connection for the next db access
	Definition defDal(DALMgr::instance());
	RWDBConnection conn = DALMgr::instance()->GetConnection();

	const bsm::DefTableInfos& defTables = DefJobRepository::Instance()->GetDefTables();

	ReadCalendarInformation();

	// read system state information
	DIAG_PDEF(DIAG_D, m_resourceId << ": read system state information");
	Forecast::DAL::SimSystemState simSystemState( DALMgr::instance() );

	Forecast::DAL::SimSystemState::DataCenterMap dataCenterMap;
	if(extjob_seq){
		//For Batch Discovery
		simSystemState.ReadAllDataCenters(dataCenterMap, &conn);
	}
	else{
		simSystemState.ReadFullDataCenterInfo(dataCenterMap, &conn);
	}

	m_LastReport.m_MaxRunSims = m_gMaxRunSim.value();
	m_LastReport.m_MaxTotalJobsInSimGraph = m_gMaxTotalJobsInSimGraph.value();

	m_simulator->SetPeriodicStatsGetter(&m_periodicStatsGetterImpl);
	m_simulator->SetSimulStep(m_params.SimulatorEngineStep);
	m_simulator->SetNumberOfDaysToSimulate(m_params.MaxSimulationDays);
	m_simulator->SetNumberOfSimulationThreads(m_params.MaxNumDetectThreads);

	const Definition::CommDomVec& commVec = DefJobRepository::Instance()->GetDataCenters();

	FillEngineWithDatacenterInformation(commVec);

	LoadQuantitativeResources(defDal, commVec);

	SetupGlobalConditionPrefixSearcher(defDal, commVec);

	// set dbjob planner
	DBJobPlanner planner;
	planner.SetCalendarDefCached(&m_calendarCache);

	DataCenterUserDailyVec dy_user_daily_to_process;
	DataCenterUserDailyVec dy_user_daily_processed;

	// table progress counters
	int progressMaxPos = 0;
	int progressCurPos = 0;

	// job processing & display counters
	m_totalJobsInSimGraph = 0;
	unsigned int totalJobSent = 0;
	long totalJobsProcessed = 0;

	//Filter flags
	bool bDcMatch = true;
	bool bTblMatch = true;
	bool bUDMatch = true;

	do 
	{
		// clear the list of dynamic user daily, we fill it up while processing jobs
		dy_user_daily_to_process.clear();

		// count number of tables we will process
		progressMaxPos += CountNumberOfTablesToProcess(dataCenterMap);
		m_SenderToGui.UpdateCBWithProgress("planning", progressUpdateTime, progressCurPos, progressMaxPos, true);

		// for-each datacenter
		for (Forecast::DAL::SimSystemState::DataCenterMap::iterator dcIt = dataCenterMap.begin()
			; dcIt != dataCenterMap.end() && !m_stopFlag
			; ++dcIt)
		{
			const std::string& data_center = (*dcIt).first;

			bDcMatch = m_Matcher.DatacenterDoesItMatch(data_center);

			if(m_bFilterDc == true && bDcMatch ==  false)
			{
				continue;
			}
			Forecast::DAL::SimSystemState::UserDailyMap& user_dailyMap = (*dcIt).second;

			// set data center information into the planner
			planner.SetDataCenterName( data_center );
			// scan comm, for each datacenter add SYSTEM user daily
			DCLookup dc(data_center);
			Definition::CommDomVec::const_iterator it = std::find_if(commVec.begin(), commVec.end(), dc);
			if ( it == commVec.end() )
			{
				planner.SetFirstDayOfTheWeek(dy_cb_base::eMONDAY);
			}
			else
			{
				planner.SetFirstDayOfTheWeek(it->start_day_of_week());
			}
			// set plan system features by platform
			if (it->platform() == "MVS")
				planner.SetPlanSystemSettings(dy_planner::MVS_PLAN_SYSTEM);
			else
				planner.SetPlanSystemSettings(dy_planner::MPM_PLAN_SYSTEM);

			// for-each user daily
			for (Forecast::DAL::SimSystemState::UserDailyMap::iterator udIt = user_dailyMap.begin()
				; udIt != user_dailyMap.end() && !m_stopFlag
				; ++udIt)
			{
				const std::string& user_daily = (*udIt).first;
				Forecast::DAL::SimSystemState::TimeTableIdsPair udTimeTableIds = (*udIt).second;
				const std::string& user_dailyTime = udTimeTableIds.first;
				Forecast::DAL::SimSystemState::TableIdVec& table_ids = udTimeTableIds.second;

				// remember which user daily we processed
				dy_user_daily_processed.push_back( std::make_pair( data_center, user_daily ) );

				// user user daily information into the simulator engine
				if (user_daily != "SYSTEM")
				{
					m_simulator->UpdateUserDaily(data_center, user_daily, user_dailyTime);
				}

				size_t lastGroupOrderId(0);
				// foreach table id
				for (Forecast::DAL::SimSystemState::TableIdVec::iterator idIt = table_ids.begin()
					; idIt != table_ids.end() && !m_stopFlag
					; ++idIt)
				{

					//TODO: REFACT: handle one scheduler table
					int table_id = (*idIt);

					DIAG_PDEF(DIAG_I, "Graph " << m_resourceId 
						<< " datacenter: " << data_center 
						<< " user daily: " << user_daily 
						<< " table id: " << table_id
						);

					// update callback with progress information
					++progressCurPos;
					m_SenderToGui.UpdateCBWithProgress("planning", progressUpdateTime, progressCurPos, progressMaxPos);


					bsm::DefJobVec jobdefs;
					DefJobRepository::Instance()->GetDefJobsByTableId( table_id, jobdefs );

					planner.InitPlan( GetPlanOrderDateStr() );

					// find table definition by table_id
					DefTableFields_TableIdLookup defTableLookup(table_id);
					bsm::DefTableInfos::const_iterator defTableIt = std::find_if(defTables.begin(), defTables.end(), defTableLookup);
					if (defTableIt == defTables.end())
					{
						DIAG_PDEF(DIAG_E, "table id " << table_id << ", not found, must be a bug! (skip to next table)");
						continue;
					}
					const DefTableFields& deftblFields = (*defTableIt);
					bTblMatch = m_Matcher.TableDoesItMatch(deftblFields.m_SchedTable);

					bUDMatch = m_Matcher.UserDailyDoesItMatch(deftblFields.m_User_Daily);
					if (bUDMatch == false)
						continue;

					// check security filter
					bool bTableAuthorized = m_Matcher.IsTableAuthorized(deftblFields, BROWSE_ACCESS);

					// manage scheduling group information
					lastGroupOrderId = 0;
					bool bSchedulingGroupTbl = false;
					std::vector< bool > jobdefsSend( jobdefs.size(), false );
					std::vector< size_t > joboidSend( jobdefs.size(), 0 );

					DIAG_PDEF(DIAG_D, m_resourceId << ": Check planning for table id " 
						<< table_id << " (" << jobdefs.size() << " jobs)");


					long totalJobsFromTable = 0;
					ACE_Time_Value planningStartTime( ACE_OS::gettimeofday() );
					for (size_t i = 0; i != jobdefs.size() ; ++i)
					{
						bsm::DefJob& dbjob = *jobdefs[i];
						bool bSchedulingGroupJob = false;

						if (i == 0)
						{
							// check if this is a scheduling group
							if (dbjob.Base().f_DBF_DEF_JOB_TASK_TYPE == "Scheduling Group")
							{
								bSchedulingGroupTbl = true;
								bSchedulingGroupJob = true;
								lastGroupOrderId = m_nextOrderId;
								DIAG_PDEF(DIAG_D, m_resourceId << ": table id " << table_id << " is a scheduling group");
							}
						}

						// plan job
						DIAG_PDEF(DIAG_D, m_resourceId << ": plan job information for table id " 
							<< table_id << ", job id " << dbjob.Base().f_DBF_DEF_JOB_JOB_ID );

						// count number of jobs we processed
						++totalJobsProcessed;

						bool bJobOrdered = true;

						if(!extjob_seq)
						{
							//For Forecast
							EM_PROFILER_MANUAL_START(P_Plan);
							bJobOrdered = planner.ProcessDBJob(dbjob);
							EM_PROFILER_MANUAL_STOP(P_Plan);
						}

						if (!bJobOrdered) 
						{
							// if this is a scheduling group we don't need to check the reset of the table
							if (i==0 && bSchedulingGroupTbl == true)
							{
								DIAG_PDEF(DIAG_D, m_resourceId << ": sched group is not ordered, we skip all table");
								jobdefsSend.clear();
								joboidSend.clear();
								// skip table
								break;
							}

							// skip to next job
							continue;
						}

						// Get parsed command type jobs for user daily commands
						std::string JobToOrderName = dbjob.GetUserDailyNameToOrder();
						if ( !JobToOrderName.empty() ) //the job has some user daily
						{
							DIAG_PDEF(DIAG_D, std::string("job ") + dbjob.GetName() + " orders table " +  JobToOrderName);
							ProcessJobDynamicUserDaily( JobToOrderName, user_dailyMap, data_center, dy_user_daily_processed, dy_user_daily_to_process );
						}

						// setup order id for this job
						size_t jobOrderId = m_nextOrderId++;
						DIAG_PDEF(DIAG_D, m_resourceId << ": job is ordered with oid = " << jobOrderId);

						// filter job
						bool bPassedFilter = bTableAuthorized 
							&& bDcMatch 
							&& bTblMatch 
							&& m_Matcher.DisplayDoesItFit(dbjob)
							;


						joboidSend[i] = jobOrderId;
						jobdefsSend[i] = bPassedFilter;
						
						//put the dbjob in queue for adding to the simulator in another thread
						{  
							EM_PROFILER_SCOPE(P_AddToSimulator_0);
		
							m_AdderToSim.Put( new 
								SimGraphI_AddToSim::Message_AddToSimulator(
							dbjob, 
							jobOrderId,
								bSchedulingGroupJob ? 0 : lastGroupOrderId,//for scheduled group the group id is 0
							planner.GetNextOrderDay(),
							planner.GetPrevOredrDay(),
							user_daily,
							deftblFields,
							bPassedFilter,
								m_params.UseDoConditions,
								extjob_seq)
							);

						}

						++m_totalJobsInSimGraph;
						++totalJobsFromTable;

					} // for-each job definitions

					if (totalJobsFromTable > 0)
					{
						// update global counter
						m_gTotalJobsInSimGraph += totalJobsFromTable;
					}

					size_t n = BooleanCount(jobdefsSend, true);

					if (n > 0)
					{
						//if the table is a scheduling group we must verify the scheduled group job is send/signed
							if(bSchedulingGroupTbl==true && jobdefsSend[0]==false)
							{
								++n;
								m_simulator->SetJobSign(JobFindHint(lastGroupOrderId,(*dcIt).first,true),true);
								jobdefsSend[0]=true;
							}

						m_SenderToGui.AddDefJobs(deftblFields, jobdefs, jobdefsSend, joboidSend, n, 
							m_GlobalCondSearcher, data_center);

								// force progress update
						m_SenderToGui.UpdateCBWithProgress("planning", progressUpdateTime, progressCurPos, progressMaxPos, true);

							// count number of jobs sent
							totalJobSent += n;
					}


				} // for-each table definition
			} // for-each user daily
		} // for-each datacenter

		dataCenterMap.clear();

		ProcessDynamicUserDailyInformation(dy_user_daily_to_process, defTables, dataCenterMap);

	} while (m_stopFlag == false && !dy_user_daily_to_process.empty());



	DIAG_PDEF(DIAG_I, "wait until finish adding to sim and close those working thread" << m_resourceId);
	m_AdderToSim.CloseAndWait(); 
	DIAG_PDEF(DIAG_I, "all jobs were added to the simulator" << m_resourceId);
	//Distribute global conditions - 
	//must be called after all jobs where loaded and the global conditions rules where loaded  
	LoadSystemScenario();
	m_simulator->DistributeAndCalcOrpahnCondsForAllDc();

	// in case we stopped by request
	if (m_stopFlag == true)
	{
		SetGraphStatus(Forecast::BUILD_STATUS_ERROR);
		DIAG_PDEF(DIAG_I, m_resourceId << ": Stop flag was raised, planning was stopped");
		return -1;
	}

	try{
		if( !m_ScenarioXMLStr.empty() )
	{
			DIAG_PDEF(DIAG_D, "Load Scenario To Graph");
			LoadScenarioToGraph(m_ScenarioXMLStr);
	}
	}
	catch(Forecast::Common::WhatIfValidationException& /*refEx*/)
	{
		//yoel todo
		m_ScenarioXMLStr.clear();
	}
	catch (Forecast::Common::FcException& /*refEx*/)
	{
		//yoel todo
		m_ScenarioXMLStr.clear();
	}

	SetGraphStatus(Forecast::BUILD_STATUS_COMPLETE);
	m_SenderToGui.NotifyCBHelper("graph end",std::mem_fun<void, Forecast::SimGraphCB>(&Forecast::SimGraphCB::GraphCB_End));

	//cleaning. should be last step (m_AdderToSim uses its)
	m_simulator->SetPeriodicStatsGetter(NULL);

	EM_PROFILER_MANUAL_STOP(P_BuildGraph);

	m_LastReport.m_LapTime=	EM_PROFILER_MANUAL_LAP_STRING(P_BuildGraph);
	m_LastReport.m_totalJobsProcessed=totalJobsProcessed;
	m_LastReport.m_PlanLapTime= EM_PROFILER_MANUAL_LAP_STRING(P_Plan);
	m_LastReport.m_LoadToGraphLapTime= EM_PROFILER_MANUAL_LAP_STRING(P_AddToSimulator);
	m_LastReport.m_DbLapTime= EM_PROFILER_MANUAL_LAP_STRING(P_DataLoad); 
	m_LastReport.m_CrbLapTime= EM_PROFILER_MANUAL_LAP_STRING(P_SendToGUI);
	m_LastReport.m_JobStatLoadLapTime= EM_PROFILER_MANUAL_LAP_STRING(P_LoadStatFromDb);
	m_LastReport.m_JobsSent=totalJobSent;
	m_LastReport.m_JobsInGraph=m_totalJobsInSimGraph;
	DIAG_P(DIAGC_TIME, DIAG_I, "End: BuildGraph" << m_resourceId);
	if (IS_PRINTABLE_DIAG_P(DIAGC_BIM, DIAG_I))
	{
		std::ostringstream Report;
		GetLastReport(Report);
		DIAG_P(DIAGC_BIM, DIAG_I,Report.str().c_str());
	}

	return 0;
}

void SimGraphI::GetLastReport(std::ostringstream& Rep)
{
	Rep<<std::endl<<"("<<m_LastReport.m_ReportTime.to_string("%d/%m/%Y %H:%M:%S:%q")
				<<") Report Build Graph : LapTime="<<m_LastReport.m_LapTime
		<<" TotalJobsProcessed="<<m_LastReport.m_totalJobsProcessed
		<<" JobsInGraph="<<m_LastReport.m_JobsInGraph
				<<" MaxTotalJobsInGraph="<<m_LastReport.m_MaxTotalJobsInSimGraph
				<<" MaxRunSimul="<<m_LastReport.m_MaxRunSims
		<<" DBaccess="<<m_LastReport.m_DbLapTime
		<<" Planning="<<m_LastReport.m_PlanLapTime
		<<" LoadToGraph="<<m_LastReport.m_LoadToGraphLapTime
		<<" Sending="<<m_LastReport.m_CrbLapTime
		<<" JobsSent="<<m_LastReport.m_JobsSent
		<<" LoadStatFromDb="<<m_LastReport.m_JobStatLoadLapTime
		;
}

void SimGraphI::ConstructResourceId()
{
	// setup SimGraphI resource id string
	DBG_FNC_ENTER("SimGraphI::ConstructResourceId");
	m_resourceId = "SimGraph:";
	size_t newId = m_gNextSimGraphId++;
	char szId[20] = {0};
	ACE_OS::itoa(newId, szId, 10);// 32_TO_64: Need to have ltoa 
	m_resourceId += szId;
}

void SimGraphI::SetSession(Session* s)
{
	DBG_FNC_ENTER("SimGraphI::SetSession");
	EM_ASSERT( "s != 0", "setting null session" );

	if( m_mySession )
	{
		m_mySession->Unregister(this, m_poa);
	}
	m_mySession = s;
	m_mySession->Register(this, m_poa);

	m_Matcher.SetSession(m_mySession);
}

Session* SimGraphI::GetSession()
{
	return m_mySession;
}

/*virtual*/ void SimGraphI::SetTraceOrderIds(const Forecast::OrderIdSeq & oid_seq) 
	ACE_THROW_SPEC ((CORBA::SystemException))
{
    DBG_FNC_ENTER("SimGraphI::SetTraceOrderIds");
	Forecast::BuildStatusEnum simStat = SimGraphI::GetSimStatus();
	if (simStat == Forecast::BUILD_STATUS_EXEC)
	{
        DIAG_PDEF(DIAG_I, m_resourceId << " simulator executed, can't set trace order ids");
		return;
	}

	if (m_simulator == NULL)
	{
		DIAG_PDEF(DIAG_I, m_resourceId << " no simulator was allocated");
		return;
	}

	std::vector< size_t > ids;
	CORBA::ULong len = oid_seq.length();
	for (CORBA::ULong i = 0; i < len; ++i)
	{
		ids.push_back(oid_seq[i]);
	}

	ACE_Guard< ACE_Thread_Mutex > guard(m_lock);
	m_simulator->SetTraceTojobs(ids);
}

/*virtual*/ Forecast::OrderIdSeq * SimGraphI::GetTraceOrderIds()
	ACE_THROW_SPEC((CORBA::SystemException))
{
    DBG_FNC_ENTER("SimGraphI::GetTraceOrderIds");
	Forecast::OrderIdSeq_var oid_seq = new Forecast::OrderIdSeq();
	Forecast::BuildStatusEnum simStat = SimGraphI::GetSimStatus();
	if (simStat == Forecast::BUILD_STATUS_EXEC)
	{
        DIAG_PDEF(DIAG_I, m_resourceId << " simulator executed, return empty list");
		return oid_seq.out();
	}

	if (m_simulator == NULL)
	{
		DIAG_PDEF(DIAG_I, m_resourceId << " no simulator was allocated");
		return oid_seq.out();
	}

	ACE_Guard< ACE_Thread_Mutex > guard(m_lock);
	std::vector< SimulJobI* >& ids = m_simulator->GetTraceJobsVec();
	oid_seq->length((CORBA::ULong)ids.size());
	for (CORBA::ULong i = 0; i < ids.size(); ++i)
	{
		SimulJobI* pJob = ids[i];
		oid_seq[i] = pJob->GetOrderID();// 32_TO_64: TODO: when EM clients support 64-bit,
										// OrderId in forecast's IDLs should be defined as a 64-bit variable
										// (CORBA::ULongLong - ?)
	}
	return oid_seq.out();
}

/*virtual*/ CORBA::Boolean SimGraphI::GetTraceInfo(
	Forecast::OrderId oid,
	CORBA::Long       Version,
	CORBA::String_out traceInfoAsXml
	) ACE_THROW_SPEC((CORBA::SystemException))
{
    DBG_FNC_ENTER("SimGraphI::GetTraceInfo");
	Forecast::BuildStatusEnum simStat = SimGraphI::GetSimStatus();
	if (simStat == Forecast::BUILD_STATUS_EXEC)
	{
        DIAG_PDEF(DIAG_I, m_resourceId << " simulator executed, can't clear trace results");
		traceInfoAsXml = CORBA::string_dup("");
		return false;
	}

	if (m_simulator == NULL)
	{
		DIAG_PDEF(DIAG_I, m_resourceId << " no simulator was allocated");
		traceInfoAsXml = CORBA::string_dup("");
		return false;
	}

	// TODO: lookup oid in simulator and get simulation result for oid as xml
	ACE_Guard< ACE_Thread_Mutex > guard(m_lock);
	std::vector< SimulJobI* >& ids = m_simulator->GetTraceJobsVec();
	SimulJobI* pJob = NULL;
	for (size_t i = 0; pJob == NULL && i < ids.size(); ++i)
	{
		SimulJobI* tmpJob = ids[i];
		if (tmpJob->GetOrderID()  == oid)
		{
			pJob = tmpJob;
		}
	}
	
	if (pJob == NULL)
	{
		// job not found or no log
		traceInfoAsXml = CORBA::string_dup("");
		return false;
	}

	// get job WhyLog information as xml
	
	std::ostringstream oss;
	pJob->DumpTraceAsXml(oss,Version);
	std::string xmlLog = oss.str();
	traceInfoAsXml = CORBA::string_dup(xmlLog.c_str());
	if (IS_PRINTABLE_DIAG_PDEF(DIAG_I))
	{
		DIAG_PDEF(DIAG_I, "Why as xml for job " << pJob->GetOrderID() << ":\n");

		oss << "\n" << std::endl;
		TDiag *pTheDiag = TDiag::Instance(); 
		pTheDiag->PrintDirectly(oss.str().c_str());
		pTheDiag->flush(); 
	}

	return true;
}

/*virtual*/ void SimGraphI::ClearTraceInfo() ACE_THROW_SPEC((CORBA::SystemException))
{
	// engine - release trace information 
    DBG_FNC_ENTER("SimGraphI::ClearTraceInfo");
	Forecast::BuildStatusEnum simStat = SimGraphI::GetSimStatus();
	if (simStat == Forecast::BUILD_STATUS_EXEC)
	{
        DIAG_PDEF(DIAG_I, m_resourceId << " simulator executed, can't clear trace results");
		return;
	}

	if (m_simulator == NULL)
	{
		DIAG_PDEF(DIAG_I, m_resourceId << " no simulator was allocated");
		return;
	}
	
	ACE_Guard< ACE_Thread_Mutex > guard(m_lock);
	m_simulator->ClearJobTrace();
}


int SimGraphI::GetJobDefinitionSize()
{
	Definition defDal(DALMgr::instance());

	int nJobDefSize = defDal.GetJobDefinitionSize();

	return nJobDefSize;
}


//////////////////////////////////////////////////////////////////////////
//
void SimGraphI::GetValuesList( const std::string& entityName, std::vector<std::string>& names )
{
	DBG_FNC_ENTER("SimGraphI::GetValuesList");

	AutoIter<DataCenterI>  DcIter=m_simulator->GetDataCenterIter();

	while(*DcIter!=NULL)
	{
		if(0); //switch by entity name
		else if( entityName == Forecast::Graph::en_entityDataCenter )
		{
			names.push_back((*DcIter)->GetDataCenterName());
		}
		else if( entityName == Forecast::Graph::en_entityQuantityResource )
		{
			(*DcIter)->GetQuantityResourceNameList(names);
		}
		else if( entityName == Forecast::Graph::en_entityControlResource)
		{
			(*DcIter)->GetControlResourceNameList(names);
		}
		else if( entityName == Forecast::Graph::en_entityApplication)
		{
			(*DcIter)->GetApplicationNameList(names);
		}
		else if( entityName == Forecast::Graph::en_entityGroup)
		{
			(*DcIter)->GetGroupNameList(names);
		}
		else if( entityName == Forecast::Graph::en_entitySchedTable)
		{
			(*DcIter)->GetSchedTableNameList(names);
		}

		++DcIter;
	}

	//remove duplicated 
	std::sort(names.begin(), names.end());
	std::vector<std::string>::iterator e = std::unique(names.begin(), names.end());
	names.erase(e, names.end());
}

//////////////////////////////////////////////////////////////////////////
//
void SimGraphI::SetupGlobalConditionPrefixSearcher(
	Definition& defDal,
	const Definition::CommDomVec& commVec)
{
	DBG_FNC_ENTER("SimGraphI::SetupGlobalConditionPrefixSearcher");

	RWDBConnection conn = DALMgr::instance()->GetConnection();

	// read global condition prefixes, and add them to the engine
	Forecast::DAL::GlobalCondVec globalCondVec;
	int rc = defDal.ReadGlobalCondList(globalCondVec, &conn);
	if (rc != 0)
	{
		DIAG_PDEF(DIAG_E, "failed to read global condition prefixes, run without (rc: " << rc << ")");
		m_SenderToGui.NotifyCBErrorMessage("build graph", 2, "fail to read global condition prefixes from database", false);
	}
	else
	{
		// add them into the simulator
		for (Forecast::DAL::GlobalCondVec::const_iterator it = globalCondVec.begin()
			; it != globalCondVec.end()
			; ++it)
		{
			const Forecast::DAL::GlobalCondInfo& gci = *it;
			const std::string& fromdc = gci.from_dc.std();
			const std::string& todc = gci.to_dc.std();
			const std::string& prefix = gci.prefix.std();
			m_simulator->GlobalCondRule(fromdc, todc, prefix);
		}
		// resolve global conditions 
		m_simulator->GlobalCondsResolveDc();
	}

	// setup global condition prefix searcher
	m_GlobalCondSearcher.Build(globalCondVec, commVec);
}

//////////////////////////////////////////////////////////////////////////
//
void SimGraphI::ReadCalendarInformation()
{
	DBG_FNC_ENTER("SimGraphI::ReadCalendarInformation");

	DIAG_PDEF(DIAG_D, m_resourceId << ": read calendar information");
	if (m_calendarCache.ReadRefresh() != 0)
	{
		ThrowFatalError("build graph", 1, "fail to read calendar information from database");
	}

}

//////////////////////////////////////////////////////////////////////////
// used to interrupt the normal flow.
// client will get the message throw callback
// throw a 'fatal error' exception to catch on high level to return -1
void SimGraphI::ThrowFatalError( const std::string& context, long errCode, const std::string& errMsg) throw ( FatalError )
{
	DBG_FNC_ENTER("SimGraphI::ThrowFatalError");
	DIAG_PDEF(DIAG_E, m_resourceId << ": " << errMsg);
	SetGraphStatus(Forecast::BUILD_STATUS_ERROR);
	m_SenderToGui.NotifyCBErrorMessage(context.c_str(), errCode, errMsg.c_str(), true); //true is fatal error
	throw FatalError( context, errCode, errMsg);
}

//////////////////////////////////////////////////////////////////////////
// fill engine with datacenter information
//
void SimGraphI::FillEngineWithDatacenterInformation(const DAL::Definition::CommDomVec& commVec)
{
	DBG_FNC_ENTER("SimGraphI::FillEngineWithDatacenterInformation");

	CCondition::SetAddVirtualOrphanConditions(m_params.AddVirtualOrphanConditions);

	for (size_t i = 0; i < commVec.size();  ++i)
	{
		const commDom& c = commVec[i];
		if (c.enabled() == "0" || c.control_m_ver() < "610")
			continue;

		DIAG_PDEF(DIAG_D, m_resourceId << ": fill engine with datacenter information : " << c.data_center());
		DataCenterSimulAdapter dcAdapter(c);
		DataCenterI* pDc = m_simulator->CreateDataCenter(dcAdapter);
		// set data center parameters
		pDc->SetStatisticsRunType((short)m_params.StatisticsRunType);
		pDc->SetAutoOrphan(CCondition::ConditionMode(m_params.AddAllOrphanConditions));
		pDc->SetAutoConfirmMode(DataCenterI::ConfirmMode(m_params.ExecuteConfirmedJobs));
		pDc->SetDefaultElapsedTime(m_params.DefaultJobElapsedTime);
		pDc->SetPeriodicStatsGetter(&m_periodicStatsGetterImpl);
		pDc->SetDiscardOrphanConditions( m_params.DiscardOrphanConditions > 0 );
	}
}

//////////////////////////////////////////////////////////////////////////
//
void SimGraphI::LoadQuantitativeResources(DAL::Definition& defDal, const DAL::Definition::CommDomVec& commVec)
{
	DBG_FNC_ENTER("SimGraphI::LoadQuantitativeResources");

	RWDBConnection conn = DALMgr::instance()->GetConnection();

	DcQuanResDataVector DcQuantVec;
	if(defDal.ReadQuantResources(DcQuantVec,true, commVec, &conn) !=0 )
	{
		ThrowFatalError("build graph", 1, "fail to read Quantitative resources definitions from database");
	}
	m_simulator->UpdateQuantResources(DcQuantVec);

}

//////////////////////////////////////////////////////////////////////////
//
int SimGraphI::CountNumberOfTablesToProcess(const DAL::SimSystemState::DataCenterMap& dataCenterMap)
{
	DBG_FNC_ENTER("SimGraphI::CountNumberOfTablesToProcess");
	int progressMaxPos = 0;

	for (Forecast::DAL::SimSystemState::DataCenterMap::const_iterator dcIt = dataCenterMap.begin()
		; dcIt != dataCenterMap.end() && !m_stopFlag
		; ++dcIt)
	{
		const Forecast::DAL::SimSystemState::UserDailyMap& user_dailyMap = (*dcIt).second;
		// for each datacenter
		for (Forecast::DAL::SimSystemState::UserDailyMap::const_iterator udIt = user_dailyMap.begin()
			; udIt != user_dailyMap.end() && !m_stopFlag
			; ++udIt)
		{
			// for each user daily
			Forecast::DAL::SimSystemState::TimeTableIdsPair udTimeTableIds = (*udIt).second;
			Forecast::DAL::SimSystemState::TableIdVec& table_ids = udTimeTableIds.second;
			progressMaxPos += (int)table_ids.size();
		}
	}

	return progressMaxPos;

}

//////////////////////////////////////////////////////////////////////////
// process dynamic user daily information into 'dataCenterMap'
//
void SimGraphI::ProcessDynamicUserDailyInformation(
	const DataCenterUserDailyVec& dy_user_daily_to_process,
	const bsm::DefTableInfos& defTables,
	DAL::SimSystemState::DataCenterMap& dataCenterMap)
{
	DBG_FNC_ENTER("SimGraphI::ProcessDynamicUserDailyInformation");

	DataCenterUserDailyVec::const_iterator dyUdIt = dy_user_daily_to_process.begin();
	for (; dyUdIt != dy_user_daily_to_process.end(); ++dyUdIt)
	{
		const std::string& dc = (*dyUdIt).first;
		const std::string& ud = (*dyUdIt).second;
		Forecast::DAL::SimSystemState::TimeTableIdsPair& p = dataCenterMap[dc][ud];

		for (size_t i = 0; i < defTables.size(); ++i)
		{
			if (defTables[i].m_DataCenter == dc && defTables[i].m_User_Daily == ud)
			{
				int table_id = defTables[i].m_Table_ID;
				p.second.push_back(table_id);
			}
		}
	}

}

//////////////////////////////////////////////////////////////////////////
//
void SimGraphI::ProcessJobDynamicUserDaily( const std::string& JobToOrderName,
						   const Forecast::DAL::SimSystemState::UserDailyMap& user_dailyMap,
						   const std::string& data_center,
						   const DataCenterUserDailyVec& dy_user_daily_processed,
						   DataCenterUserDailyVec& dy_user_daily_to_process
						   )
{
	DBG_FNC_ENTER("SimGraphI::ProcessJobDynamicUserDaily");

	//If we are not going to process it
	if(user_dailyMap.find(JobToOrderName)==user_dailyMap.end())
	{
		// if we didn't processed this user daily
		DataCenterUserDailyVec::const_iterator dcudIt = std::find_if( 
			dy_user_daily_processed.begin(), 
			dy_user_daily_processed.end(), 
			DCUDPairLookup(data_center,JobToOrderName ));

		if (dcudIt == dy_user_daily_processed.end())
		{
			// if it is not in our current processing list
			dcudIt = std::find_if( 
				dy_user_daily_to_process.begin(), 
				dy_user_daily_to_process.end(), 
				DCUDPairLookup(data_center, JobToOrderName));
			if (dcudIt == dy_user_daily_to_process.end())
			{
				// add data_center and user_daliy to our processing list
				dy_user_daily_to_process.push_back( 
					std::make_pair( data_center, JobToOrderName ));
			}
		}
	}

}

}}	// Forecast::Service


OUTPUT_END
Execute (c:\utils\ccm_task_diff.pl:228): diff -u C:/Tasks/43731/old/SimGraphI.cpp C:/Tasks/43731/new/SimGraphI.cpp
Execute (c:\utils\ccm_task_diff.pl:228): OUTPUT_BEGIN
--- C:/Tasks/43731/old/SimGraphI.cpp	Thu Dec 24 11:29:14 2009
+++ C:/Tasks/43731/new/SimGraphI.cpp	Thu Dec 24 11:29:14 2009
@@ -3,13 +3,13 @@
  *  BMC Software Inc.
  *
  *	file %name:	SimGraphI.cpp %
- *	%date_created:	Thu Dec 10 13:24:06 2009 %
+ *	%date_created:	Tue Dec 15 10:03:08 2009 %
  *	description:	
  *
  */
 
 #ifndef lint 
-static const char _SimGraphI_cpp_cpp[] = "@(#) %name: SimGraphI.cpp %, %cvtype: cpp %, %date_modified: %, %derived_by: yakovt %, %version: 81.1.3.1.2 %, %instance: 4 %, %compiled: "__DATE__", "__TIME__" %, %file_path: "__FILE__ " %(#)@";
+static const char _SimGraphI_cpp_cpp[] = "@(#) %name: SimGraphI.cpp %, %cvtype: cpp %, %date_modified: %, %derived_by: yakovt %, %version: 81.1.3.1.3 %, %instance: 4 %, %compiled: "__DATE__", "__TIME__" %, %file_path: "__FILE__ " %(#)@";
 #endif
 
 #include "stdafx.h"
@@ -1257,15 +1257,16 @@
 	}
 	catch(CORBA::SystemException& se)
 	{
-		exceptionMsg = "Got system exception during simulation : " + em::tos(se);
+		exceptionMsg = "Got CORBA system exception during simulation : " + em::tos(se);
 	}
 	catch( const Forecast::Common::FcException& e)
 	{
 		exceptionMsg = "Got Forecast exception: " + em::tos(e.what());
 		m_SenderToGui.NotifyCBErrorMessage("Run Simulation", 1, exceptionMsg, true);
 	}
-	catch( const FatalError&  )
+	catch( const FatalError&  e)
 	{
+		exceptionMsg = "Got FatalError: " + em::tos(e.what());
 		//do nothing -- error handling was in ThrowFatalError
 	}
 	catch( const EmException& e )
@@ -1276,7 +1277,7 @@
 
 	if( rc != 0 )
 	{
-		DIAG_PDEF( DIAG_D, exceptionMsg );
+		DIAG_PDEF( DIAG_W, exceptionMsg );
 		m_stopFlag = true;
 		SetSimStatus(Forecast::BUILD_STATUS_ERROR);
 	}

OUTPUT_END
Execute (c:\utils\ccm_task_diff.pl:145): EXECUTE_CMD: ccm history SimGraphI_AddToSim.cpp#3.1.1.1.1.1.1:cpp:1
Execute (c:\utils\ccm_task_diff.pl:145): OUTPUT_BEGIN
Object:  SimGraphI_AddToSim.cpp#1 (cpp:1)
Owner:   yakovt
State:   sqa
Created: Sun Aug 31 12:06:31 2008
Task:    35469
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
Successors:
	SimGraphI_AddToSim.cpp#2:cpp:1
*****************************************************************************
Object:  SimGraphI_AddToSim.cpp#2 (cpp:1)
Owner:   yakovt
State:   sqa
Created: Mon Oct 06 09:20:04 2008
Task:    36206
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI_AddToSim.cpp#1:cpp:1
Successors:
	SimGraphI_AddToSim.cpp#3:cpp:1
*****************************************************************************
Object:  SimGraphI_AddToSim.cpp#3 (cpp:1)
Owner:   yakovt
State:   released
Created: Thu Dec 25 19:08:01 2008
Task:    37415
Comment:
changed to sqa state by GAP automatic approval

Predecessors:
	SimGraphI_AddToSim.cpp#2:cpp:1
Successors:
	SimGraphI_AddToSim.cpp#4:cpp:1
	SimGraphI_AddToSim.cpp#3.1.1:cpp:1
	SimGraphI_AddToSim.cpp#3.2.1:cpp:1
*****************************************************************************
Object:  SimGraphI_AddToSim.cpp#4 (cpp:1)
Owner:   yakovt
State:   sqa
Created: Wed Jul 29 16:26:54 2009
Task:    40595
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI_AddToSim.cpp#3:cpp:1
Successors:
	SimGraphI_AddToSim.cpp#5:cpp:1
*****************************************************************************
Object:  SimGraphI_AddToSim.cpp#5 (cpp:1)
Owner:   mgendelm
State:   sqa
Created: Wed Oct 21 21:43:14 2009
Task:    12802
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI_AddToSim.cpp#4:cpp:1
Successors:
	SimGraphI_AddToSim.cpp#3.1.2:cpp:1
*****************************************************************************
Object:  SimGraphI_AddToSim.cpp#3.1.1 (cpp:1)
Owner:   tadmon
State:   sqa
Created: Thu Dec 03 10:43:51 2009
Task:    43369
Comment:
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI_AddToSim.cpp#3:cpp:1
Successors:
	SimGraphI_AddToSim.cpp#3.1.2:cpp:1
	SimGraphI_AddToSim.cpp#3.1.1.1.1:cpp:1
*****************************************************************************
Object:  SimGraphI_AddToSim.cpp#3.1.2 (cpp:1)
Owner:   tadmon
State:   sqa
Created: Thu Dec 03 17:03:23 2009
Task:    43425
Comment:
Merged 'SimGraphI_AddToSim.cpp#3.1.1' with 'SimGraphI_AddToSim.cpp#5'.
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI_AddToSim.cpp#5:cpp:1
	SimGraphI_AddToSim.cpp#3.1.1:cpp:1
Successors:
	SimGraphI_AddToSim.cpp#3.1.1.1.2:cpp:1
*****************************************************************************
Object:  SimGraphI_AddToSim.cpp#3.2.1 (cpp:1)
Owner:   barak
State:   integrate
Created: Mon Dec 07 12:56:14 2009
Task:    43501
Comment:

Predecessors:
	SimGraphI_AddToSim.cpp#3:cpp:1
Successors:
	SimGraphI_AddToSim.cpp#3.1.1.1.1:cpp:1
*****************************************************************************
Object:  SimGraphI_AddToSim.cpp#3.1.1.1.1 (cpp:1)
Owner:   tadmon
State:   released
Created: Mon Dec 07 17:17:46 2009
Task:    43534
Comment:
Merged 'SimGraphI_AddToSim.cpp#3.1.1' with 'SimGraphI_AddToSim.cpp#3.2.1'.
changed to sqa state by GAP automatic approval

Predecessors:
	SimGraphI_AddToSim.cpp#3.1.1:cpp:1
	SimGraphI_AddToSim.cpp#3.2.1:cpp:1
Successors:
	SimGraphI_AddToSim.cpp#3.1.1.1.2:cpp:1
	SimGraphI_AddToSim.cpp#3.1.1.1.1.1.1:cpp:1
*****************************************************************************
Object:  SimGraphI_AddToSim.cpp#3.1.1.1.2 (cpp:1)
Owner:   tadmon
State:   sqa
Created: Tue Dec 08 18:25:04 2009
Task:    43595
Comment:
Merged 'SimGraphI_AddToSim.cpp#3.1.1.1.1' with 'SimGraphI_AddToSim.cpp#3.1.2'.
changed to sqa state by GAP automatic approval
Predecessors:
	SimGraphI_AddToSim.cpp#3.1.2:cpp:1
	SimGraphI_AddToSim.cpp#3.1.1.1.1:cpp:1
Successors:
	SimGraphI_AddToSim.cpp#3.1.1.1.3:cpp:1
*****************************************************************************
Object:  SimGraphI_AddToSim.cpp#3.1.1.1.1.1.1 (cpp:1)
Owner:   yakovt
State:   integrate
Created: Thu Dec 17 11:22:05 2009
Task:    43731
Comment:

Predecessors:
	SimGraphI_AddToSim.cpp#3.1.1.1.1:cpp:1
Successors:
	SimGraphI_AddToSim.cpp#3.1.1.1.3:cpp:1
*****************************************************************************
Object:  SimGraphI_AddToSim.cpp#3.1.1.1.3 (cpp:1)
Owner:   yakovt
State:   integrate
Created: Wed Dec 23 18:42:42 2009
Task:    43956
Comment:

Predecessors:
	SimGraphI_AddToSim.cpp#3.1.1.1.2:cpp:1
	SimGraphI_AddToSim.cpp#3.1.1.1.1.1.1:cpp:1
Successors:
*****************************************************************************

OUTPUT_END
Execute (c:\utils\ccm_task_diff.pl:157): EXECUTE_CMD: ccm finduse SimGraphI_AddToSim.cpp#3.1.1.1.3:cpp:1
Execute (c:\utils\ccm_task_diff.pl:157): OUTPUT_BEGIN
SimGraphI_AddToSim.cpp#3.1.1.1.3 integrate yakovt cpp ECSNT 1 43956
	ECSNT\ForecastService\SimGraphI_AddToSim.cpp#3.1.1.1.3@ECSNT#700yakovt-win:project:4
	ECSNT\ForecastService\SimGraphI_AddToSim.cpp#3.1.1.1.3@ECSNT#700_hani_win:project:4
	ECSNT\ForecastService\SimGraphI_AddToSim.cpp#3.1.1.1.3@ECSNT#bldrem_EM700_U_CI:project:4
	ECSNT\ForecastService\SimGraphI_AddToSim.cpp#3.1.1.1.3@ECSNT#bldrem_EM700_W_CI:project:4
	ECSNT\ForecastService\SimGraphI_AddToSim.cpp#3.1.1.1.3@ECSNT#galia700windows2:project:4

OUTPUT_END
Execute (c:\utils\ccm_task_diff.pl:174): EXECUTE_CMD: ccm cat SimGraphI_AddToSim.cpp#3.1.1.1.1.1.1:cpp:1
Execute (c:\utils\ccm_task_diff.pl:174): OUTPUT_BEGIN
/**********************************************************************
*                 Copyright BMC Software Inc., 
*     as an unpublished licensed work. All rights reserved.
*     -----------------------------------------------------
*
*	C++ %name:		SimGraphI_AddToSim.cpp %
*	Instance:		1
*	Description:	
*	%created_by:	yakovt %
*	%date_created:	Thu Dec 17 11:22:05 2009 %
*
**********************************************************************/
#ifndef lint
static const char *_cxxsrc = "@(#) %filespec: SimGraphI_AddToSim.cpp#3.1.1.1.1.1.1 %  (%full_filespec: SimGraphI_AddToSim.cpp#3.1.1.1.1.1.1:cpp:1 %)";
#endif

#include "stdafx.h"
#include <ForecastService/SimGraphI_AddToSim.h>
#include <em_foundations/EmProfiler.h>
#include <BsmCommon/Helper.h>
#include <BsmCommon/DefJob.h>
#include <em_foundations/DefTableFields.h>
#include <em_foundations/EmException.h>
#include <ForecastService/DBJobSimulAdapter.h>
#include <ForecastDAL/DALMgr.h>
#include <ForecastService/BuildGraphReport.h>
#include <BsmService/PeriodicStatsAdapters.h>
#include <ForecastService/BimServiceMgr.h>
#include <ForecastCommon/ForecastParameters.h>

DIAG_REGISTER_MODULE;

namespace Forecast {
namespace Service {


//////////////////////////////////////////////////////////////////////////
// takes reference (no copy!) to the parent class
//
SimGraphI_AddToSim::SimGraphI_AddToSim(
									   CSimulator*& simulator, 
									   const Forecast::Common::ForecastParameters& params,
									   BimServiceMgr& bimServiceMgr,
									   const std::string& resourceId,
									   BuildGraphReport& LastReport,
									   PeriodicStatsGetterImpl& periodicStatsGetterImpl
									   )
: m_simulator(simulator)
, m_params(params)
, m_bimServiceMgr(bimServiceMgr)
, m_resourceId(resourceId)
, m_LastReport(LastReport)
, m_periodicStatsGetterImpl(periodicStatsGetterImpl)
{
}

SimGraphI_AddToSim::~SimGraphI_AddToSim()
{
	CloseAndWait(); //ensure  that the thread will be closed
}



//////////////////////////////////////////////////////////////////////////
//
SimGraphI_AddToSim::Message_AddToSimulator::Message_AddToSimulator(
	//input
	const bsm::DefJob&	dbjob,
	size_t				id,				//job order id 
	size_t				groupId,		// group order id
	const std::string&	NextOrderDay,
	const std::string&  PrevOrderDay,
	const std::string&	User_Daily,
	const DefTableFields& deftblFields,
	bool				Signed,
	int					UseDoCond,
	//output
	Forecast::SingleJobExtInfoSeq * extjob_seq)
: m_dbjob(dbjob)
, m_id(id)
, m_groupId(groupId)
, m_NextOrderDay(NextOrderDay)
, m_PrevOrderDay(PrevOrderDay)
, m_User_Daily(User_Daily)
, m_deftblFields(deftblFields) 
, m_Signed(Signed)
, m_UseDoCond(UseDoCond)
, m_extjob_seq(extjob_seq)
{
}


SimGraphI_AddToSim::Message_AddToSimulator::~Message_AddToSimulator()
{

}


//////////////////////////////////////////////////////////////////////////
//
void SimGraphI_AddToSim::Message_AddToSimulator::Execute(WorkingTask* task)
{
	DBG_FNC_ENTER("SimGraphI_AddToSim::Execute");

	SimGraphI_AddToSim* parent = dynamic_cast<SimGraphI_AddToSim*>(task);
	CSimulator* simulator = parent->m_simulator;
	const Forecast::Common::ForecastParameters& params = parent->m_params;
	BimServiceMgr& bimServiceMgr = parent->m_bimServiceMgr;
	const std::string& resourceId = parent->m_resourceId;

	EM_PROFILER_SCOPE(P_AddToSimulator);

	DIAG_PDEF(DIAG_D, resourceId << ": add job into the simulation engine");

	DBJobSimulAdapter jobAdapter(
		m_dbjob,
		m_id,
		m_groupId,
		m_NextOrderDay,
		m_PrevOrderDay,
		m_User_Daily,
		m_deftblFields,
		m_Signed,
		m_UseDoCond
		);

	EM_ASSERT(simulator->GetPeriodicStatsGetter() != NULL, "Internal Error: Periodic Stats Getter of the Simulator is NULL");

	SimulJobI* pSimulJob=simulator->AddJob(&jobAdapter,true);

	DIAG_PDEF(DIAG_D, "added job " << pSimulJob->GetJobName() << " with statistics " << pSimulJob->GetCurElapsedTime() );

	ProcessBimService( pSimulJob, params, bimServiceMgr, m_dbjob,m_deftblFields, m_extjob_seq );
}


//////////////////////////////////////////////////////////////////////////
//
void SimGraphI_AddToSim::Message_AddToSimulator::ProcessExtJob( const size_t& orderid, 
						  const bsm::DefJob& dbjob, 
						  const DefTableFields & table, 
						  Forecast::SingleJobExtInfoSeq * extjob_seq, 
						  BimService* svc 
						  )
			
{
	DBG_FNC_ENTER("SimGraphI_AddToSim::ProcessExtJob");

	if(extjob_seq)
	{
		extjob_seq->length(extjob_seq->length()+1);

		Forecast::SingleJobExtInfo & job = (*extjob_seq)[extjob_seq->length()-1];

		job.oid = orderid;
		job.Author = dbjob.Base().f_DBF_DEF_JOB_AUTHOR.c_str();
		job.Owner  = dbjob.Base().f_DBF_DEF_JOB_OWNER.c_str();
		job.MemLib = dbjob.Base().f_DBF_DEF_JOB_MEM_LIB.c_str();
		job.JobName = dbjob.Base().f_DBF_DEF_JOB_JOB_NAME.c_str();
		job.MemName = dbjob.Base().f_DBF_DEF_JOB_MEMNAME.c_str();
		job.NodeID = dbjob.Base().f_DBF_DEF_JOB_NODE_ID.c_str();
		job.RequestNJENode	= dbjob.Ext().f_DBF_DEF_JOB_REQ_NJE_NODE.c_str();
		job.SchedulingEnv	= dbjob.Ext().f_DBF_DEF_JOB_SCHEDULE_ENV.c_str();
		job.SystemAffinity	= dbjob.Ext().f_DBF_DEF_JOB_SYS_AFFINITY.c_str();
		job.MultiAgent      = (dbjob.Ext().f_DBF_DEF_JOB_MULTY_AGENT == "Y" ? true : false);
		job.SchedTable = table.m_SchedTable.c_str();
		job.DSN = table.m_DSN.c_str();
		job.DataCenter = table.m_DataCenter.c_str();
		job.NJENode = CORBA::string_dup("");
		if(svc)
		{
			job.BatchServiceName = svc->GetServiceName().c_str();
			job.BatchServicePriority = svc->GetPriority().c_str();
		}
		else
		{
			job.BatchServiceName = CORBA::string_dup("");
			job.BatchServicePriority = CORBA::string_dup("");
	}

	}
}

//////////////////////////////////////////////////////////////////////////
//
void SimGraphI_AddToSim::Message_AddToSimulator::ProcessBimService(SimulJobI* pSimulJob,
										   const Forecast::Common::ForecastParameters& params,
										   BimServiceMgr& bimServiceMgr,
										  const bsm::DefJob& dbjob, 
										  const DefTableFields & table, 
										  Forecast::SingleJobExtInfoSeq * extjob_seq)
{	
	DBG_FNC_ENTER("SimGraphI_AddToSim::ProcessBimService");


	if (pSimulJob->IsBIM() == true)
	{
		if(params.BimAvailable)
		{
			std::auto_ptr<BimService> pBs ( new BimService(pSimulJob) );
			pBs->SetFromDBJob(dbjob);
			if ( extjob_seq )
			{
				//TAMAR: Batch Discovery Auth override
				pBs->SetSign(true);
				ProcessExtJob(pSimulJob->GetOrderID(),dbjob,table,extjob_seq,pBs.get()); // return wrapped pointer for pBs
		
			}
			bimServiceMgr.AddService(pBs.release()); // return wrapped pointer and give up ownership
		}
		else
		{
			DIAG_PDEF( DIAG_W, "BIM service is ignoring because BIM server is not installed");
		}
	}
	else
	{
		if ( extjob_seq )
		ProcessExtJob(pSimulJob->GetOrderID(),dbjob,table,extjob_seq,NULL);
	}
}




}} // Forecast::Service

OUTPUT_END
Execute (c:\utils\ccm_task_diff.pl:128): EXECUTE_CMD: ccm diff -vc  SimGraphI_AddToSim.cpp#3.1.1.1.1.1.1:cpp:1
Execute (c:\utils\ccm_task_diff.pl:128): OUTPUT_BEGIN
Attribute name            SimGraphI_AddToSim.cpp#3.1 SimGraphI_AddToSim.cpp#3.1
------------------------- -------------------------- --------------------------
create_time               Mon Dec 07 17:17:46 2009   Thu Dec 17 11:22:05 2009  
modify_time               Tue Dec 22 18:31:05 2009   Wed Dec 23 13:25:07 2009  
owner                     tadmon                     yakovt                    
release                   6.4.0.03                   6.4.0.04                  
status                    released                   integrate                 
version                   3.1.1.1.1                  3.1.1.1.1.1.1             
source_create_time        Mon Dec 07 17:17:47 2009   Thu Dec 17 11:22:05 2009  
source_modify_time        Mon Dec 07 17:17:48 2009   Thu Dec 17 11:28:04 2009  

===============================================================================
Associated tasks differs:

SimGraphI_AddToSim.cpp#3.1.1.1.1
43534: bsm: merge task

SimGraphI_AddToSim.cpp#3.1.1.1.1.1.1
43731: 640.4: bsm: forecast: diag: print bim data  w/o name

===============================================================================
Text attribute 'comment' differs:

1,2d0
< Merged 'SimGraphI_AddToSim.cpp#3.1.1' with 'SimGraphI_AddToSim.cpp#3.2.1'.
< changed to sqa state by GAP automatic approval

===============================================================================
Text attribute 'source' differs:

9,10c9,10
< *	%created_by:	tadmon %
< *	%date_created:	Mon Dec 07 17:17:46 2009 %
---
> *	%created_by:	yakovt %
> *	%date_created:	Thu Dec 17 11:22:05 2009 %
14c14
< static const char *_cxxsrc = "@(#) %filespec: SimGraphI_AddToSim.cpp#3.1.1.1.1 %  (%full_filespec: SimGraphI_AddToSim.cpp#3.1.1.1.1:cpp:1 %)";
---
> static const char *_cxxsrc = "@(#) %filespec: SimGraphI_AddToSim.cpp#3.1.1.1.1.1.1 %  (%full_filespec: SimGraphI_AddToSim.cpp#3.1.1.1.1.1.1:cpp:1 %)";
200c200
< 			BimService* pBs= new BimService(pSimulJob);
---
> 			std::auto_ptr<BimService> pBs ( new BimService(pSimulJob) );
206c206
< 				ProcessExtJob(pSimulJob->GetOrderID(),dbjob,table,extjob_seq,pBs);
---
> 				ProcessExtJob(pSimulJob->GetOrderID(),dbjob,table,extjob_seq,pBs.get()); // return wrapped pointer for pBs
209c209
< 			bimServiceMgr.AddService(pBs);
---
> 			bimServiceMgr.AddService(pBs.release()); // return wrapped pointer and give up ownership

===============================================================================
Text attribute 'status_log' differs:

1,4c1,2
< Mon Dec  7 17:17:47 2009: Status set to 'working' by tadmon in role build_mgr
< Mon Dec  7 17:19:17 2009: Status set to 'integrate' by tadmon in role build_mgr
< Wed Dec  9 19:17:27 2009: Status set to 'sqa' by bldrem in role build_mgr
< Tue Dec 22 18:31:05 2009: Status set to 'released' by bldrem in role build_mgr
---
> Thu Dec 17 11:22:05 2009: Status set to 'working' by yakovt in role developer
> Wed Dec 23 13:25:07 2009: Status set to 'integrate' by yakovt in role developer


OUTPUT_END
Execute (c:\utils\ccm_task_diff.pl:174): EXECUTE_CMD: ccm cat SimGraphI_AddToSim.cpp#3.1.1.1.1:cpp:1
Execute (c:\utils\ccm_task_diff.pl:174): OUTPUT_BEGIN
/**********************************************************************
*                 Copyright BMC Software Inc., 
*     as an unpublished licensed work. All rights reserved.
*     -----------------------------------------------------
*
*	C++ %name:		SimGraphI_AddToSim.cpp %
*	Instance:		1
*	Description:	
*	%created_by:	tadmon %
*	%date_created:	Mon Dec 07 17:17:46 2009 %
*
**********************************************************************/
#ifndef lint
static const char *_cxxsrc = "@(#) %filespec: SimGraphI_AddToSim.cpp#3.1.1.1.1 %  (%full_filespec: SimGraphI_AddToSim.cpp#3.1.1.1.1:cpp:1 %)";
#endif

#include "stdafx.h"
#include <ForecastService/SimGraphI_AddToSim.h>
#include <em_foundations/EmProfiler.h>
#include <BsmCommon/Helper.h>
#include <BsmCommon/DefJob.h>
#include <em_foundations/DefTableFields.h>
#include <em_foundations/EmException.h>
#include <ForecastService/DBJobSimulAdapter.h>
#include <ForecastDAL/DALMgr.h>
#include <ForecastService/BuildGraphReport.h>
#include <BsmService/PeriodicStatsAdapters.h>
#include <ForecastService/BimServiceMgr.h>
#include <ForecastCommon/ForecastParameters.h>

DIAG_REGISTER_MODULE;

namespace Forecast {
namespace Service {


//////////////////////////////////////////////////////////////////////////
// takes reference (no copy!) to the parent class
//
SimGraphI_AddToSim::SimGraphI_AddToSim(
									   CSimulator*& simulator, 
									   const Forecast::Common::ForecastParameters& params,
									   BimServiceMgr& bimServiceMgr,
									   const std::string& resourceId,
									   BuildGraphReport& LastReport,
									   PeriodicStatsGetterImpl& periodicStatsGetterImpl
									   )
: m_simulator(simulator)
, m_params(params)
, m_bimServiceMgr(bimServiceMgr)
, m_resourceId(resourceId)
, m_LastReport(LastReport)
, m_periodicStatsGetterImpl(periodicStatsGetterImpl)
{
}

SimGraphI_AddToSim::~SimGraphI_AddToSim()
{
	CloseAndWait(); //ensure  that the thread will be closed
}



//////////////////////////////////////////////////////////////////////////
//
SimGraphI_AddToSim::Message_AddToSimulator::Message_AddToSimulator(
	//input
	const bsm::DefJob&	dbjob,
	size_t				id,				//job order id 
	size_t				groupId,		// group order id
	const std::string&	NextOrderDay,
	const std::string&  PrevOrderDay,
	const std::string&	User_Daily,
	const DefTableFields& deftblFields,
	bool				Signed,
	int					UseDoCond,
	//output
	Forecast::SingleJobExtInfoSeq * extjob_seq)
: m_dbjob(dbjob)
, m_id(id)
, m_groupId(groupId)
, m_NextOrderDay(NextOrderDay)
, m_PrevOrderDay(PrevOrderDay)
, m_User_Daily(User_Daily)
, m_deftblFields(deftblFields) 
, m_Signed(Signed)
, m_UseDoCond(UseDoCond)
, m_extjob_seq(extjob_seq)
{
}


SimGraphI_AddToSim::Message_AddToSimulator::~Message_AddToSimulator()
{

}


//////////////////////////////////////////////////////////////////////////
//
void SimGraphI_AddToSim::Message_AddToSimulator::Execute(WorkingTask* task)
{
	DBG_FNC_ENTER("SimGraphI_AddToSim::Execute");

	SimGraphI_AddToSim* parent = dynamic_cast<SimGraphI_AddToSim*>(task);
	CSimulator* simulator = parent->m_simulator;
	const Forecast::Common::ForecastParameters& params = parent->m_params;
	BimServiceMgr& bimServiceMgr = parent->m_bimServiceMgr;
	const std::string& resourceId = parent->m_resourceId;

	EM_PROFILER_SCOPE(P_AddToSimulator);

	DIAG_PDEF(DIAG_D, resourceId << ": add job into the simulation engine");

	DBJobSimulAdapter jobAdapter(
		m_dbjob,
		m_id,
		m_groupId,
		m_NextOrderDay,
		m_PrevOrderDay,
		m_User_Daily,
		m_deftblFields,
		m_Signed,
		m_UseDoCond
		);

	EM_ASSERT(simulator->GetPeriodicStatsGetter() != NULL, "Internal Error: Periodic Stats Getter of the Simulator is NULL");

	SimulJobI* pSimulJob=simulator->AddJob(&jobAdapter,true);

	DIAG_PDEF(DIAG_D, "added job " << pSimulJob->GetJobName() << " with statistics " << pSimulJob->GetCurElapsedTime() );

	ProcessBimService( pSimulJob, params, bimServiceMgr, m_dbjob,m_deftblFields, m_extjob_seq );
}


//////////////////////////////////////////////////////////////////////////
//
void SimGraphI_AddToSim::Message_AddToSimulator::ProcessExtJob( const size_t& orderid, 
						  const bsm::DefJob& dbjob, 
						  const DefTableFields & table, 
						  Forecast::SingleJobExtInfoSeq * extjob_seq, 
						  BimService* svc 
						  )
			
{
	DBG_FNC_ENTER("SimGraphI_AddToSim::ProcessExtJob");

	if(extjob_seq)
	{
		extjob_seq->length(extjob_seq->length()+1);

		Forecast::SingleJobExtInfo & job = (*extjob_seq)[extjob_seq->length()-1];

		job.oid = orderid;
		job.Author = dbjob.Base().f_DBF_DEF_JOB_AUTHOR.c_str();
		job.Owner  = dbjob.Base().f_DBF_DEF_JOB_OWNER.c_str();
		job.MemLib = dbjob.Base().f_DBF_DEF_JOB_MEM_LIB.c_str();
		job.JobName = dbjob.Base().f_DBF_DEF_JOB_JOB_NAME.c_str();
		job.MemName = dbjob.Base().f_DBF_DEF_JOB_MEMNAME.c_str();
		job.NodeID = dbjob.Base().f_DBF_DEF_JOB_NODE_ID.c_str();
		job.RequestNJENode	= dbjob.Ext().f_DBF_DEF_JOB_REQ_NJE_NODE.c_str();
		job.SchedulingEnv	= dbjob.Ext().f_DBF_DEF_JOB_SCHEDULE_ENV.c_str();
		job.SystemAffinity	= dbjob.Ext().f_DBF_DEF_JOB_SYS_AFFINITY.c_str();
		job.MultiAgent      = (dbjob.Ext().f_DBF_DEF_JOB_MULTY_AGENT == "Y" ? true : false);
		job.SchedTable = table.m_SchedTable.c_str();
		job.DSN = table.m_DSN.c_str();
		job.DataCenter = table.m_DataCenter.c_str();
		job.NJENode = CORBA::string_dup("");
		if(svc)
		{
			job.BatchServiceName = svc->GetServiceName().c_str();
			job.BatchServicePriority = svc->GetPriority().c_str();
		}
		else
		{
			job.BatchServiceName = CORBA::string_dup("");
			job.BatchServicePriority = CORBA::string_dup("");
	}

	}
}

//////////////////////////////////////////////////////////////////////////
//
void SimGraphI_AddToSim::Message_AddToSimulator::ProcessBimService(SimulJobI* pSimulJob,
										   const Forecast::Common::ForecastParameters& params,
										   BimServiceMgr& bimServiceMgr,
										  const bsm::DefJob& dbjob, 
										  const DefTableFields & table, 
										  Forecast::SingleJobExtInfoSeq * extjob_seq)
{	
	DBG_FNC_ENTER("SimGraphI_AddToSim::ProcessBimService");


	if (pSimulJob->IsBIM() == true)
	{
		if(params.BimAvailable)
		{
			BimService* pBs= new BimService(pSimulJob);
			pBs->SetFromDBJob(dbjob);
			if ( extjob_seq )
			{
				//TAMAR: Batch Discovery Auth override
				pBs->SetSign(true);
				ProcessExtJob(pSimulJob->GetOrderID(),dbjob,table,extjob_seq,pBs);
		
			}
			bimServiceMgr.AddService(pBs);
		}
		else
		{
			DIAG_PDEF( DIAG_W, "BIM service is ignoring because BIM server is not installed");
		}
	}
	else
	{
		if ( extjob_seq )
		ProcessExtJob(pSimulJob->GetOrderID(),dbjob,table,extjob_seq,NULL);
	}
}




}} // Forecast::Service

OUTPUT_END
Execute (c:\utils\ccm_task_diff.pl:228): diff -u C:/Tasks/43731/old/SimGraphI_AddToSim.cpp C:/Tasks/43731/new/SimGraphI_AddToSim.cpp
Execute (c:\utils\ccm_task_diff.pl:228): OUTPUT_BEGIN
--- C:/Tasks/43731/old/SimGraphI_AddToSim.cpp	Thu Dec 24 11:29:15 2009
+++ C:/Tasks/43731/new/SimGraphI_AddToSim.cpp	Thu Dec 24 11:29:15 2009
@@ -6,12 +6,12 @@
 *	C++ %name:		SimGraphI_AddToSim.cpp %
 *	Instance:		1
 *	Description:	
-*	%created_by:	tadmon %
-*	%date_created:	Mon Dec 07 17:17:46 2009 %
+*	%created_by:	yakovt %
+*	%date_created:	Thu Dec 17 11:22:05 2009 %
 *
 **********************************************************************/
 #ifndef lint
-static const char *_cxxsrc = "@(#) %filespec: SimGraphI_AddToSim.cpp#3.1.1.1.1 %  (%full_filespec: SimGraphI_AddToSim.cpp#3.1.1.1.1:cpp:1 %)";
+static const char *_cxxsrc = "@(#) %filespec: SimGraphI_AddToSim.cpp#3.1.1.1.1.1.1 %  (%full_filespec: SimGraphI_AddToSim.cpp#3.1.1.1.1.1.1:cpp:1 %)";
 #endif
 
 #include "stdafx.h"
@@ -197,16 +197,16 @@
 	{
 		if(params.BimAvailable)
 		{
-			BimService* pBs= new BimService(pSimulJob);
+			std::auto_ptr<BimService> pBs ( new BimService(pSimulJob) );
 			pBs->SetFromDBJob(dbjob);
 			if ( extjob_seq )
 			{
 				//TAMAR: Batch Discovery Auth override
 				pBs->SetSign(true);
-				ProcessExtJob(pSimulJob->GetOrderID(),dbjob,table,extjob_seq,pBs);
+				ProcessExtJob(pSimulJob->GetOrderID(),dbjob,table,extjob_seq,pBs.get()); // return wrapped pointer for pBs
 		
 			}
-			bimServiceMgr.AddService(pBs);
+			bimServiceMgr.AddService(pBs.release()); // return wrapped pointer and give up ownership
 		}
 		else
 		{

OUTPUT_END
